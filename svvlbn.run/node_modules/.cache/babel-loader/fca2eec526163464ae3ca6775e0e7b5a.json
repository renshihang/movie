{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { AttributeType, BlendType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nvar normalFrag = \"\\nuniform float u_opacity : 1;\\nvarying vec4 v_color;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  gl_FragColor = v_color;\\n  gl_FragColor.a = u_opacity;\\n\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\nvar normalVert = \"\\nattribute vec3 a_Position;\\nuniform mat4 u_ModelMatrix;\\nattribute float a_Size;\\nattribute vec4 a_Color;\\nvarying vec4 v_color;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  v_color = a_Color;\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0)) + vec4(a_Size / 2.,-a_Size /2.,0.,0.);\\n  gl_Position = project_common_position_to_clipspace(project_pos);\\n  gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport function PointTriangulation(feature) {\n  var coordinates = feature.coordinates;\n  return {\n    vertices: _toConsumableArray(coordinates),\n    indices: [0],\n    size: coordinates.length\n  };\n}\n\nvar NormalModel = function (_BaseModel) {\n  _inherits(NormalModel, _BaseModel);\n\n  function NormalModel() {\n    _classCallCheck(this, NormalModel);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NormalModel).apply(this, arguments));\n  }\n\n  _createClass(NormalModel, [{\n    key: \"getDefaultStyle\",\n    value: function getDefaultStyle() {\n      return {\n        blend: 'additive'\n      };\n    }\n  }, {\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          _ref$opacity = _ref.opacity,\n          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,\n          _ref$stroke = _ref.stroke,\n          stroke = _ref$stroke === void 0 ? 'rgb(0,0,0,0)' : _ref$stroke,\n          _ref$strokeWidth = _ref.strokeWidth,\n          strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth;\n\n      return {\n        u_opacity: opacity,\n        u_stroke_width: strokeWidth,\n        u_stroke_color: rgb2arr(stroke)\n      };\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      return [this.layer.buildLayerModel({\n        moduleName: 'normalpoint',\n        vertexShader: normalVert,\n        fragmentShader: normalFrag,\n        triangulation: PointTriangulation,\n        depth: {\n          enable: false\n        },\n        primitive: gl.POINTS,\n        blend: this.getBlend()\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var size = feature.size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n    }\n  }, {\n    key: \"defaultStyleOptions\",\n    value: function defaultStyleOptions() {\n      return {\n        blend: BlendType.additive\n      };\n    }\n  }]);\n\n  return NormalModel;\n}(BaseModel);\n\nexport { NormalModel as default };","map":{"version":3,"sources":["../../../src/point/models/normal.ts"],"names":["coordinates","feature","vertices","indices","size","length","NormalModel","BaseModel","blend","opacity","stroke","strokeWidth","u_opacity","u_stroke_width","u_stroke_color","rgb2arr","moduleName","vertexShader","fragmentShader","triangulation","depth","enable","primitive","gl","name","type","AttributeType","descriptor","buffer","usage","data","FLOAT","update","Array","BlendType","additive"],"mappings":";;;;;;AAAA,SAAA,aAAA,EAAA,SAAA,EAAA,EAAA,QAAA,eAAA;AAUA,SAAA,OAAA,QAAA,gBAAA;AACA,OAAA,SAAA,MAAA,sBAAA;;;AASA,OAAO,SAAA,kBAAA,CAAA,OAAA,EAAqD;AAC1D,MAAMA,WAAW,GAAGC,OAAO,CAA3B,WAAA;AACA,SAAO;AACLC,IAAAA,QAAQ,EAAA,kBAAA,CADH,WACG,CADH;AAELC,IAAAA,OAAO,EAAE,CAFJ,CAEI,CAFJ;AAGLC,IAAAA,IAAI,EAAEJ,WAAW,CAACK;AAHb,GAAP;AAKD;;IAEoBC,W;;;;;;;;;;;sCACuD;AACxE,aAAO;AACLE,QAAAA,KAAK,EAAE;AADF,OAAP;AAGD;;;mCACoC;AAAA,UAAA,IAAA,GAK/B,KAAA,KAAA,CAL+B,cAK/B,EAL+B;AAAA,UAAA,YAAA,GAAA,IAAA,CAAA,OAAA;AAAA,UAEjCC,OAFiC,GAAA,YAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,YAAA;AAAA,UAAA,WAAA,GAAA,IAAA,CAAA,MAAA;AAAA,UAGjCC,MAHiC,GAAA,WAAA,KAAA,KAAA,CAAA,GAAA,cAAA,GAAA,WAAA;AAAA,UAAA,gBAAA,GAAA,IAAA,CAAA,WAAA;AAAA,UAIjCC,WAJiC,GAAA,gBAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,gBAAA;;AAMnC,aAAO;AACLC,QAAAA,SAAS,EADJ,OAAA;AAELC,QAAAA,cAAc,EAFT,WAAA;AAGLC,QAAAA,cAAc,EAAEC,OAAO,CAAA,MAAA;AAHlB,OAAP;AAKD;;;kCAC8B;AAC7B,aAAO,CACL,KAAA,KAAA,CAAA,eAAA,CAA2B;AACzBC,QAAAA,UAAU,EADe,aAAA;AAEzBC,QAAAA,YAAY,EAFa,UAAA;AAGzBC,QAAAA,cAAc,EAHW,UAAA;AAIzBC,QAAAA,aAAa,EAJY,kBAAA;AAKzBC,QAAAA,KAAK,EAAE;AAAEC,UAAAA,MAAM,EAAE;AAAV,SALkB;AAMzBC,QAAAA,SAAS,EAAEC,EAAE,CANY,MAAA;AAOzBf,QAAAA,KAAK,EAAE,KAAA,QAAA;AAPkB,OAA3B,CADK,CAAP;AAWD;;;gDAEqC;AAEpC,WAAA,qBAAA,CAAA,sBAAA,CAAkD;AAChDgB,QAAAA,IAAI,EAD4C,MAAA;AAEhDC,QAAAA,IAAI,EAAEC,aAAa,CAF6B,SAAA;AAGhDC,QAAAA,UAAU,EAAE;AACVH,UAAAA,IAAI,EADM,QAAA;AAEVI,UAAAA,MAAM,EAAE;AAENC,YAAAA,KAAK,EAAEN,EAAE,CAFH,YAAA;AAGNO,YAAAA,IAAI,EAHE,EAAA;AAINL,YAAAA,IAAI,EAAEF,EAAE,CAACQ;AAJH,WAFE;AAQV3B,UAAAA,IAAI,EARM,CAAA;AASV4B,UAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,OAAA,EAAA,UAAA,EAAA,MAAA,EAAA,YAAA,EAKH;AAAA,gBACK5B,IADL,GACcH,OADd,CAAA,IAAA;AAEH,mBAAOgC,KAAK,CAALA,OAAAA,CAAAA,IAAAA,IAAsB,CAAC7B,IAAI,CAA3B6B,CAA2B,CAAL,CAAtBA,GAAkC,CAAzC,IAAyC,CAAzC;AACD;AAjBS;AAHoC,OAAlD;AAuBD;;;0CAGC;AACA,aAAO;AACLzB,QAAAA,KAAK,EAAE0B,SAAS,CAACC;AADZ,OAAP;AAGD;;;;EAhEsC5B,S;;SAApBD,W","sourcesContent":["import {\n  AttributeType,\n  BlendType,\n  gl,\n  IEncodeFeature,\n  ILayerConfig,\n  IModel,\n  IModelUniform,\n} from '@antv/l7-core';\n\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nimport { BlendTypes } from '../../utils/blend';\nimport normalFrag from '../shaders/normal_frag.glsl';\nimport normalVert from '../shaders/normal_vert.glsl';\ninterface IPointLayerStyleOptions {\n  opacity: number;\n  strokeWidth: number;\n  stroke: string;\n}\nexport function PointTriangulation(feature: IEncodeFeature) {\n  const coordinates = feature.coordinates as number[];\n  return {\n    vertices: [...coordinates],\n    indices: [0],\n    size: coordinates.length,\n  };\n}\n\nexport default class NormalModel extends BaseModel {\n  public getDefaultStyle(): Partial<IPointLayerStyleOptions & ILayerConfig> {\n    return {\n      blend: 'additive',\n    };\n  }\n  public getUninforms(): IModelUniform {\n    const {\n      opacity = 1,\n      stroke = 'rgb(0,0,0,0)',\n      strokeWidth = 1,\n    } = this.layer.getLayerConfig() as IPointLayerStyleOptions;\n    return {\n      u_opacity: opacity,\n      u_stroke_width: strokeWidth,\n      u_stroke_color: rgb2arr(stroke),\n    };\n  }\n  public buildModels(): IModel[] {\n    return [\n      this.layer.buildLayerModel({\n        moduleName: 'normalpoint',\n        vertexShader: normalVert,\n        fragmentShader: normalFrag,\n        triangulation: PointTriangulation,\n        depth: { enable: false },\n        primitive: gl.POINTS,\n        blend: this.getBlend(),\n      }),\n    ];\n  }\n\n  protected registerBuiltinAttributes() {\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 1,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const { size } = feature;\n          return Array.isArray(size) ? [size[0]] : [size as number];\n        },\n      },\n    });\n  }\n  private defaultStyleOptions(): Partial<\n    IPointLayerStyleOptions & ILayerConfig\n  > {\n    return {\n      blend: BlendType.additive,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}