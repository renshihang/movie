{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport rewind from '@mapbox/geojson-rewind';\nimport { getCoords } from '@turf/invariant';\nimport * as turfMeta from '@turf/meta';\nexport default function geoJSON(data, cfg) {\n  rewind(data, true);\n  var resultData = [];\n  var featureKeys = {};\n  data.features = data.features.filter(function (item) {\n    var geometry = item.geometry;\n    return item != null && geometry && geometry.type && geometry.coordinates && geometry.coordinates.length > 0;\n  });\n\n  if (data.features.length === 0) {\n    return {\n      dataArray: [],\n      featureKeys: featureKeys\n    };\n  }\n\n  var i = 0;\n  turfMeta.flattenEach(data, function (currentFeature, featureIndex) {\n    var coord = getCoords(currentFeature);\n    var id = featureIndex;\n\n    if (currentFeature.geometry.type === 'Polygon') {\n      coord.forEach(function (coor) {\n        var dataItem = _objectSpread({}, currentFeature.properties, {\n          coordinates: [coor],\n          _id: id\n        });\n\n        resultData.push(dataItem);\n      });\n    } else {\n      var dataItem = _objectSpread({}, currentFeature.properties, {\n        coordinates: coord,\n        _id: id\n      });\n\n      resultData.push(dataItem);\n    }\n  });\n  return {\n    dataArray: resultData,\n    featureKeys: featureKeys\n  };\n}","map":{"version":3,"sources":["../../src/parser/geojson.ts"],"names":["rewind","resultData","featureKeys","data","geometry","item","dataArray","i","turfMeta","coord","getCoords","id","currentFeature","dataItem","coordinates","_id"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,OAAA,MAAA,MAAA,wBAAA;AAQA,SAAA,SAAA,QAAA,iBAAA;AACA,OAAO,KAAP,QAAA,MAAA,YAAA;AASA,eAAe,SAAA,OAAA,CAAA,IAAA,EAAA,GAAA,EAGA;AACbA,EAAAA,MAAM,CAAA,IAAA,EAANA,IAAM,CAANA;AACA,MAAMC,UAA4B,GAAlC,EAAA;AACA,MAAMC,WAAwB,GAA9B,EAAA;AACAC,EAAAA,IAAI,CAAJA,QAAAA,GAAgB,IAAI,CAAJ,QAAA,CAAA,MAAA,CAAqB,UAAA,IAAA,EAAmB;AACtD,QAAMC,QAAyB,GAAGC,IAAI,CAAtC,QAAA;AACA,WACEA,IAAI,IAAJA,IAAAA,IAAAA,QAAAA,IAEAD,QAAQ,CAFRC,IAAAA,IAGAD,QAAQ,CAHRC,WAAAA,IAIAD,QAAQ,CAARA,WAAAA,CAAAA,MAAAA,GALF,CAAA;AAFFD,GAAgB,CAAhBA;;AAUA,MAAIA,IAAI,CAAJA,QAAAA,CAAAA,MAAAA,KAAJ,CAAA,EAAgC;AAC9B,WAAO;AACLG,MAAAA,SAAS,EADJ,EAAA;AAELJ,MAAAA,WAAW,EAAXA;AAFK,KAAP;AAID;;AAED,MAAMK,CAAC,GAAP,CAAA;AAEAC,EAAAA,QAAQ,CAARA,WAAAA,CAAAA,IAAAA,EAEE,UAAA,cAAA,EAAA,YAAA,EAA2E;AACzE,QAAMC,KAAK,GAAGC,SAAS,CAAvB,cAAuB,CAAvB;AACA,QAAMC,EAAE,GAAR,YAAA;;AACA,QAAIC,cAAc,CAAdA,QAAAA,CAAAA,IAAAA,KAAJ,SAAA,EAAgD;AAC9CH,MAAAA,KAAK,CAALA,OAAAA,CAAc,UAAA,IAAA,EAAU;AACtB,YAAMI,QAAQ,GAAA,aAAA,CAAA,EAAA,EACTD,cAAc,CADL,UAAA,EAAA;AAEZE,UAAAA,WAAW,EAAE,CAFD,IAEC,CAFD;AAGZC,UAAAA,GAAG,EAAEJ;AAHO,SAAA,CAAd;;AAKAV,QAAAA,UAAU,CAAVA,IAAAA,CAAAA,QAAAA;AANFQ,OAAAA;AADF,KAAA,MASO;AACL,UAAMI,QAAwB,GAAA,aAAA,CAAA,EAAA,EACzBD,cAAc,CADW,UAAA,EAAA;AAE5BE,QAAAA,WAAW,EAFiB,KAAA;AAG5BC,QAAAA,GAAG,EAAEJ;AAHuB,OAAA,CAA9B;;AAKAV,MAAAA,UAAU,CAAVA,IAAAA,CAAAA,QAAAA;AACD;AArBLO,GAAAA;AAwBA,SAAO;AACLF,IAAAA,SAAS,EADJ,UAAA;AAELJ,IAAAA,WAAW,EAAXA;AAFK,GAAP;AAID","sourcesContent":["// @ts-ignore\nimport rewind from '@mapbox/geojson-rewind';\nimport {\n  Feature,\n  FeatureCollection,\n  Geometries,\n  Geometry,\n  Properties,\n} from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport * as turfMeta from '@turf/meta';\nimport { IFeatureKey, IParseDataItem, IParserData } from '../interface';\ninterface IGeoJSON {\n  features: object[];\n}\ninterface IParserCFG {\n  idField?: string;\n  [key: string]: any;\n}\nexport default function geoJSON(\n  data: FeatureCollection<Geometries, Properties>,\n  cfg?: IParserCFG,\n): IParserData {\n  rewind(data, true); // 设置地理多边形方向 If clockwise is true, the outer ring is clockwise, otherwise it is counterclockwise.\n  const resultData: IParseDataItem[] = [];\n  const featureKeys: IFeatureKey = {};\n  data.features = data.features.filter((item: Feature) => {\n    const geometry: Geometry | null = item.geometry as Geometry;\n    return (\n      item != null &&\n      geometry &&\n      geometry.type &&\n      geometry.coordinates &&\n      geometry.coordinates.length > 0\n    );\n  });\n  if (data.features.length === 0) {\n    return {\n      dataArray: [],\n      featureKeys,\n    };\n  }\n  // 数据为空时处理\n  const i = 0;\n  // multi polygon 拆分\n  turfMeta.flattenEach(\n    data,\n    (currentFeature: Feature<Geometries, Properties>, featureIndex: number) => {\n      const coord = getCoords(currentFeature);\n      const id = featureIndex;\n      if (currentFeature.geometry.type === 'Polygon') {\n        coord.forEach((coor) => {\n          const dataItem = {\n            ...currentFeature.properties,\n            coordinates: [coor],\n            _id: id,\n          };\n          resultData.push(dataItem);\n        });\n      } else {\n        const dataItem: IParseDataItem = {\n          ...currentFeature.properties,\n          coordinates: coord,\n          _id: id,\n        };\n        resultData.push(dataItem);\n      }\n    },\n  );\n  return {\n    dataArray: resultData,\n    featureKeys,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}