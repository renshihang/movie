{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _class, _class2, _descriptor, _temp;\n\nimport { inject, injectable, postConstruct } from 'inversify';\nimport { TYPES } from '../../../types';\nimport { gl } from '../gl';\nvar PostProcessor = (_dec = injectable(), _dec2 = inject(TYPES.IRendererService), _dec3 = postConstruct(), _dec(_class = (_class2 = (_temp = function () {\n  function PostProcessor() {\n    _classCallCheck(this, PostProcessor);\n\n    _initializerDefineProperty(this, \"rendererService\", _descriptor, this);\n\n    this.passes = [];\n    this.readFBO = void 0;\n    this.writeFBO = void 0;\n  }\n\n  _createClass(PostProcessor, [{\n    key: \"getReadFBO\",\n    value: function getReadFBO() {\n      return this.readFBO;\n    }\n  }, {\n    key: \"getWriteFBO\",\n    value: function getWriteFBO() {\n      return this.writeFBO;\n    }\n  }, {\n    key: \"render\",\n    value: function () {\n      var _render = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(layer) {\n        var i, pass;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                i = 0;\n\n              case 1:\n                if (!(i < this.passes.length)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                pass = this.passes[i];\n                pass.setRenderToScreen(this.isLastEnabledPass(i));\n                _context.next = 6;\n                return pass.render(layer);\n\n              case 6:\n                if (i !== this.passes.length - 1) {\n                  this.swap();\n                }\n\n              case 7:\n                i++;\n                _context.next = 1;\n                break;\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function render(_x) {\n        return _render.apply(this, arguments);\n      }\n\n      return render;\n    }()\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      this.readFBO.resize({\n        width: width,\n        height: height\n      });\n      this.writeFBO.resize({\n        width: width,\n        height: height\n      });\n    }\n  }, {\n    key: \"add\",\n    value: function add(pass, layer, config) {\n      pass.init(layer, config);\n      this.passes.push(pass);\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(pass, index, layer, config) {\n      pass.init(layer, config);\n      this.passes.splice(index, 0, pass);\n    }\n  }, {\n    key: \"getPostProcessingPassByName\",\n    value: function getPostProcessingPassByName(name) {\n      return this.passes.find(function (p) {\n        return p.getName() === name;\n      });\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      var _this$rendererService = this.rendererService,\n          createFramebuffer = _this$rendererService.createFramebuffer,\n          createTexture2D = _this$rendererService.createTexture2D;\n      this.readFBO = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n      this.writeFBO = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n    }\n  }, {\n    key: \"isLastEnabledPass\",\n    value: function isLastEnabledPass(index) {\n      for (var i = index + 1; i < this.passes.length; i++) {\n        if (this.passes[i].isEnabled()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"swap\",\n    value: function swap() {\n      var tmp = this.readFBO;\n      this.readFBO = this.writeFBO;\n      this.writeFBO = tmp;\n    }\n  }]);\n\n  return PostProcessor;\n}(), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"rendererService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _applyDecoratedDescriptor(_class2.prototype, \"init\", [_dec3], Object.getOwnPropertyDescriptor(_class2.prototype, \"init\"), _class2.prototype)), _class2)) || _class);\nexport { PostProcessor as default };","map":{"version":3,"sources":["../../../../src/services/renderer/passes/PostProcessor.ts"],"names":["injectable","PostProcessor","inject","TYPES","passes","readFBO","writeFBO","layer","i","length","pass","width","height","config","index","name","p","postConstruct","createFramebuffer","createTexture2D","color","wrapS","gl","wrapT","CLAMP_TO_EDGE","tmp"],"mappings":"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","sourcesContent":["import { inject, injectable, postConstruct } from 'inversify';\nimport { TYPES } from '../../../types';\nimport { ILayer } from '../../layer/ILayerService';\nimport { gl } from '../gl';\nimport { IFramebuffer } from '../IFramebuffer';\nimport { IPostProcessingPass, IPostProcessor } from '../IMultiPassRenderer';\nimport { IRendererService } from '../IRendererService';\n\n/**\n * ported from Three.js EffectComposer\n * 后处理负责 pingpong read/write framebuffer，最后一个 pass 默认输出到屏幕\n */\n@injectable()\nexport default class PostProcessor implements IPostProcessor {\n  @inject(TYPES.IRendererService)\n  protected readonly rendererService: IRendererService;\n\n  private passes: Array<IPostProcessingPass<unknown>> = [];\n  private readFBO: IFramebuffer;\n  private writeFBO: IFramebuffer;\n\n  public getReadFBO() {\n    return this.readFBO;\n  }\n\n  public getWriteFBO() {\n    return this.writeFBO;\n  }\n\n  public async render(layer: ILayer) {\n    for (let i = 0; i < this.passes.length; i++) {\n      const pass = this.passes[i];\n      // last pass should render to screen\n      pass.setRenderToScreen(this.isLastEnabledPass(i));\n      await pass.render(layer);\n\n      // pingpong\n      if (i !== this.passes.length - 1) {\n        this.swap();\n      }\n    }\n  }\n\n  public resize(width: number, height: number) {\n    this.readFBO.resize({\n      width,\n      height,\n    });\n    this.writeFBO.resize({\n      width,\n      height,\n    });\n  }\n\n  public add<T>(\n    pass: IPostProcessingPass<T>,\n    layer: ILayer,\n    config?: Partial<T>,\n  ) {\n    pass.init(layer, config);\n    this.passes.push(pass);\n  }\n\n  public insert<T>(\n    pass: IPostProcessingPass<T>,\n    index: number,\n    layer: ILayer,\n    config?: Partial<T>,\n  ) {\n    pass.init(layer, config);\n    this.passes.splice(index, 0, pass);\n  }\n\n  public getPostProcessingPassByName(\n    name: string,\n  ): IPostProcessingPass<unknown> | undefined {\n    return this.passes.find((p) => p.getName() === name);\n  }\n\n  @postConstruct()\n  private init() {\n    const { createFramebuffer, createTexture2D } = this.rendererService;\n    this.readFBO = createFramebuffer({\n      color: createTexture2D({\n        width: 1,\n        height: 1,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n      }),\n    });\n\n    this.writeFBO = createFramebuffer({\n      color: createTexture2D({\n        width: 1,\n        height: 1,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n      }),\n    });\n  }\n\n  private isLastEnabledPass(index: number): boolean {\n    for (let i = index + 1; i < this.passes.length; i++) {\n      if (this.passes[i].isEnabled()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private swap() {\n    const tmp = this.readFBO;\n    this.readFBO = this.writeFBO;\n    this.writeFBO = tmp;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}