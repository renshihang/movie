{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nvar GridIndex = function () {\n  function GridIndex(width, height, cellSize) {\n    _classCallCheck(this, GridIndex);\n\n    this.boxCells = [];\n    this.xCellCount = void 0;\n    this.yCellCount = void 0;\n    this.boxKeys = void 0;\n    this.bboxes = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.xScale = void 0;\n    this.yScale = void 0;\n    this.boxUid = void 0;\n    var boxCells = this.boxCells;\n    this.xCellCount = Math.ceil(width / cellSize);\n    this.yCellCount = Math.ceil(height / cellSize);\n\n    for (var i = 0; i < this.xCellCount * this.yCellCount; i++) {\n      boxCells.push([]);\n    }\n\n    this.boxKeys = [];\n    this.bboxes = [];\n    this.width = width;\n    this.height = height;\n    this.xScale = this.xCellCount / width;\n    this.yScale = this.yCellCount / height;\n    this.boxUid = 0;\n  }\n\n  _createClass(GridIndex, [{\n    key: \"insert\",\n    value: function insert(key, x1, y1, x2, y2) {\n      this.forEachCell(x1, y1, x2, y2, this.insertBoxCell, this.boxUid++);\n      this.boxKeys.push(key);\n      this.bboxes.push(x1);\n      this.bboxes.push(y1);\n      this.bboxes.push(x2);\n      this.bboxes.push(y2);\n    }\n  }, {\n    key: \"query\",\n    value: function query(x1, y1, x2, y2, predicate) {\n      return this.queryHitTest(x1, y1, x2, y2, false, predicate);\n    }\n  }, {\n    key: \"hitTest\",\n    value: function hitTest(x1, y1, x2, y2, predicate) {\n      return this.queryHitTest(x1, y1, x2, y2, true, predicate);\n    }\n  }, {\n    key: \"insertBoxCell\",\n    value: function insertBoxCell(x1, y1, x2, y2, cellIndex, uid) {\n      this.boxCells[cellIndex].push(uid);\n    }\n  }, {\n    key: \"queryHitTest\",\n    value: function queryHitTest(x1, y1, x2, y2, hitTest, predicate) {\n      if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {\n        return hitTest ? false : [];\n      }\n\n      var result = [];\n\n      if (x1 <= 0 && y1 <= 0 && this.width <= x2 && this.height <= y2) {\n        if (hitTest) {\n          return true;\n        }\n\n        for (var boxUid = 0; boxUid < this.boxKeys.length; boxUid++) {\n          result.push({\n            key: this.boxKeys[boxUid],\n            x1: this.bboxes[boxUid * 4],\n            y1: this.bboxes[boxUid * 4 + 1],\n            x2: this.bboxes[boxUid * 4 + 2],\n            y2: this.bboxes[boxUid * 4 + 3]\n          });\n        }\n\n        return predicate ? result.filter(predicate) : result;\n      }\n\n      var queryArgs = {\n        hitTest: hitTest,\n        seenUids: {\n          box: {},\n          circle: {}\n        }\n      };\n      this.forEachCell(x1, y1, x2, y2, this.queryCell, result, queryArgs, predicate);\n      return hitTest ? result.length > 0 : result;\n    }\n  }, {\n    key: \"queryCell\",\n    value: function queryCell(x1, y1, x2, y2, cellIndex, result, queryArgs, predicate) {\n      var seenUids = queryArgs.seenUids;\n      var boxCell = this.boxCells[cellIndex];\n\n      if (boxCell !== null) {\n        var bboxes = this.bboxes;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = boxCell[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var boxUid = _step.value;\n\n            if (!seenUids.box[boxUid]) {\n              seenUids.box[boxUid] = true;\n              var offset = boxUid * 4;\n\n              if (x1 <= bboxes[offset + 2] && y1 <= bboxes[offset + 3] && x2 >= bboxes[offset + 0] && y2 >= bboxes[offset + 1] && (!predicate || predicate(this.boxKeys[boxUid]))) {\n                if (queryArgs.hitTest) {\n                  result.push(true);\n                  return true;\n                }\n\n                result.push({\n                  key: this.boxKeys[boxUid],\n                  x1: bboxes[offset],\n                  y1: bboxes[offset + 1],\n                  x2: bboxes[offset + 2],\n                  y2: bboxes[offset + 3]\n                });\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"forEachCell\",\n    value: function forEachCell(x1, y1, x2, y2, fn, arg1, arg2, predicate) {\n      var cx1 = this.convertToXCellCoord(x1);\n      var cy1 = this.convertToYCellCoord(y1);\n      var cx2 = this.convertToXCellCoord(x2);\n      var cy2 = this.convertToYCellCoord(y2);\n\n      for (var x = cx1; x <= cx2; x++) {\n        for (var y = cy1; y <= cy2; y++) {\n          var cellIndex = this.xCellCount * y + x;\n\n          if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, predicate)) {\n            return;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"convertToXCellCoord\",\n    value: function convertToXCellCoord(x) {\n      return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(x * this.xScale)));\n    }\n  }, {\n    key: \"convertToYCellCoord\",\n    value: function convertToYCellCoord(y) {\n      return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(y * this.yScale)));\n    }\n  }]);\n\n  return GridIndex;\n}();\n\nexport default GridIndex;","map":{"version":3,"sources":["../../src/utils/grid-index.ts"],"names":["GridIndex","boxCells","xCellCount","yCellCount","boxKeys","bboxes","width","height","xScale","yScale","boxUid","Math","i","key","x1","y1","x2","y2","predicate","cellIndex","uid","hitTest","result","queryArgs","seenUids","box","circle","boxCell","offset","fn","arg1","arg2","cx1","cy1","cx2","cy2","x","y"],"mappings":"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","sourcesContent":["interface IQueryArgs {\n  hitTest: boolean;\n  seenUids: { box: any; circle: any };\n}\ntype CallBack = (...args: any[]) => any;\n/**\n * 网格索引，相比 @mapbox/grid-index，在简单计算碰撞检测结果时效率更高\n * @see https://zhuanlan.zhihu.com/p/74373214\n */\nclass GridIndex {\n  private boxCells: number[][] = [];\n  private xCellCount: number;\n  private yCellCount: number;\n  private boxKeys: string[];\n  private bboxes: number[];\n  private width: number;\n  private height: number;\n  private xScale: number;\n  private yScale: number;\n  private boxUid: number;\n\n  constructor(width: number, height: number, cellSize: number) {\n    const boxCells = this.boxCells;\n\n    this.xCellCount = Math.ceil(width / cellSize);\n    this.yCellCount = Math.ceil(height / cellSize);\n\n    for (let i = 0; i < this.xCellCount * this.yCellCount; i++) {\n      boxCells.push([]);\n    }\n    this.boxKeys = [];\n    this.bboxes = [];\n\n    this.width = width;\n    this.height = height;\n    this.xScale = this.xCellCount / width;\n    this.yScale = this.yCellCount / height;\n    this.boxUid = 0;\n  }\n\n  public insert(key: any, x1: number, y1: number, x2: number, y2: number) {\n    this.forEachCell(x1, y1, x2, y2, this.insertBoxCell, this.boxUid++);\n    this.boxKeys.push(key);\n    this.bboxes.push(x1);\n    this.bboxes.push(y1);\n    this.bboxes.push(x2);\n    this.bboxes.push(y2);\n  }\n\n  public query(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    predicate?: CallBack,\n  ) {\n    return this.queryHitTest(x1, y1, x2, y2, false, predicate);\n  }\n\n  public hitTest(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    predicate?: CallBack,\n  ) {\n    return this.queryHitTest(x1, y1, x2, y2, true, predicate);\n  }\n\n  private insertBoxCell(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    cellIndex: number,\n    uid: number,\n  ) {\n    this.boxCells[cellIndex].push(uid);\n  }\n\n  private queryHitTest(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    hitTest: boolean,\n    predicate?: CallBack,\n  ) {\n    if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {\n      return hitTest ? false : [];\n    }\n    const result: any[] = [];\n    if (x1 <= 0 && y1 <= 0 && this.width <= x2 && this.height <= y2) {\n      // 这一步是高效的关键，后续精确碰撞检测结果在计算文本可见性时并不需要\n      if (hitTest) {\n        return true;\n      }\n      for (let boxUid = 0; boxUid < this.boxKeys.length; boxUid++) {\n        result.push({\n          key: this.boxKeys[boxUid],\n          x1: this.bboxes[boxUid * 4],\n          y1: this.bboxes[boxUid * 4 + 1],\n          x2: this.bboxes[boxUid * 4 + 2],\n          y2: this.bboxes[boxUid * 4 + 3],\n        });\n      }\n      return predicate ? result.filter(predicate) : result;\n    }\n\n    const queryArgs = {\n      hitTest,\n      seenUids: { box: {}, circle: {} },\n    };\n    this.forEachCell(\n      x1,\n      y1,\n      x2,\n      y2,\n      this.queryCell,\n      result,\n      queryArgs,\n      predicate,\n    );\n    return hitTest ? result.length > 0 : result;\n  }\n\n  private queryCell(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    cellIndex: number,\n    result: any[],\n    queryArgs?: any,\n    predicate?: CallBack,\n  ) {\n    const seenUids = queryArgs.seenUids;\n    const boxCell = this.boxCells[cellIndex];\n    if (boxCell !== null) {\n      const bboxes = this.bboxes;\n      for (const boxUid of boxCell) {\n        if (!seenUids.box[boxUid]) {\n          seenUids.box[boxUid] = true;\n          const offset = boxUid * 4;\n          if (\n            x1 <= bboxes[offset + 2] &&\n            y1 <= bboxes[offset + 3] &&\n            x2 >= bboxes[offset + 0] &&\n            y2 >= bboxes[offset + 1] &&\n            (!predicate || predicate(this.boxKeys[boxUid]))\n          ) {\n            if (queryArgs.hitTest) {\n              result.push(true);\n              return true;\n            }\n            result.push({\n              key: this.boxKeys[boxUid],\n              x1: bboxes[offset],\n              y1: bboxes[offset + 1],\n              x2: bboxes[offset + 2],\n              y2: bboxes[offset + 3],\n            });\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  private forEachCell(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    fn: CallBack,\n    arg1: any[] | number,\n    arg2?: IQueryArgs,\n    predicate?: CallBack,\n  ) {\n    const cx1 = this.convertToXCellCoord(x1);\n    const cy1 = this.convertToYCellCoord(y1);\n    const cx2 = this.convertToXCellCoord(x2);\n    const cy2 = this.convertToYCellCoord(y2);\n\n    for (let x = cx1; x <= cx2; x++) {\n      for (let y = cy1; y <= cy2; y++) {\n        const cellIndex = this.xCellCount * y + x;\n        if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, predicate)) {\n          return;\n        }\n      }\n    }\n  }\n\n  private convertToXCellCoord(x: number) {\n    return Math.max(\n      0,\n      Math.min(this.xCellCount - 1, Math.floor(x * this.xScale)),\n    );\n  }\n\n  private convertToYCellCoord(y: number) {\n    return Math.max(\n      0,\n      Math.min(this.yCellCount - 1, Math.floor(y * this.yScale)),\n    );\n  }\n}\n\nexport default GridIndex;\n"]},"metadata":{},"sourceType":"module"}