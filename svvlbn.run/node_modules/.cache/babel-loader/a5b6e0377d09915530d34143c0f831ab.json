{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _temp;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { inject, injectable } from 'inversify';\nvar blendFS = \"uniform float u_opacity : 1.0;\\nuniform float u_MixRatio : 0.5;\\n\\nuniform sampler2D u_Diffuse1;\\nuniform sampler2D u_Diffuse2;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  vec4 texel1 = texture2D(u_Diffuse1, v_UV);\\n  vec4 texel2 = texture2D(u_Diffuse2, v_UV);\\n  gl_FragColor = u_opacity * mix(texel1, texel2, u_MixRatio);\\n}\\n\";\nvar copyFS = \"varying vec2 v_UV;\\n\\nuniform sampler2D u_Texture;\\n\\nvoid main() {\\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\\n}\";\nvar quadVS = \"attribute vec2 a_Position;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  v_UV = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n}\";\nimport { TYPES } from '../../../types';\nimport { gl } from '../gl';\nimport { PassType } from '../IMultiPassRenderer';\nimport BaseNormalPass from './BaseNormalPass';\n\nfunction halton(index, base) {\n  var result = 0;\n  var f = 1 / base;\n  var i = index;\n\n  while (i > 0) {\n    result = result + f * (i % base);\n    i = Math.floor(i / base);\n    f = f / base;\n  }\n\n  return result;\n}\n\nvar accumulatingId = 1;\nvar TAAPass = (_dec = injectable(), _dec2 = inject(TYPES.IShaderModuleService), _dec3 = inject(TYPES.ILogService), _dec(_class = (_class2 = (_temp = function (_BaseNormalPass) {\n  _inherits(TAAPass, _BaseNormalPass);\n\n  function TAAPass() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, TAAPass);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TAAPass)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _initializerDefineProperty(_this, \"shaderModuleService\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"logger\", _descriptor2, _assertThisInitialized(_this));\n\n    _this.haltonSequence = [];\n    _this.accumulatingId = 0;\n    _this.frame = 0;\n    _this.timer = undefined;\n    _this.sampleRenderTarget = void 0;\n    _this.prevRenderTarget = void 0;\n    _this.outputRenderTarget = void 0;\n    _this.copyRenderTarget = void 0;\n    _this.blendModel = void 0;\n    _this.outputModel = void 0;\n    _this.copyModel = void 0;\n    return _this;\n  }\n\n  _createClass(TAAPass, [{\n    key: \"getType\",\n    value: function getType() {\n      return PassType.Normal;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'taa';\n    }\n  }, {\n    key: \"init\",\n    value: function init(layer, config) {\n      _get(_getPrototypeOf(TAAPass.prototype), \"init\", this).call(this, layer, config);\n\n      var _this$rendererService = this.rendererService,\n          createFramebuffer = _this$rendererService.createFramebuffer,\n          createTexture2D = _this$rendererService.createTexture2D;\n      this.sampleRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n      this.prevRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n      this.outputRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n      this.copyRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n\n      for (var i = 0; i < 30; i++) {\n        this.haltonSequence.push([halton(i, 2), halton(i, 3)]);\n      }\n\n      this.blendModel = this.createTriangleModel('blend-pass', blendFS);\n      this.outputModel = this.createTriangleModel('copy-pass', copyFS, {\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.ONE,\n            dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n            srcAlpha: gl.ONE,\n            dstAlpha: gl.ONE_MINUS_SRC_ALPHA\n          },\n          equation: {\n            rgb: gl.FUNC_ADD,\n            alpha: gl.FUNC_ADD\n          }\n        }\n      });\n      this.copyModel = this.createTriangleModel('copy-pass', copyFS);\n    }\n  }, {\n    key: \"render\",\n    value: function render(layer) {\n      var _this2 = this;\n\n      var _this$rendererService2 = this.rendererService,\n          clear = _this$rendererService2.clear,\n          getViewportSize = _this$rendererService2.getViewportSize,\n          useFramebuffer = _this$rendererService2.useFramebuffer;\n\n      var _getViewportSize = getViewportSize(),\n          width = _getViewportSize.width,\n          height = _getViewportSize.height;\n\n      this.sampleRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.prevRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.outputRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.copyRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.resetFrame();\n      this.stopAccumulating();\n      var readFBO = layer.multiPassRenderer.getPostProcessor().getReadFBO();\n      useFramebuffer(readFBO, function () {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: readFBO\n        });\n        layer.multiPassRenderer.setRenderFlag(false);\n        layer.render();\n        layer.multiPassRenderer.setRenderFlag(true);\n      });\n\n      var accumulate = function accumulate(id) {\n        if (!_this2.accumulatingId || id !== _this2.accumulatingId) {\n          return;\n        }\n\n        if (!_this2.isFinished()) {\n          _this2.doRender(layer);\n\n          requestAnimationFrame(function () {\n            accumulate(id);\n          });\n        }\n      };\n\n      this.accumulatingId = accumulatingId++;\n      this.timer = window.setTimeout(function () {\n        accumulate(_this2.accumulatingId);\n      }, 50);\n    }\n  }, {\n    key: \"doRender\",\n    value: function doRender(layer) {\n      var _this3 = this;\n\n      this.logger.debug(\"accumulatingId: \".concat(this.accumulatingId));\n      var _this$rendererService3 = this.rendererService,\n          clear = _this$rendererService3.clear,\n          getViewportSize = _this$rendererService3.getViewportSize,\n          useFramebuffer = _this$rendererService3.useFramebuffer;\n\n      var _getViewportSize2 = getViewportSize(),\n          width = _getViewportSize2.width,\n          height = _getViewportSize2.height;\n\n      var _layer$getLayerConfig = layer.getLayerConfig(),\n          _layer$getLayerConfig2 = _layer$getLayerConfig.jitterScale,\n          jitterScale = _layer$getLayerConfig2 === void 0 ? 1 : _layer$getLayerConfig2;\n\n      var offset = this.haltonSequence[this.frame % this.haltonSequence.length];\n      this.cameraService.jitterProjectionMatrix((offset[0] * 2.0 - 1.0) / width * jitterScale, (offset[1] * 2.0 - 1.0) / height * jitterScale);\n      layer.multiPassRenderer.setRenderFlag(false);\n      layer.hooks.beforeRender.call();\n      useFramebuffer(this.sampleRenderTarget, function () {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: _this3.sampleRenderTarget\n        });\n        layer.render();\n      });\n      layer.hooks.afterRender.call();\n      layer.multiPassRenderer.setRenderFlag(true);\n      var layerStyleOptions = layer.getLayerConfig();\n      useFramebuffer(this.outputRenderTarget, function () {\n        _this3.blendModel.draw({\n          uniforms: {\n            u_opacity: layerStyleOptions.opacity || 1,\n            u_MixRatio: _this3.frame === 0 ? 1 : 0.9,\n            u_Diffuse1: _this3.sampleRenderTarget,\n            u_Diffuse2: _this3.frame === 0 ? layer.multiPassRenderer.getPostProcessor().getReadFBO() : _this3.prevRenderTarget\n          }\n        });\n      });\n\n      if (this.frame === 0) {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: this.copyRenderTarget\n        });\n      }\n\n      if (this.frame >= 1) {\n        useFramebuffer(this.copyRenderTarget, function () {\n          _this3.outputModel.draw({\n            uniforms: {\n              u_Texture: _this3.outputRenderTarget\n            }\n          });\n        });\n        useFramebuffer(layer.multiPassRenderer.getPostProcessor().getReadFBO(), function () {\n          _this3.copyModel.draw({\n            uniforms: {\n              u_Texture: _this3.copyRenderTarget\n            }\n          });\n        });\n        layer.multiPassRenderer.getPostProcessor().render(layer);\n      }\n\n      var tmp = this.prevRenderTarget;\n      this.prevRenderTarget = this.outputRenderTarget;\n      this.outputRenderTarget = tmp;\n      this.frame++;\n      this.cameraService.clearJitterProjectionMatrix();\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished() {\n      return this.frame >= this.haltonSequence.length;\n    }\n  }, {\n    key: \"resetFrame\",\n    value: function resetFrame() {\n      this.frame = 0;\n    }\n  }, {\n    key: \"stopAccumulating\",\n    value: function stopAccumulating() {\n      this.accumulatingId = 0;\n      window.clearTimeout(this.timer);\n    }\n  }, {\n    key: \"createTriangleModel\",\n    value: function createTriangleModel(shaderModuleName, fragmentShader, options) {\n      this.shaderModuleService.registerModule(shaderModuleName, {\n        vs: quadVS,\n        fs: fragmentShader\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule(shaderModuleName),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          uniforms = _this$shaderModuleSer.uniforms;\n\n      var _this$rendererService4 = this.rendererService,\n          createAttribute = _this$rendererService4.createAttribute,\n          createBuffer = _this$rendererService4.createBuffer,\n          createModel = _this$rendererService4.createModel;\n      return createModel(_objectSpread({\n        vs: vs,\n        fs: fs,\n        attributes: {\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: [-4, -4, 4, -4, 0, 4],\n              type: gl.FLOAT\n            }),\n            size: 2\n          })\n        },\n        uniforms: _objectSpread({}, uniforms),\n        depth: {\n          enable: false\n        },\n        count: 3\n      }, options));\n    }\n  }]);\n\n  return TAAPass;\n}(BaseNormalPass), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"shaderModuleService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"logger\", [_dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);\nexport { TAAPass as default };","map":{"version":3,"sources":["../../../../src/services/renderer/passes/TAAPass.ts"],"names":["result","f","i","Math","accumulatingId","injectable","TAAPass","BaseNormalPass","inject","TYPES","haltonSequence","frame","timer","undefined","sampleRenderTarget","prevRenderTarget","outputRenderTarget","copyRenderTarget","blendModel","outputModel","copyModel","PassType","layer","config","createFramebuffer","createTexture2D","color","width","height","wrapS","gl","wrapT","CLAMP_TO_EDGE","halton","blend","enable","func","srcRGB","dstRGB","srcAlpha","dstAlpha","ONE_MINUS_SRC_ALPHA","equation","rgb","alpha","FUNC_ADD","clear","getViewportSize","useFramebuffer","readFBO","depth","stencil","framebuffer","accumulate","id","requestAnimationFrame","jitterScale","offset","layerStyleOptions","uniforms","u_opacity","u_MixRatio","u_Diffuse1","u_Diffuse2","u_Texture","tmp","window","shaderModuleName","fragmentShader","options","vs","fs","createAttribute","createBuffer","createModel","attributes","a_Position","buffer","data","type","FLOAT","size","count"],"mappings":"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","sourcesContent":["import { inject, injectable } from 'inversify';\nimport blendFS from '../../../shaders/post-processing/blend.glsl';\nimport copyFS from '../../../shaders/post-processing/copy.glsl';\nimport quadVS from '../../../shaders/post-processing/quad.glsl';\nimport { TYPES } from '../../../types';\nimport { ILayer } from '../../layer/ILayerService';\nimport { ILogService } from '../../log/ILogService';\nimport { IShaderModuleService } from '../../shader/IShaderModuleService';\nimport { gl } from '../gl';\nimport { IFramebuffer } from '../IFramebuffer';\nimport { IModel, IModelInitializationOptions } from '../IModel';\nimport { PassType } from '../IMultiPassRenderer';\nimport BaseNormalPass from './BaseNormalPass';\n\n// Generate halton sequence\n// https://en.wikipedia.org/wiki/Halton_sequence\nfunction halton(index: number, base: number) {\n  let result = 0;\n  let f = 1 / base;\n  let i = index;\n  while (i > 0) {\n    result = result + f * (i % base);\n    i = Math.floor(i / base);\n    f = f / base;\n  }\n  return result;\n}\n\n// 累加计数器\nlet accumulatingId = 1;\n\n/**\n * TAA（Temporal Anti-Aliasing）\n * 在需要后处理的场景中（例如 L7 的热力图需要 blur pass、PBR 中的 SSAO 环境光遮蔽），无法使用浏览器内置的 MSAA，\n * 只能使用 TAA\n * @see https://yuque.antfin-inc.com/yuqi.pyq/fgetpa/ri52hv\n */\n@injectable()\nexport default class TAAPass<InitializationOptions = {}> extends BaseNormalPass<\n  InitializationOptions\n> {\n  @inject(TYPES.IShaderModuleService)\n  protected readonly shaderModuleService: IShaderModuleService;\n\n  @inject(TYPES.ILogService)\n  protected readonly logger: ILogService;\n\n  /**\n   * 低差异序列\n   */\n  private haltonSequence: Array<[number, number]> = [];\n\n  /**\n   * 当前累加任务 ID，例如用户连续拖拽时上一次累加很有可能没有结束，此时在开启新一轮累加之前需要结束掉之前未完成的\n   */\n  private accumulatingId: number = 0;\n\n  /**\n   * 每一轮累加中的 frameID\n   */\n  private frame: number = 0;\n\n  /**\n   * 每一轮累加中的 frame 定时器\n   */\n  private timer: number | undefined = undefined;\n\n  private sampleRenderTarget: IFramebuffer;\n  private prevRenderTarget: IFramebuffer;\n  private outputRenderTarget: IFramebuffer;\n  private copyRenderTarget: IFramebuffer;\n\n  private blendModel: IModel;\n  private outputModel: IModel;\n  private copyModel: IModel;\n\n  public getType() {\n    return PassType.Normal;\n  }\n\n  public getName() {\n    return 'taa';\n  }\n\n  public init(layer: ILayer, config?: Partial<InitializationOptions>) {\n    super.init(layer, config);\n\n    const { createFramebuffer, createTexture2D } = this.rendererService;\n    this.sampleRenderTarget = createFramebuffer({\n      color: createTexture2D({\n        width: 1,\n        height: 1,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n      }),\n    });\n    this.prevRenderTarget = createFramebuffer({\n      color: createTexture2D({\n        width: 1,\n        height: 1,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n      }),\n    });\n    this.outputRenderTarget = createFramebuffer({\n      color: createTexture2D({\n        width: 1,\n        height: 1,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n      }),\n    });\n    this.copyRenderTarget = createFramebuffer({\n      color: createTexture2D({\n        width: 1,\n        height: 1,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n      }),\n    });\n\n    for (let i = 0; i < 30; i++) {\n      this.haltonSequence.push([halton(i, 2), halton(i, 3)]);\n    }\n\n    this.blendModel = this.createTriangleModel('blend-pass', blendFS);\n    this.outputModel = this.createTriangleModel('copy-pass', copyFS, {\n      blend: {\n        enable: true,\n        func: {\n          srcRGB: gl.ONE,\n          dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n          srcAlpha: gl.ONE,\n          dstAlpha: gl.ONE_MINUS_SRC_ALPHA,\n        },\n        equation: {\n          rgb: gl.FUNC_ADD,\n          alpha: gl.FUNC_ADD,\n        },\n      },\n    });\n    this.copyModel = this.createTriangleModel('copy-pass', copyFS);\n  }\n\n  public render(layer: ILayer) {\n    const { clear, getViewportSize, useFramebuffer } = this.rendererService;\n    const { width, height } = getViewportSize();\n    this.sampleRenderTarget.resize({ width, height });\n    this.prevRenderTarget.resize({ width, height });\n    this.outputRenderTarget.resize({ width, height });\n    this.copyRenderTarget.resize({ width, height });\n\n    this.resetFrame();\n    // 首先停止上一次的累加\n    this.stopAccumulating();\n\n    // 先输出到 PostProcessor\n    const readFBO = layer.multiPassRenderer.getPostProcessor().getReadFBO();\n    useFramebuffer(readFBO, () => {\n      clear({\n        color: [0, 0, 0, 0],\n        depth: 1,\n        stencil: 0,\n        framebuffer: readFBO,\n      });\n\n      // render to post processor\n      layer.multiPassRenderer.setRenderFlag(false);\n      layer.render();\n      layer.multiPassRenderer.setRenderFlag(true);\n    });\n\n    const accumulate = (id: number) => {\n      // 在开启新一轮累加之前，需要先结束掉之前的累加\n      if (!this.accumulatingId || id !== this.accumulatingId) {\n        return;\n      }\n\n      if (!this.isFinished()) {\n        this.doRender(layer);\n\n        requestAnimationFrame(() => {\n          accumulate(id);\n        });\n      }\n    };\n\n    this.accumulatingId = accumulatingId++;\n    this.timer = window.setTimeout(() => {\n      accumulate(this.accumulatingId);\n    }, 50);\n  }\n\n  private doRender(layer: ILayer) {\n    this.logger.debug(`accumulatingId: ${this.accumulatingId}`);\n\n    const { clear, getViewportSize, useFramebuffer } = this.rendererService;\n    const { width, height } = getViewportSize();\n    const { jitterScale = 1 } = layer.getLayerConfig();\n\n    // 使用 Halton 序列抖动投影矩阵\n    const offset = this.haltonSequence[this.frame % this.haltonSequence.length];\n    this.cameraService.jitterProjectionMatrix(\n      ((offset[0] * 2.0 - 1.0) / width) * jitterScale,\n      ((offset[1] * 2.0 - 1.0) / height) * jitterScale,\n    );\n\n    // 按抖动后的投影矩阵渲染\n    layer.multiPassRenderer.setRenderFlag(false);\n    layer.hooks.beforeRender.call();\n    useFramebuffer(this.sampleRenderTarget, () => {\n      clear({\n        color: [0, 0, 0, 0],\n        depth: 1,\n        stencil: 0,\n        framebuffer: this.sampleRenderTarget,\n      });\n\n      layer.render();\n    });\n    layer.hooks.afterRender.call();\n    layer.multiPassRenderer.setRenderFlag(true);\n\n    // 混合\n    const layerStyleOptions = layer.getLayerConfig();\n    useFramebuffer(this.outputRenderTarget, () => {\n      this.blendModel.draw({\n        uniforms: {\n          // @ts-ignore\n          u_opacity: layerStyleOptions.opacity || 1,\n          u_MixRatio: this.frame === 0 ? 1 : 0.9,\n          u_Diffuse1: this.sampleRenderTarget,\n          u_Diffuse2:\n            this.frame === 0\n              ? layer.multiPassRenderer.getPostProcessor().getReadFBO()\n              : this.prevRenderTarget,\n        },\n      });\n    });\n\n    // 输出累加结果\n    if (this.frame === 0) {\n      clear({\n        color: [0, 0, 0, 0],\n        depth: 1,\n        stencil: 0,\n        framebuffer: this.copyRenderTarget,\n      });\n    }\n\n    if (this.frame >= 1) {\n      useFramebuffer(this.copyRenderTarget, () => {\n        this.outputModel.draw({\n          uniforms: {\n            u_Texture: this.outputRenderTarget,\n          },\n        });\n      });\n\n      useFramebuffer(\n        layer.multiPassRenderer.getPostProcessor().getReadFBO(),\n        () => {\n          this.copyModel.draw({\n            uniforms: {\n              u_Texture: this.copyRenderTarget,\n            },\n          });\n        },\n      );\n      layer.multiPassRenderer.getPostProcessor().render(layer);\n    }\n\n    // 保存前序帧结果\n    const tmp = this.prevRenderTarget;\n    this.prevRenderTarget = this.outputRenderTarget;\n    this.outputRenderTarget = tmp;\n\n    this.frame++;\n\n    // 恢复 jitter 后的相机\n    this.cameraService.clearJitterProjectionMatrix();\n  }\n\n  /**\n   * 是否已经完成累加\n   * @return {boolean} isFinished\n   */\n  private isFinished() {\n    return this.frame >= this.haltonSequence.length;\n  }\n\n  private resetFrame() {\n    this.frame = 0;\n  }\n\n  private stopAccumulating() {\n    this.accumulatingId = 0;\n    window.clearTimeout(this.timer);\n  }\n\n  private createTriangleModel(\n    shaderModuleName: string,\n    fragmentShader: string,\n    options?: Partial<IModelInitializationOptions>,\n  ) {\n    this.shaderModuleService.registerModule(shaderModuleName, {\n      vs: quadVS,\n      fs: fragmentShader,\n    });\n\n    const { vs, fs, uniforms } = this.shaderModuleService.getModule(\n      shaderModuleName,\n    );\n    const { createAttribute, createBuffer, createModel } = this.rendererService;\n    return createModel({\n      vs,\n      fs,\n      attributes: {\n        // 使用一个全屏三角形，相比 Quad 顶点数目更少\n        a_Position: createAttribute({\n          buffer: createBuffer({\n            data: [-4, -4, 4, -4, 0, 4],\n            type: gl.FLOAT,\n          }),\n          size: 2,\n        }),\n      },\n      uniforms: {\n        ...uniforms,\n      },\n      depth: {\n        enable: false,\n      },\n      count: 3,\n      ...options,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}