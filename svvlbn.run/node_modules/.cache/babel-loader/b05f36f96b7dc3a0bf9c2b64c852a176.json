{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from '../../core/BaseModel';\nimport { LineArcTriangulation } from '../../core/triangulation';\nvar line_arc_frag = \"#define LineTypeSolid 0.0\\n#define LineTypeDash 1.0\\n#define Animate 0.0\\n\\nuniform float u_opacity;\\nuniform float u_blur : 0.9;\\nuniform float u_line_type: 0.0;\\nvarying vec2 v_normal;\\nvarying vec2 v_dash_array;\\nvarying float v_distance_ratio;\\nvarying vec4 v_color;\\n\\nuniform float u_time;\\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  gl_FragColor = v_color;\\n  float blur = 1.- smoothstep(u_blur, 1., length(v_normal.xy));\\n  gl_FragColor.a *= (blur * u_opacity);\\n  if(u_line_type == LineTypeDash) {\\n    gl_FragColor.a *= blur  * (1.0- step(v_dash_array.x, mod(v_distance_ratio, v_dash_array.x +v_dash_array.y)));\\n  }\\n\\n  if(u_aimate.x == Animate) {\\n      float alpha =1.0 - fract( mod(1.0- v_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\\n      alpha = smoothstep(0., 1., alpha);\\n      gl_FragColor.a *= alpha;\\n  }\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\nvar line_arc_vert = \"#define LineTypeSolid 0.0\\n#define LineTypeDash 1.0\\n#define Animate 0.0\\nattribute vec3 a_Position;\\nattribute vec4 a_Instance;\\nattribute vec4 a_Color;\\nattribute float a_Size;\\n\\nuniform mat4 u_ModelMatrix;\\nuniform float segmentNumber;\\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_distance_ratio;\\nuniform float u_line_type: 0.0;\\nuniform vec2 u_dash_array: [10.0, 5.];\\n\\nvarying vec2 v_dash_array;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"project\\\"\\n#pragma include \\\"picking\\\"\\n\\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\\n  return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\\n}\\n\\nfloat getSegmentRatio(float index) {\\n  return smoothstep(0.0, 1.0, index / (segmentNumber - 1.0));\\n}\\n\\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\\n  vec2 x = mix(source, target, ratio);\\n  vec2 center = mix(source, target, 0.5);\\n  float dSourceCenter = distance(source, center);\\n  float dXCenter = distance(x, center);\\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\\n}\\n\\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\\n  float vertex_height = paraboloid(source, target, segmentRatio);\\n\\n  return vec3(\\n    mix(source, target, segmentRatio),\\n    sqrt(max(0.0, vertex_height))\\n  );\\n}\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace);\\n  // rotate by 90 degrees\\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n\\n  vec2 offset = dir_screenspace * offset_direction * a_Size / 2.0;\\n\\n  return offset;\\n}\\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace);\\n  // rotate by 90 degrees\\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n  return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\\n}\\n\\nvoid main() {\\n  v_color = a_Color;\\n  vec2 source = project_position(vec4(a_Instance.rg, 0, 0)).xy;\\n  vec2 target = project_position(vec4(a_Instance.ba, 0, 0)).xy;\\n  float segmentIndex = a_Position.x;\\n  float segmentRatio = getSegmentRatio(segmentIndex);\\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\\n\\n   if(u_line_type == LineTypeDash) {\\n    v_distance_ratio = segmentIndex / segmentNumber;\\n    float total_Distance = pixelDistance(a_Instance.rg, a_Instance.ba) / 2.0 * PI;\\n    v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\\n  }\\n    if(u_aimate.x == Animate) {\\n      v_distance_ratio = segmentIndex / segmentNumber;\\n  }\\n\\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\\n  vec3 curr = getPos(source, target, segmentRatio);\\n  vec3 next = getPos(source, target, nextSegmentRatio);\\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y);\\n  v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nvar lineStyleObj = {\n  solid: 0.0,\n  dash: 1.0\n};\n\nvar Arc3DModel = function (_BaseModel) {\n  _inherits(Arc3DModel, _BaseModel);\n\n  function Arc3DModel() {\n    _classCallCheck(this, Arc3DModel);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Arc3DModel).apply(this, arguments));\n  }\n\n  _createClass(Arc3DModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          opacity = _ref.opacity,\n          _ref$lineType = _ref.lineType,\n          lineType = _ref$lineType === void 0 ? 'solid' : _ref$lineType,\n          _ref$dashArray = _ref.dashArray,\n          dashArray = _ref$dashArray === void 0 ? [10, 5] : _ref$dashArray;\n\n      return {\n        u_opacity: opacity || 1,\n        segmentNumber: 30,\n        u_line_type: lineStyleObj[lineType] || 0.0,\n        u_dash_array: dashArray\n      };\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      var _ref2 = this.layer.getLayerConfig(),\n          animateOption = _ref2.animateOption;\n\n      return {\n        u_aimate: this.animateOption2Array(animateOption),\n        u_time: this.layer.getLayerAnimateTime()\n      };\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      return [this.layer.buildLayerModel({\n        moduleName: 'arc3Dline',\n        vertexShader: line_arc_vert,\n        fragmentShader: line_arc_frag,\n        triangulation: LineArcTriangulation,\n        blend: this.getBlend()\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var size = feature.size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'instance',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Instance',\n          buffer: {\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 4,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4], vertex[5], vertex[6]];\n          }\n        }\n      });\n    }\n  }]);\n\n  return Arc3DModel;\n}(BaseModel);\n\nexport { Arc3DModel as default };","map":{"version":3,"sources":["../../../src/line/models/arc_3d.ts"],"names":["lineStyleObj","solid","dash","Arc3DModel","BaseModel","opacity","lineType","dashArray","u_opacity","segmentNumber","u_line_type","u_dash_array","animateOption","u_aimate","u_time","moduleName","vertexShader","fragmentShader","triangulation","blend","name","type","AttributeType","descriptor","buffer","usage","gl","data","FLOAT","size","update","feature","Array","vertex"],"mappings":"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","sourcesContent":["import {\n  AttributeType,\n  gl,\n  IAnimateOption,\n  IEncodeFeature,\n  ILayerConfig,\n  IModel,\n  IModelUniform,\n} from '@antv/l7-core';\nimport BaseModel from '../../core/BaseModel';\nimport { ILineLayerStyleOptions, lineStyleType } from '../../core/interface';\nimport { LineArcTriangulation } from '../../core/triangulation';\nimport line_arc_frag from '../shaders/line_arc_frag.glsl';\nimport line_arc_vert from '../shaders/line_arc_vert.glsl';\nconst lineStyleObj: { [key: string]: number } = {\n  solid: 0.0,\n  dash: 1.0,\n};\nexport default class Arc3DModel extends BaseModel {\n  public getUninforms(): IModelUniform {\n    const {\n      opacity,\n      lineType = 'solid',\n      dashArray = [10, 5],\n    } = this.layer.getLayerConfig() as ILineLayerStyleOptions;\n    return {\n      u_opacity: opacity || 1,\n      segmentNumber: 30,\n      u_line_type: lineStyleObj[lineType as string] || 0.0,\n      u_dash_array: dashArray,\n    };\n  }\n  public getAnimateUniforms(): IModelUniform {\n    const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;\n    return {\n      u_aimate: this.animateOption2Array(animateOption as IAnimateOption),\n      u_time: this.layer.getLayerAnimateTime(),\n    };\n  }\n\n  public buildModels(): IModel[] {\n    return [\n      this.layer.buildLayerModel({\n        moduleName: 'arc3Dline',\n        vertexShader: line_arc_vert,\n        fragmentShader: line_arc_frag,\n        triangulation: LineArcTriangulation,\n        blend: this.getBlend(),\n      }),\n    ];\n  }\n  protected registerBuiltinAttributes() {\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 1,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const { size } = feature;\n          return Array.isArray(size) ? [size[0]] : [size as number];\n        },\n      },\n    });\n\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'instance', // 弧线起始点信息\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Instance',\n        buffer: {\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 4,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          return [vertex[3], vertex[4], vertex[5], vertex[6]];\n        },\n      },\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}