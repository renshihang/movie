{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from '../../core/BaseModel';\nimport { HeatmapGridTriangulation } from '../../core/triangulation';\nvar heatmapGridFrag = \"precision highp float;\\nvarying vec4 v_color;\\nuniform float u_opacity: 1;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  gl_FragColor = v_color;\\n  gl_FragColor.a *= u_opacity;\\n\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\nvar heatmapGridVert = \"precision highp float;\\n// \\u591A\\u8FB9\\u5F62\\u9876\\u70B9\\u5750\\u6807\\nattribute vec3 a_Position;\\n// \\u591A\\u8FB9\\u5F62\\u7ECF\\u7EAC\\u5EA6\\u5750\\u6807\\nattribute vec3 a_Pos;\\nattribute float a_Size;\\nattribute vec4 a_Color;\\nuniform vec2 u_radius;\\nuniform float u_coverage: 0.9;\\nuniform float u_angle: 0;\\nuniform mat4 u_ModelMatrix;\\nvarying vec4 v_color;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"project\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  v_color = a_Color;\\n    \\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\\n  vec2 offset =(vec2(a_Position.xy * u_radius * rotationMatrix * u_coverage));\\n  vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\\n  vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0., 1.0));\\n  setPickingColor(a_PickingColor);\\n}\\n\";\n\nvar HexagonModel = function (_BaseModel) {\n  _inherits(HexagonModel, _BaseModel);\n\n  function HexagonModel() {\n    _classCallCheck(this, HexagonModel);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(HexagonModel).apply(this, arguments));\n  }\n\n  _createClass(HexagonModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          opacity = _ref.opacity,\n          coverage = _ref.coverage;\n\n      return {\n        u_opacity: opacity || 1.0,\n        u_coverage: coverage || 0.9,\n        u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset]\n      };\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      return [this.layer.buildLayerModel({\n        moduleName: 'hexagonheatmap',\n        vertexShader: heatmapGridVert,\n        fragmentShader: heatmapGridFrag,\n        triangulation: HeatmapGridTriangulation,\n        depth: {\n          enable: false\n        },\n        primitive: gl.TRIANGLES\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'pos',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Pos',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 3,\n          update: function update(feature, featureIdx) {\n            var coordinates = feature.coordinates;\n            return [coordinates[0], coordinates[1], 0];\n          }\n        }\n      });\n    }\n  }]);\n\n  return HexagonModel;\n}(BaseModel);\n\nexport { HexagonModel as default };","map":{"version":3,"sources":["../../../src/heatmap/models/hexagon.ts"],"names":["HexagonModel","BaseModel","opacity","coverage","u_opacity","u_coverage","u_radius","moduleName","vertexShader","fragmentShader","triangulation","depth","enable","primitive","gl","TRIANGLES","name","type","AttributeType","descriptor","buffer","usage","data","FLOAT","size","update","coordinates","feature"],"mappings":";;;;;AAAA,SAAA,aAAA,EAAA,EAAA,QAAA,eAAA;AAOA,OAAA,SAAA,MAAA,sBAAA;AACA,SAAA,wBAAA,QAAA,0BAAA;;;;IASqBA,Y;;;;;;;;;;;mCACkB;AAAA,UAAA,IAAA,GAI/B,KAAA,KAAA,CAJ+B,cAI/B,EAJ+B;AAAA,UAEjCE,OAFiC,GAAA,IAAA,CAAA,OAAA;AAAA,UAGjCC,QAHiC,GAAA,IAAA,CAAA,QAAA;;AAKnC,aAAO;AACLC,QAAAA,SAAS,EAAEF,OAAO,IADb,GAAA;AAELG,QAAAA,UAAU,EAAEF,QAAQ,IAFf,GAAA;AAGLG,QAAAA,QAAQ,EAAE,CACR,KAAA,KAAA,CAAA,SAAA,GAAA,IAAA,CADQ,OAAA,EAER,KAAA,KAAA,CAAA,SAAA,GAAA,IAAA,CAFQ,OAAA;AAHL,OAAP;AAQD;;;kCAE8B;AAC7B,aAAO,CACL,KAAA,KAAA,CAAA,eAAA,CAA2B;AACzBC,QAAAA,UAAU,EADe,gBAAA;AAEzBC,QAAAA,YAAY,EAFa,eAAA;AAGzBC,QAAAA,cAAc,EAHW,eAAA;AAIzBC,QAAAA,aAAa,EAJY,wBAAA;AAKzBC,QAAAA,KAAK,EAAE;AAAEC,UAAAA,MAAM,EAAE;AAAV,SALkB;AAMzBC,QAAAA,SAAS,EAAEC,EAAE,CAACC;AANW,OAA3B,CADK,CAAP;AAUD;;;gDACqC;AACpC,WAAA,qBAAA,CAAA,sBAAA,CAAkD;AAChDC,QAAAA,IAAI,EAD4C,KAAA;AAEhDC,QAAAA,IAAI,EAAEC,aAAa,CAF6B,SAAA;AAGhDC,QAAAA,UAAU,EAAE;AACVH,UAAAA,IAAI,EADM,OAAA;AAEVI,UAAAA,MAAM,EAAE;AAENC,YAAAA,KAAK,EAAEP,EAAE,CAFH,YAAA;AAGNQ,YAAAA,IAAI,EAHE,EAAA;AAINL,YAAAA,IAAI,EAAEH,EAAE,CAACS;AAJH,WAFE;AAQVC,UAAAA,IAAI,EARM,CAAA;AASVC,UAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,OAAA,EAAA,UAAA,EAAiD;AACvD,gBAAMC,WAAW,GAAGC,OAAO,CAA3B,WAAA;AACA,mBAAO,CAACD,WAAW,CAAZ,CAAY,CAAZ,EAAiBA,WAAW,CAA5B,CAA4B,CAA5B,EAAP,CAAO,CAAP;AACD;AAZS;AAHoC,OAAlD;AAkBD;;;;EA/CuCzB,S;;SAArBD,Y","sourcesContent":["import {\n  AttributeType,\n  gl,\n  IEncodeFeature,\n  IModel,\n  IModelUniform,\n} from '@antv/l7-core';\nimport BaseModel from '../../core/BaseModel';\nimport { HeatmapGridTriangulation } from '../../core/triangulation';\nimport heatmapGridFrag from '../shaders/hexagon_frag.glsl';\nimport heatmapGridVert from '../shaders/hexagon_vert.glsl';\n\ninterface IHeatMapLayerStyleOptions {\n  opacity: number;\n  coverage: number;\n}\n\nexport default class HexagonModel extends BaseModel {\n  public getUninforms(): IModelUniform {\n    const {\n      opacity,\n      coverage,\n    } = this.layer.getLayerConfig() as IHeatMapLayerStyleOptions;\n    return {\n      u_opacity: opacity || 1.0,\n      u_coverage: coverage || 0.9,\n      u_radius: [\n        this.layer.getSource().data.xOffset,\n        this.layer.getSource().data.yOffset,\n      ],\n    };\n  }\n\n  public buildModels(): IModel[] {\n    return [\n      this.layer.buildLayerModel({\n        moduleName: 'hexagonheatmap',\n        vertexShader: heatmapGridVert,\n        fragmentShader: heatmapGridFrag,\n        triangulation: HeatmapGridTriangulation,\n        depth: { enable: false },\n        primitive: gl.TRIANGLES,\n      }),\n    ];\n  }\n  protected registerBuiltinAttributes() {\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'pos', // 顶点经纬度位置\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Pos',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 3,\n        update: (feature: IEncodeFeature, featureIdx: number) => {\n          const coordinates = feature.coordinates as number[];\n          return [coordinates[0], coordinates[1], 0];\n        },\n      },\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}