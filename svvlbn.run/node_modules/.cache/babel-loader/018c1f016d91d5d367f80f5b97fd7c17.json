{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _bytesPerElementMap, _dec, _dec2, _class, _class2, _descriptor, _temp;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { inject, injectable } from 'inversify';\nimport { TYPES } from '../../types';\nimport { gl } from '../renderer/gl';\nimport StyleAttribute from './StyleAttribute';\nvar bytesPerElementMap = (_bytesPerElementMap = {}, _defineProperty(_bytesPerElementMap, gl.FLOAT, 4), _defineProperty(_bytesPerElementMap, gl.UNSIGNED_BYTE, 1), _defineProperty(_bytesPerElementMap, gl.UNSIGNED_SHORT, 2), _bytesPerElementMap);\nvar counter = 0;\nvar StyleAttributeService = (_dec = injectable(), _dec2 = inject(TYPES.IRendererService), _dec(_class = (_class2 = (_temp = function () {\n  function StyleAttributeService() {\n    _classCallCheck(this, StyleAttributeService);\n\n    this.attributesAndIndices = void 0;\n\n    _initializerDefineProperty(this, \"rendererService\", _descriptor, this);\n\n    this.attributes = [];\n    this.triangulation = void 0;\n    this.c = counter++;\n    this.featureLayout = {\n      sizePerElement: 0,\n      elements: []\n    };\n  }\n\n  _createClass(StyleAttributeService, [{\n    key: \"registerStyleAttribute\",\n    value: function registerStyleAttribute(options) {\n      var attributeToUpdate = this.getLayerStyleAttribute(options.name || '');\n\n      if (attributeToUpdate) {\n        attributeToUpdate.setProps(options);\n      } else {\n        attributeToUpdate = new StyleAttribute(options);\n        this.attributes.push(attributeToUpdate);\n      }\n\n      return attributeToUpdate;\n    }\n  }, {\n    key: \"updateStyleAttribute\",\n    value: function updateStyleAttribute(attributeName, options, updateOptions) {\n      var attributeToUpdate = this.getLayerStyleAttribute(attributeName);\n\n      if (!attributeToUpdate) {\n        attributeToUpdate = this.registerStyleAttribute(_objectSpread({}, options, {\n          name: attributeName\n        }));\n      }\n\n      var scale = options.scale;\n\n      if (scale && attributeToUpdate) {\n        attributeToUpdate.scale = scale;\n        attributeToUpdate.needRescale = true;\n        attributeToUpdate.needRemapping = true;\n        attributeToUpdate.needRegenerateVertices = true;\n\n        if (updateOptions && updateOptions.featureRange) {\n          attributeToUpdate.featureRange = updateOptions.featureRange;\n        }\n      }\n    }\n  }, {\n    key: \"getLayerStyleAttributes\",\n    value: function getLayerStyleAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getLayerStyleAttribute\",\n    value: function getLayerStyleAttribute(attributeName) {\n      return this.attributes.find(function (attribute) {\n        return attribute.name === attributeName;\n      });\n    }\n  }, {\n    key: \"updateAttributeByFeatureRange\",\n    value: function updateAttributeByFeatureRange(attributeName, features) {\n      var startFeatureIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var endFeatureIdx = arguments.length > 3 ? arguments[3] : undefined;\n      var attributeToUpdate = this.attributes.find(function (attribute) {\n        return attribute.name === attributeName;\n      });\n\n      if (attributeToUpdate && attributeToUpdate.descriptor) {\n        var descriptor = attributeToUpdate.descriptor;\n        var update = descriptor.update,\n            buffer = descriptor.buffer,\n            _descriptor$size = descriptor.size,\n            size = _descriptor$size === void 0 ? 0 : _descriptor$size;\n        var bytesPerElement = bytesPerElementMap[buffer.type || gl.FLOAT];\n\n        if (update) {\n          var _this$featureLayout = this.featureLayout,\n              elements = _this$featureLayout.elements,\n              sizePerElement = _this$featureLayout.sizePerElement;\n          var featuresToUpdate = elements.slice(startFeatureIdx, endFeatureIdx);\n\n          if (!featuresToUpdate.length) {\n            return;\n          }\n\n          var offset = featuresToUpdate[0].offset;\n          var bufferOffsetInBytes = offset * size * bytesPerElement;\n          var updatedBufferData = featuresToUpdate.map(function (_ref, attributeIdx) {\n            var featureIdx = _ref.featureIdx,\n                vertices = _ref.vertices,\n                normals = _ref.normals;\n            var verticesNumForCurrentFeature = vertices.length / sizePerElement;\n            var featureData = [];\n\n            for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {\n              var normal = normals ? normals.slice(vertexIdx * 3, vertexIdx * 3 + 3) : [];\n              featureData.push.apply(featureData, _toConsumableArray(update(features[featureIdx], featureIdx, vertices.slice(vertexIdx * sizePerElement, vertexIdx * sizePerElement + sizePerElement), attributeIdx, normal)));\n            }\n\n            return featureData;\n          }).reduce(function (prev, cur) {\n            prev.push.apply(prev, _toConsumableArray(cur));\n            return prev;\n          }, []);\n          attributeToUpdate.vertexAttribute.updateBuffer({\n            data: updatedBufferData,\n            offset: bufferOffsetInBytes\n          });\n        }\n      }\n    }\n  }, {\n    key: \"createAttributesAndIndices\",\n    value: function createAttributesAndIndices(features, triangulation) {\n      var _this = this;\n\n      if (triangulation) {\n        this.triangulation = triangulation;\n      }\n\n      var descriptors = this.attributes.map(function (attr) {\n        attr.resetDescriptor();\n        return attr.descriptor;\n      });\n      var verticesNum = 0;\n      var vertices = [];\n      var indices = [];\n      var normals = [];\n      var size = 3;\n      features.forEach(function (feature, featureIdx) {\n        var _this$triangulation = _this.triangulation(feature),\n            indicesForCurrentFeature = _this$triangulation.indices,\n            verticesForCurrentFeature = _this$triangulation.vertices,\n            normalsForCurrentFeature = _this$triangulation.normals,\n            vertexSize = _this$triangulation.size;\n\n        indicesForCurrentFeature.forEach(function (i) {\n          indices.push(i + verticesNum);\n        });\n        verticesForCurrentFeature.forEach(function (index) {\n          vertices.push(index);\n        });\n\n        if (normalsForCurrentFeature) {\n          normalsForCurrentFeature.forEach(function (normal) {\n            normals.push(normal);\n          });\n        }\n\n        size = vertexSize;\n        var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;\n        _this.featureLayout.sizePerElement = size;\n\n        _this.featureLayout.elements.push({\n          featureIdx: featureIdx,\n          vertices: verticesForCurrentFeature,\n          normals: normalsForCurrentFeature,\n          offset: verticesNum\n        });\n\n        verticesNum += verticesNumForCurrentFeature;\n\n        var _loop = function _loop(vertexIdx) {\n          descriptors.forEach(function (descriptor, attributeIdx) {\n            if (descriptor && descriptor.update) {\n              var _ref2;\n\n              var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];\n\n              (_ref2 = descriptor.buffer.data).push.apply(_ref2, _toConsumableArray(descriptor.update(feature, featureIdx, verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize), vertexIdx, normal)));\n            }\n          });\n        };\n\n        for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {\n          _loop(vertexIdx);\n        }\n      });\n      var _this$rendererService = this.rendererService,\n          createAttribute = _this$rendererService.createAttribute,\n          createBuffer = _this$rendererService.createBuffer,\n          createElements = _this$rendererService.createElements;\n      var attributes = {};\n      descriptors.forEach(function (descriptor, attributeIdx) {\n        if (descriptor) {\n          var buffer = descriptor.buffer,\n              update = descriptor.update,\n              name = descriptor.name,\n              rest = _objectWithoutProperties(descriptor, [\"buffer\", \"update\", \"name\"]);\n\n          var vertexAttribute = createAttribute(_objectSpread({\n            buffer: createBuffer(buffer)\n          }, rest));\n          attributes[descriptor.name || ''] = vertexAttribute;\n          _this.attributes[attributeIdx].vertexAttribute = vertexAttribute;\n        }\n      });\n      var elements = createElements({\n        data: indices,\n        type: gl.UNSIGNED_INT,\n        count: indices.length\n      });\n      this.attributesAndIndices = {\n        attributes: attributes,\n        elements: elements\n      };\n      return this.attributesAndIndices;\n    }\n  }, {\n    key: \"clearAllAttributes\",\n    value: function clearAllAttributes() {\n      this.attributes.forEach(function (attribute) {\n        if (attribute.vertexAttribute) {\n          attribute.vertexAttribute.destroy();\n        }\n      });\n      this.attributes = [];\n    }\n  }]);\n\n  return StyleAttributeService;\n}(), _temp), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"rendererService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);\nexport { StyleAttributeService as default };","map":{"version":3,"sources":["../../../src/services/layer/StyleAttributeService.ts"],"names":["bytesPerElementMap","gl","counter","injectable","StyleAttributeService","attributesAndIndices","inject","TYPES","attributes","triangulation","c","featureLayout","sizePerElement","elements","options","attributeToUpdate","attributeName","updateOptions","name","scale","attribute","features","startFeatureIdx","endFeatureIdx","descriptor","update","buffer","size","bytesPerElement","featuresToUpdate","offset","bufferOffsetInBytes","updatedBufferData","featureIdx","vertices","normals","verticesNumForCurrentFeature","featureData","vertexIdx","normal","prev","data","descriptors","attr","verticesNum","indices","indicesForCurrentFeature","verticesForCurrentFeature","normalsForCurrentFeature","vertexSize","i","createAttribute","createBuffer","createElements","rest","vertexAttribute","type","count","length"],"mappings":"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","sourcesContent":["import { inject, injectable } from 'inversify';\nimport { TYPES } from '../../types';\nimport { gl } from '../renderer/gl';\nimport { IAttribute } from '../renderer/IAttribute';\nimport { IElements } from '../renderer/IElements';\nimport { IRendererService } from '../renderer/IRendererService';\nimport { IParseDataItem } from '../source/ISourceService';\nimport { ILayer } from './ILayerService';\nimport {\n  IEncodeFeature,\n  IStyleAttribute,\n  IStyleAttributeInitializationOptions,\n  IStyleAttributeService,\n  IStyleAttributeUpdateOptions,\n  IVertexAttributeDescriptor,\n  Triangulation,\n} from './IStyleAttributeService';\nimport StyleAttribute from './StyleAttribute';\n\nconst bytesPerElementMap = {\n  [gl.FLOAT]: 4,\n  [gl.UNSIGNED_BYTE]: 1,\n  [gl.UNSIGNED_SHORT]: 2,\n};\n\nlet counter = 0;\n\n/**\n * 每个 Layer 都拥有一个，用于管理样式属性的注册和更新\n */\n@injectable()\nexport default class StyleAttributeService implements IStyleAttributeService {\n  public attributesAndIndices: {\n    attributes: {\n      [attributeName: string]: IAttribute;\n    };\n    elements: IElements;\n  };\n  @inject(TYPES.IRendererService)\n  private readonly rendererService: IRendererService;\n\n  private attributes: IStyleAttribute[] = [];\n\n  private triangulation: Triangulation;\n\n  private c = counter++;\n\n  private featureLayout: {\n    sizePerElement: number;\n    elements: Array<{\n      featureIdx: number;\n      vertices: number[];\n      normals: number[];\n      offset: number;\n    }>;\n  } = {\n    sizePerElement: 0,\n    elements: [],\n  };\n  public registerStyleAttribute(\n    options: Partial<IStyleAttributeInitializationOptions>,\n  ) {\n    let attributeToUpdate = this.getLayerStyleAttribute(options.name || '');\n    if (attributeToUpdate) {\n      attributeToUpdate.setProps(options);\n    } else {\n      attributeToUpdate = new StyleAttribute(options);\n      this.attributes.push(attributeToUpdate);\n    }\n    return attributeToUpdate;\n  }\n\n  public updateStyleAttribute(\n    attributeName: string,\n    options: Partial<IStyleAttributeInitializationOptions>,\n    updateOptions?: Partial<IStyleAttributeUpdateOptions>,\n  ) {\n    let attributeToUpdate = this.getLayerStyleAttribute(attributeName);\n    if (!attributeToUpdate) {\n      attributeToUpdate = this.registerStyleAttribute({\n        ...options,\n        name: attributeName,\n      });\n    }\n    const { scale } = options;\n    if (scale && attributeToUpdate) {\n      // TODO: 需要比较新旧值确定是否需要 rescale\n      // 需要重新 scale，肯定也需要重新进行数据映射\n      attributeToUpdate.scale = scale;\n      attributeToUpdate.needRescale = true;\n      attributeToUpdate.needRemapping = true;\n      attributeToUpdate.needRegenerateVertices = true;\n      if (updateOptions && updateOptions.featureRange) {\n        attributeToUpdate.featureRange = updateOptions.featureRange;\n      }\n    }\n  }\n\n  public getLayerStyleAttributes(): IStyleAttribute[] | undefined {\n    return this.attributes;\n  }\n\n  public getLayerStyleAttribute(\n    attributeName: string,\n  ): IStyleAttribute | undefined {\n    return this.attributes.find(\n      (attribute) => attribute.name === attributeName,\n    );\n  }\n\n  public updateAttributeByFeatureRange(\n    attributeName: string,\n    features: IEncodeFeature[],\n    startFeatureIdx: number = 0,\n    endFeatureIdx?: number,\n  ) {\n    const attributeToUpdate = this.attributes.find(\n      (attribute) => attribute.name === attributeName,\n    );\n    if (attributeToUpdate && attributeToUpdate.descriptor) {\n      const { descriptor } = attributeToUpdate;\n      const { update, buffer, size = 0 } = descriptor;\n      const bytesPerElement = bytesPerElementMap[buffer.type || gl.FLOAT];\n      if (update) {\n        const { elements, sizePerElement } = this.featureLayout;\n        // 截取待更新的 feature 范围\n        const featuresToUpdate = elements.slice(startFeatureIdx, endFeatureIdx);\n\n        // [n, n] 中断更新\n        if (!featuresToUpdate.length) {\n          return;\n        }\n        const { offset } = featuresToUpdate[0];\n        // 以 byte 为单位计算 buffer 中的偏移\n        const bufferOffsetInBytes = offset * size * bytesPerElement;\n        const updatedBufferData = featuresToUpdate\n          .map(({ featureIdx, vertices, normals }, attributeIdx) => {\n            const verticesNumForCurrentFeature =\n              vertices.length / sizePerElement;\n            const featureData: number[] = [];\n            for (\n              let vertexIdx = 0;\n              vertexIdx < verticesNumForCurrentFeature;\n              vertexIdx++\n            ) {\n              const normal = normals\n                ? normals!.slice(vertexIdx * 3, vertexIdx * 3 + 3)\n                : [];\n              featureData.push(\n                ...update(\n                  features[featureIdx],\n                  featureIdx,\n                  vertices.slice(\n                    vertexIdx * sizePerElement,\n                    vertexIdx * sizePerElement + sizePerElement,\n                  ),\n                  attributeIdx,\n                  normal,\n                ),\n              );\n            }\n            return featureData;\n          })\n          .reduce((prev, cur) => {\n            prev.push(...cur);\n            return prev;\n          }, []);\n\n        // 更新底层 IAttribute 中包含的 IBuffer，使用 subdata\n        attributeToUpdate.vertexAttribute.updateBuffer({\n          data: updatedBufferData,\n          offset: bufferOffsetInBytes,\n        });\n      }\n    }\n  }\n\n  public createAttributesAndIndices(\n    features: IEncodeFeature[],\n    triangulation?: Triangulation,\n  ): {\n    attributes: {\n      [attributeName: string]: IAttribute;\n    };\n    elements: IElements;\n  } {\n    if (triangulation) {\n      this.triangulation = triangulation;\n    }\n    const descriptors = this.attributes.map((attr) => {\n      attr.resetDescriptor();\n      return attr.descriptor;\n    });\n    let verticesNum = 0;\n    const vertices: number[] = [];\n    const indices: number[] = [];\n    const normals: number[] = [];\n    let size = 3;\n\n    features.forEach((feature, featureIdx) => {\n      // 逐 feature 进行三角化\n      const {\n        indices: indicesForCurrentFeature,\n        vertices: verticesForCurrentFeature,\n        normals: normalsForCurrentFeature,\n        size: vertexSize,\n      } = this.triangulation(feature);\n      indicesForCurrentFeature.forEach((i) => {\n        indices.push(i + verticesNum);\n      });\n      verticesForCurrentFeature.forEach((index) => {\n        vertices.push(index);\n      });\n      // fix Maximum call stack size exceeded https://stackoverflow.com/questions/22123769/rangeerror-maximum-call-stack-size-exceeded-why\n      if (normalsForCurrentFeature) {\n        normalsForCurrentFeature.forEach((normal) => {\n          normals.push(normal);\n        });\n      }\n      size = vertexSize;\n      const verticesNumForCurrentFeature =\n        verticesForCurrentFeature.length / vertexSize;\n\n      // 记录三角化结果，用于后续精确更新指定 feature\n      this.featureLayout.sizePerElement = size;\n      this.featureLayout.elements.push({\n        featureIdx,\n        vertices: verticesForCurrentFeature,\n        normals: normalsForCurrentFeature as number[],\n        offset: verticesNum,\n      });\n\n      verticesNum += verticesNumForCurrentFeature;\n      // 根据 position 顶点生成其他顶点数据\n      for (\n        let vertexIdx = 0;\n        vertexIdx < verticesNumForCurrentFeature;\n        vertexIdx++\n      ) {\n        descriptors.forEach((descriptor, attributeIdx) => {\n          if (descriptor && descriptor.update) {\n            const normal =\n              normalsForCurrentFeature?.slice(\n                vertexIdx * 3,\n                vertexIdx * 3 + 3,\n              ) || [];\n            (descriptor.buffer.data as number[]).push(\n              ...descriptor.update(\n                feature,\n                featureIdx,\n                verticesForCurrentFeature.slice(\n                  vertexIdx * vertexSize,\n                  vertexIdx * vertexSize + vertexSize,\n                ),\n                vertexIdx, // 当前顶点所在feature索引\n                normal,\n                // TODO: 传入顶点索引 vertexIdx\n              ),\n            );\n          } // end if\n        }); // end for each\n      } // end for\n    }); // end features for Each\n    const {\n      createAttribute,\n      createBuffer,\n      createElements,\n    } = this.rendererService;\n\n    const attributes: {\n      [attributeName: string]: IAttribute;\n    } = {};\n    descriptors.forEach((descriptor, attributeIdx) => {\n      if (descriptor) {\n        // IAttribute 参数透传\n        const { buffer, update, name, ...rest } = descriptor;\n\n        const vertexAttribute = createAttribute({\n          // IBuffer 参数透传\n          buffer: createBuffer(buffer),\n          ...rest,\n        });\n        attributes[descriptor.name || ''] = vertexAttribute;\n\n        // 在 StyleAttribute 上保存对 VertexAttribute 的引用\n        this.attributes[attributeIdx].vertexAttribute = vertexAttribute;\n      }\n    });\n\n    const elements = createElements({\n      data: indices,\n      type: gl.UNSIGNED_INT,\n      count: indices.length,\n    });\n    this.attributesAndIndices = {\n      attributes,\n      elements,\n    };\n    return this.attributesAndIndices;\n  }\n  public clearAllAttributes() {\n    // 销毁关联的 vertex attribute buffer objects\n    this.attributes.forEach((attribute) => {\n      if (attribute.vertexAttribute) {\n        attribute.vertexAttribute.destroy();\n      }\n    });\n    this.attributes = [];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}