{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar glyphSizeInSDF = 30;\nexport function buildMapping(_ref) {\n  var characterSet = _ref.characterSet,\n      getFontWidth = _ref.getFontWidth,\n      fontHeight = _ref.fontHeight,\n      buffer = _ref.buffer,\n      maxCanvasWidth = _ref.maxCanvasWidth,\n      _ref$mapping = _ref.mapping,\n      mapping = _ref$mapping === void 0 ? {} : _ref$mapping,\n      _ref$xOffset = _ref.xOffset,\n      xOffset = _ref$xOffset === void 0 ? 0 : _ref$xOffset,\n      _ref$yOffset = _ref.yOffset,\n      yOffset = _ref$yOffset === void 0 ? 0 : _ref$yOffset;\n  var row = 0;\n  var x = xOffset;\n  Array.from(characterSet).forEach(function (char, i) {\n    if (!mapping[char]) {\n      var width = getFontWidth(char, i);\n\n      if (x + glyphSizeInSDF > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n\n      mapping[char] = {\n        x: x,\n        y: yOffset + row * glyphSizeInSDF,\n        width: glyphSizeInSDF,\n        height: glyphSizeInSDF,\n        advance: width\n      };\n      x += glyphSizeInSDF;\n    }\n  });\n  var rowHeight = fontHeight + buffer * 2;\n  return {\n    mapping: mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\nexport function buildIconMaping(icons, buffer, maxCanvasWidth) {\n  var xOffset = 0;\n  var yOffset = 0;\n  var rowHeight = 0;\n  var columns = [];\n  var mapping = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = icons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var icon = _step.value;\n\n      if (!mapping[icon.id]) {\n        var height = icon.height,\n            width = icon.width;\n\n        if (xOffset + width + buffer > maxCanvasWidth) {\n          buildRowMapping(mapping, columns, yOffset);\n          xOffset = 0;\n          yOffset = rowHeight + yOffset + buffer;\n          rowHeight = 0;\n          columns = [];\n        }\n\n        columns.push({\n          icon: icon,\n          xOffset: xOffset\n        });\n        xOffset = xOffset + width + buffer;\n        rowHeight = Math.max(rowHeight, height);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  var canvasHeight = nextPowOfTwo(rowHeight + yOffset + buffer);\n  return {\n    mapping: mapping,\n    canvasHeight: canvasHeight\n  };\n}\n\nfunction buildRowMapping(mapping, columns, yOffset) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = columns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var column = _step2.value;\n      var icon = column.icon,\n          xOffset = column.xOffset;\n      mapping[icon.id] = _objectSpread({}, icon, {\n        x: xOffset,\n        y: yOffset,\n        image: icon.image\n      });\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nexport function nextPowOfTwo(num) {\n  return Math.pow(2, Math.ceil(Math.log2(num)));\n}","map":{"version":3,"sources":["../../src/utils/font_util.ts"],"names":["glyphSizeInSDF","characterSet","getFontWidth","fontHeight","buffer","maxCanvasWidth","mapping","xOffset","yOffset","row","x","Array","width","y","height","advance","rowHeight","canvasHeight","nextPowOfTwo","columns","icon","icons","buildRowMapping","Math","column","image"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,IAAMA,cAAc,GAApB,EAAA;AACA,OAAO,SAAA,YAAA,CAAA,IAAA,EASgB;AAAA,MARrBC,YAQqB,GAAA,IAAA,CARrBA,YAQqB;AAAA,MAPrBC,YAOqB,GAAA,IAAA,CAPrBA,YAOqB;AAAA,MANrBC,UAMqB,GAAA,IAAA,CANrBA,UAMqB;AAAA,MALrBC,MAKqB,GAAA,IAAA,CALrBA,MAKqB;AAAA,MAJrBC,cAIqB,GAAA,IAAA,CAJrBA,cAIqB;AAAA,MAAA,YAAA,GAAA,IAAA,CAHrBC,OAGqB;AAAA,MAHrBA,OAGqB,GAAA,YAAA,KAAA,KAAA,CAAA,GAHX,EAGW,GAAA,YAAA;AAAA,MAAA,YAAA,GAAA,IAAA,CAFrBC,OAEqB;AAAA,MAFrBA,OAEqB,GAAA,YAAA,KAAA,KAAA,CAAA,GAFX,CAEW,GAAA,YAAA;AAAA,MAAA,YAAA,GAAA,IAAA,CADrBC,OACqB;AAAA,MADrBA,OACqB,GAAA,YAAA,KAAA,KAAA,CAAA,GADX,CACW,GAAA,YAAA;AACrB,MAAIC,GAAG,GAAP,CAAA;AACA,MAAIC,CAAC,GAAL,OAAA;AACAC,EAAAA,KAAK,CAALA,IAAAA,CAAAA,YAAAA,EAAAA,OAAAA,CAAiC,UAAA,IAAA,EAAA,CAAA,EAA6B;AAC5D,QAAI,CAACL,OAAO,CAAZ,IAAY,CAAZ,EAAoB;AAClB,UAAMM,KAAK,GAAGV,YAAY,CAAA,IAAA,EAA1B,CAA0B,CAA1B;;AACA,UAAIQ,CAAC,GAADA,cAAAA,GAAJ,cAAA,EAAyC;AACvCA,QAAAA,CAAC,GAADA,CAAAA;AACAD,QAAAA,GAAG;AACJ;;AACDH,MAAAA,OAAO,CAAPA,IAAO,CAAPA,GAAgB;AACdI,QAAAA,CAAC,EADa,CAAA;AAEdG,QAAAA,CAAC,EAAEL,OAAO,GAAGC,GAAG,GAFF,cAAA;AAGdG,QAAAA,KAAK,EAHS,cAAA;AAIdE,QAAAA,MAAM,EAJQ,cAAA;AAKdC,QAAAA,OAAO,EAAEH;AALK,OAAhBN;AAOAI,MAAAA,CAAC,IAADA,cAAAA;AACD;AAfHC,GAAAA;AAkBA,MAAMK,SAAS,GAAGb,UAAU,GAAGC,MAAM,GAArC,CAAA;AAEA,SAAO;AACLE,IAAAA,OAAO,EADF,OAAA;AAELC,IAAAA,OAAO,EAFF,CAAA;AAGLC,IAAAA,OAAO,EAAEA,OAAO,GAAGC,GAAG,GAHjB,SAAA;AAILQ,IAAAA,YAAY,EAAEC,YAAY,CAACV,OAAO,GAAG,CAACC,GAAG,GAAJ,CAAA,IAAX,SAAA;AAJrB,GAAP;AAMD;AAED,OAAO,SAAA,eAAA,CAAA,KAAA,EAAA,MAAA,EAAA,cAAA,EAIL;AACA,MAAIF,OAAO,GAAX,CAAA;AACA,MAAIC,OAAO,GAAX,CAAA;AACA,MAAIQ,SAAS,GAAb,CAAA;AACA,MAAIG,OAAO,GAAX,EAAA;AACA,MAAMb,OAAiB,GAAvB,EAAA;AALA,MAAA,yBAAA,GAAA,IAAA;AAAA,MAAA,iBAAA,GAAA,KAAA;AAAA,MAAA,cAAA,GAAA,SAAA;;AAAA,MAAA;AAMA,SAAA,IAAA,SAAA,GAAmBe,KAAnB,CAAA,MAAA,CAAA,QAAA,CAAmBA,EAAnB,EAAA,KAAA,EAAA,EAAA,yBAAA,GAAA,CAAA,KAAA,GAAA,SAAA,CAAA,IAAA,EAAA,EAAA,IAAA,CAAA,EAAA,yBAAA,GAAA,IAAA,EAA0B;AAAA,UAAfD,IAAe,GAAA,KAAA,CAAA,KAAA;;AACxB,UAAI,CAACd,OAAO,CAACc,IAAI,CAAjB,EAAY,CAAZ,EAAuB;AAAA,YACbN,MADa,GACKM,IADL,CAAA,MAAA;AAAA,YACLR,KADK,GACKQ,IADL,CAAA,KAAA;;AAIrB,YAAIb,OAAO,GAAPA,KAAAA,GAAAA,MAAAA,GAAJ,cAAA,EAA+C;AAC7Ce,UAAAA,eAAe,CAAA,OAAA,EAAA,OAAA,EAAfA,OAAe,CAAfA;AAEAf,UAAAA,OAAO,GAAPA,CAAAA;AACAC,UAAAA,OAAO,GAAGQ,SAAS,GAATA,OAAAA,GAAVR,MAAAA;AACAQ,UAAAA,SAAS,GAATA,CAAAA;AACAG,UAAAA,OAAO,GAAPA,EAAAA;AACD;;AAEDA,QAAAA,OAAO,CAAPA,IAAAA,CAAa;AACXC,UAAAA,IAAI,EADO,IAAA;AAEXb,UAAAA,OAAO,EAAPA;AAFW,SAAbY;AAKAZ,QAAAA,OAAO,GAAGA,OAAO,GAAPA,KAAAA,GAAVA,MAAAA;AACAS,QAAAA,SAAS,GAAGO,IAAI,CAAJA,GAAAA,CAAAA,SAAAA,EAAZP,MAAYO,CAAZP;AACD;AACF;AA5BD,GAAA,CAAA,OAAA,GAAA,EAAA;AAAA,IAAA,iBAAA,GAAA,IAAA;AAAA,IAAA,cAAA,GAAA,GAAA;AAAA,GAAA,SAAA;AAAA,QAAA;AAAA,UAAA,CAAA,yBAAA,IAAA,SAAA,CAAA,MAAA,IAAA,IAAA,EAAA;AAAA,QAAA,SAAA,CAAA,MAAA;AAAA;AAAA,KAAA,SAAA;AAAA,UAAA,iBAAA,EAAA;AAAA,cAAA,cAAA;AAAA;AAAA;AAAA;;AA8BA,MAAIG,OAAO,CAAPA,MAAAA,GAAJ,CAAA,EAAwB;AACtBG,IAAAA,eAAe,CAAA,OAAA,EAAA,OAAA,EAAfA,OAAe,CAAfA;AACD;;AAED,MAAML,YAAY,GAAGC,YAAY,CAACF,SAAS,GAATA,OAAAA,GAAlC,MAAiC,CAAjC;AAEA,SAAO;AACLV,IAAAA,OAAO,EADF,OAAA;AAELW,IAAAA,YAAY,EAAZA;AAFK,GAAP;AAID;;AACD,SAAA,eAAA,CAAA,OAAA,EAAA,OAAA,EAAA,OAAA,EAOE;AAAA,MAAA,0BAAA,GAAA,IAAA;AAAA,MAAA,kBAAA,GAAA,KAAA;AAAA,MAAA,eAAA,GAAA,SAAA;;AAAA,MAAA;AACA,SAAA,IAAA,UAAA,GAAqBE,OAArB,CAAA,MAAA,CAAA,QAAA,CAAqBA,EAArB,EAAA,MAAA,EAAA,EAAA,0BAAA,GAAA,CAAA,MAAA,GAAA,UAAA,CAAA,IAAA,EAAA,EAAA,IAAA,CAAA,EAAA,0BAAA,GAAA,IAAA,EAA8B;AAAA,UAAnBK,MAAmB,GAAA,MAAA,CAAA,KAAA;AAAA,UACpBJ,IADoB,GACFI,MADE,CAAA,IAAA;AAAA,UACdjB,OADc,GACFiB,MADE,CAAA,OAAA;AAE5BlB,MAAAA,OAAO,CAACc,IAAI,CAAZd,EAAO,CAAPA,GAAAA,aAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA;AAA8BI,QAAAA,CAAC,EAA/BJ,OAAAA;AAA0CO,QAAAA,CAAC,EAA3CP,OAAAA;AAAsDmB,QAAAA,KAAK,EAAEL,IAAI,CAACK;AAAlEnB,OAAAA,CAAAA;AACD;AAJD,GAAA,CAAA,OAAA,GAAA,EAAA;AAAA,IAAA,kBAAA,GAAA,IAAA;AAAA,IAAA,eAAA,GAAA,GAAA;AAAA,GAAA,SAAA;AAAA,QAAA;AAAA,UAAA,CAAA,0BAAA,IAAA,UAAA,CAAA,MAAA,IAAA,IAAA,EAAA;AAAA,QAAA,UAAA,CAAA,MAAA;AAAA;AAAA,KAAA,SAAA;AAAA,UAAA,kBAAA,EAAA;AAAA,cAAA,eAAA;AAAA;AAAA;AAAA;AAKD;;AACD,OAAO,SAAA,YAAA,CAAA,GAAA,EAAmC;AACxC,SAAOiB,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAYA,IAAI,CAAJA,IAAAA,CAAUA,IAAI,CAAJA,IAAAA,CAA7B,GAA6BA,CAAVA,CAAZA,CAAP;AACD","sourcesContent":["import { IFontMappingOption } from '../services/asset/IFontService';\nimport { IIcon, IICONMap } from '../services/asset/IIconService';\n/**\n * tiny-sdf 中每个 glyph 的宽度（加上 buffer 24 + 3 + 3 = 30）\n */\nconst glyphSizeInSDF = 30;\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n}: IFontMappingOption) {\n  let row = 0;\n  let x = xOffset;\n  Array.from(characterSet).forEach((char: string, i: number) => {\n    if (!mapping[char]) {\n      const width = getFontWidth(char, i);\n      if (x + glyphSizeInSDF > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x,\n        y: yOffset + row * glyphSizeInSDF,\n        width: glyphSizeInSDF,\n        height: glyphSizeInSDF,\n        advance: width,\n      };\n      x += glyphSizeInSDF;\n    }\n  });\n\n  const rowHeight = fontHeight + buffer * 2;\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight),\n  };\n}\n\nexport function buildIconMaping(\n  icons: IIcon[],\n  buffer: number,\n  maxCanvasWidth: number,\n) {\n  let xOffset = 0;\n  let yOffset = 0;\n  let rowHeight = 0;\n  let columns = [];\n  const mapping: IICONMap = {};\n  for (const icon of icons) {\n    if (!mapping[icon.id]) {\n      const { height, width } = icon;\n\n      // fill one row\n      if (xOffset + width + buffer > maxCanvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset,\n      });\n\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  const canvasHeight = nextPowOfTwo(rowHeight + yOffset + buffer);\n\n  return {\n    mapping,\n    canvasHeight,\n  };\n}\nfunction buildRowMapping(\n  mapping: IICONMap,\n  columns: Array<{\n    icon: IIcon;\n    xOffset: number;\n  }>,\n  yOffset: number,\n) {\n  for (const column of columns) {\n    const { icon, xOffset } = column;\n    mapping[icon.id] = { ...icon, x: xOffset, y: yOffset, image: icon.image };\n  }\n}\nexport function nextPowOfTwo(num: number) {\n  return Math.pow(2, Math.ceil(Math.log2(num)));\n}\n"]},"metadata":{},"sourceType":"module"}