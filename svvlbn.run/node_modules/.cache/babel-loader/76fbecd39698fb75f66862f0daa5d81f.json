{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { aProjectFlat } from '@antv/l7-utils';\nimport { vec2 } from 'gl-matrix';\nexport function computeMiter(tangent, miter, lineA, lineB, halfThick) {\n  vec2.add(tangent, lineA, lineB);\n  vec2.normalize(tangent, tangent);\n  miter = vec2.fromValues(-tangent[1], tangent[0]);\n  var tmp = vec2.fromValues(-lineA[1], lineA[0]);\n  return halfThick / vec2.dot(miter, tmp);\n}\nexport function computeNormal(out, dir) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\nexport function direction(out, a, b) {\n  var a1 = aProjectFlat([a[0], a[1]]);\n  var b1 = aProjectFlat([b[0], b[1]]);\n  vec2.sub(out, a1, b1);\n  vec2.normalize(out, out);\n  return out;\n}\n\nfunction extrusions(positions, out, miters, point, normal, scale) {\n  addNext(out, miters, normal, -scale);\n  addNext(out, miters, normal, scale);\n  positions.push(point[0], point[1], 0);\n  positions.push(point[0], point[1], 0);\n}\n\nfunction addNext(out, miters, normal, length) {\n  out.push(normal[0], normal[1], 0);\n  miters.push(length);\n}\n\nfunction lineSegmentDistance(end, start) {\n  var a1 = aProjectFlat([start[0], start[1]]);\n  var b1 = aProjectFlat([end[0], end[1]]);\n  var dx = a1[0] - b1[0];\n  var dy = a1[1] - b1[1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction isPointEqual(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\nexport default function (points, closed, indexOffset) {\n  var lineA = vec2.fromValues(0, 0);\n  var lineB = vec2.fromValues(0, 0);\n  var tangent = vec2.fromValues(0, 0);\n  var miter = vec2.create();\n  var started = false;\n  var lineNormal = null;\n  var tmp = vec2.create();\n  var count = indexOffset || 0;\n  var miterLimit = 3;\n  var out = [];\n  var attrPos = [];\n  var attrIndex = [];\n  var miters = [];\n  var attrDistance = [0, 0];\n\n  if (closed) {\n    points = points.slice();\n    points.push(points[0]);\n  }\n\n  var total = points.length;\n\n  for (var i = 1; i < total; i++) {\n    var index = count;\n    var last = vec2.fromValues(points[i - 1][0], points[i - 1][1]);\n    var cur = vec2.fromValues(points[i][0], points[i][1]);\n    var next = i < points.length - 1 ? vec2.fromValues(points[i + 1][0], points[i + 1][1]) : null;\n\n    if (isPointEqual(last, cur)) {\n      continue;\n    }\n\n    if (next) {\n      var nextIndex = i + 1;\n\n      while (next && isPointEqual(cur, next)) {\n        next = nextIndex < points.length - 1 ? vec2.fromValues(points[++nextIndex][0], points[nextIndex][1]) : null;\n      }\n    }\n\n    var lineDistance = lineSegmentDistance(cur, last);\n    var d = lineDistance + attrDistance[attrDistance.length - 1];\n    direction(lineA, cur, last);\n\n    if (!lineNormal) {\n      lineNormal = vec2.create();\n      computeNormal(lineNormal, lineA);\n    }\n\n    if (!started) {\n      started = true;\n      extrusions(attrPos, out, miters, last, lineNormal, 1);\n    }\n\n    attrIndex.push(index + 0, index + 2, index + 1);\n\n    if (!next) {\n      computeNormal(lineNormal, lineA);\n      extrusions(attrPos, out, miters, cur, lineNormal, 1);\n      attrDistance.push(d, d);\n      attrIndex.push(index + 1, index + 2, index + 3);\n      count += 2;\n    } else {\n      direction(lineB, next, cur);\n      var miterLen = computeMiter(tangent, vec2.fromValues(miter[0], miter[1]), lineA, lineB, 1);\n      var flip = vec2.dot(tangent, lineNormal) < 0 ? -1 : 1;\n      var bevel = Math.abs(miterLen) > miterLimit;\n\n      if (Math.abs(miterLen) > 1000) {\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n        attrIndex.push(index + 1, index + 2, index + 3);\n        attrIndex.push(index + 2, index + 4, index + 3);\n        computeNormal(tmp, lineB);\n        vec2.copy(lineNormal, tmp);\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n        attrDistance.push(d, d, d, d);\n        count += 4;\n        continue;\n      }\n\n      if (bevel) {\n        miterLen = miterLimit;\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n        attrIndex.push(index + 1, index + 2, index + 3);\n        attrIndex.push.apply(attrIndex, _toConsumableArray(flip === 1 ? [index + 2, index + 4, index + 5] : [index + 4, index + 5, index + 3]));\n        computeNormal(tmp, lineB);\n        vec2.copy(lineNormal, tmp);\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n        attrDistance.push(d, d, d, d);\n        count += 4;\n      } else {\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n        attrIndex.push(index + 1, index + 2, index + 3);\n        addNext(out, miters, lineNormal, miterLen * -flip);\n        attrPos.push(cur[0], cur[1], 0);\n        attrIndex.push(index + 2, index + 4, index + 3);\n        attrIndex.push(index + 4, index + 5, index + 6);\n        computeNormal(tmp, lineB);\n        vec2.copy(lineNormal, tmp);\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n        attrDistance.push(d, d, d, d, d);\n        count += 5;\n      }\n    }\n  }\n\n  var pickData = [];\n\n  for (var _i = 0; _i < miters.length; _i++) {\n    var totalDistance = attrDistance[attrDistance.length - 1];\n    pickData.push(attrPos[_i * 3], attrPos[_i * 3 + 1], attrPos[_i * 3 + 2], attrDistance[_i], miters[_i], totalDistance);\n  }\n\n  return {\n    normals: out,\n    attrIndex: attrIndex,\n    attrPos: pickData\n  };\n}","map":{"version":3,"sources":["../../src/utils/polylineNormal.ts"],"names":["vec2","miter","tangent","tmp","lineA","halfThick","dir","a1","aProjectFlat","a","b1","b","addNext","positions","point","out","normal","miters","start","end","dx","dy","Math","lineB","started","lineNormal","count","indexOffset","miterLimit","attrPos","attrIndex","attrDistance","points","total","i","index","last","cur","next","isPointEqual","nextIndex","lineDistance","lineSegmentDistance","d","direction","computeNormal","extrusions","miterLen","computeMiter","flip","bevel","pickData","totalDistance","normals"],"mappings":"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","sourcesContent":["import { aProjectFlat, lngLatToMeters, Point } from '@antv/l7-utils';\nimport { vec2 } from 'gl-matrix';\nexport function computeMiter(\n  tangent: vec2,\n  miter: vec2,\n  lineA: vec2,\n  lineB: vec2,\n  halfThick: number,\n) {\n  vec2.add(tangent, lineA, lineB);\n  vec2.normalize(tangent, tangent);\n  miter = vec2.fromValues(-tangent[1], tangent[0]);\n  const tmp = vec2.fromValues(-lineA[1], lineA[0]);\n  return halfThick / vec2.dot(miter, tmp);\n}\nexport function computeNormal(out: vec2, dir: vec2) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\nexport function direction(out: vec2, a: vec2, b: vec2) {\n  const a1 = aProjectFlat([a[0], a[1]]);\n  const b1 = aProjectFlat([b[0], b[1]]);\n  vec2.sub(out, a1, b1);\n  vec2.normalize(out, out);\n  return out;\n}\nfunction extrusions(\n  positions: number[],\n  out: number[],\n  miters: number[],\n  point: vec2,\n  normal: vec2,\n  scale: number,\n) {\n  addNext(out, miters, normal, -scale);\n  addNext(out, miters, normal, scale);\n  positions.push(point[0], point[1], 0);\n  positions.push(point[0], point[1], 0);\n}\n\nfunction addNext(\n  out: number[],\n  miters: number[],\n  normal: vec2,\n  length: number,\n) {\n  out.push(normal[0], normal[1], 0);\n  miters.push(length);\n}\n\nfunction lineSegmentDistance(end: vec2, start: vec2) {\n  const a1 = aProjectFlat([start[0], start[1]]);\n  const b1 = aProjectFlat([end[0], end[1]]);\n  const dx = a1[0] - b1[0];\n  const dy = a1[1] - b1[1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction isPointEqual(a: vec2, b: vec2) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\nexport default function(\n  points: number[][],\n  closed: boolean,\n  indexOffset: number,\n) {\n  const lineA = vec2.fromValues(0, 0);\n  const lineB = vec2.fromValues(0, 0);\n  const tangent = vec2.fromValues(0, 0);\n  const miter: vec2 = vec2.create();\n  let started = false;\n  let lineNormal = null;\n  const tmp = vec2.create();\n  let count = indexOffset || 0;\n  const miterLimit = 3;\n\n  const out: number[] = [];\n  const attrPos: number[] = [];\n  const attrIndex: number[] = [];\n  const miters: number[] = [];\n  const attrDistance = [0, 0];\n  if (closed) {\n    points = points.slice();\n    points.push(points[0]);\n  }\n\n  const total = points.length;\n\n  for (let i = 1; i < total; i++) {\n    const index = count;\n    const last = vec2.fromValues(points[i - 1][0], points[i - 1][1]);\n    const cur = vec2.fromValues(points[i][0], points[i][1]);\n    let next =\n      i < points.length - 1\n        ? vec2.fromValues(points[i + 1][0], points[i + 1][1])\n        : null;\n    // 如果当前点和前一点相同，跳过\n    if (isPointEqual(last, cur)) {\n      continue;\n    }\n    if (next) {\n      let nextIndex = i + 1;\n      // 找到不相同的下一点\n      while (next && isPointEqual(cur, next)) {\n        next =\n          nextIndex < points.length - 1\n            ? vec2.fromValues(points[++nextIndex][0], points[nextIndex][1])\n            : null;\n      }\n    }\n    const lineDistance = lineSegmentDistance(cur, last);\n    const d = lineDistance + attrDistance[attrDistance.length - 1];\n    direction(lineA, cur, last);\n    if (!lineNormal) {\n      lineNormal = vec2.create();\n      computeNormal(lineNormal, lineA);\n    }\n\n    if (!started) {\n      started = true;\n      extrusions(attrPos, out, miters, last, lineNormal, 1);\n    }\n\n    attrIndex.push(index + 0, index + 2, index + 1);\n\n    // no miter, simple segment\n    if (!next) {\n      // reset normal\n      computeNormal(lineNormal, lineA);\n      extrusions(attrPos, out, miters, cur, lineNormal, 1);\n      attrDistance.push(d, d);\n      attrIndex.push(index + 1, index + 2, index + 3);\n      count += 2;\n    } else {\n      // get unit dir of next line\n      direction(lineB, next, cur);\n\n      // stores tangent & miter\n      let miterLen = computeMiter(\n        tangent,\n        vec2.fromValues(miter[0], miter[1]),\n        lineA,\n        lineB,\n        1,\n      );\n\n      // get orientation\n      const flip = vec2.dot(tangent, lineNormal) < 0 ? -1 : 1;\n      const bevel = Math.abs(miterLen) > miterLimit;\n\n      // 处理前后两条线段重合的情况，这种情况不需要使用任何接头（miter/bevel）。\n      // 理论上这种情况下 miterLen = Infinity，本应通过 isFinite(miterLen) 判断，\n      // 但是 AMap 投影变换后丢失精度，只能通过一个阈值（1000）判断。\n\n      if (Math.abs(miterLen) > 1000) {\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n        attrIndex.push(index + 1, index + 2, index + 3);\n        attrIndex.push(index + 2, index + 4, index + 3);\n        computeNormal(tmp, lineB);\n        vec2.copy(lineNormal, tmp); // store normal for next round\n\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n        attrDistance.push(d, d, d, d);\n\n        // the miter is now the normal for our next join\n        count += 4;\n        continue;\n      }\n\n      if (bevel) {\n        miterLen = miterLimit;\n\n        // next two points in our first segment\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n\n        attrIndex.push(index + 1, index + 2, index + 3);\n\n        // now add the bevel triangle\n        attrIndex.push(\n          ...(flip === 1\n            ? [index + 2, index + 4, index + 5]\n            : [index + 4, index + 5, index + 3]),\n        );\n\n        computeNormal(tmp, lineB);\n        vec2.copy(lineNormal, tmp); // store normal for next round\n\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n        attrDistance.push(d, d, d, d);\n\n        // the miter is now the normal for our next join\n        count += 4;\n      } else {\n        // next two points in our first segment\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n        attrIndex.push(index + 1, index + 2, index + 3);\n\n        // now add the miter triangles\n        addNext(out, miters, lineNormal, miterLen * -flip);\n        attrPos.push(cur[0], cur[1], 0);\n        attrIndex.push(index + 2, index + 4, index + 3);\n        attrIndex.push(index + 4, index + 5, index + 6);\n        computeNormal(tmp, lineB);\n        vec2.copy(lineNormal, tmp); // store normal for next round\n\n        extrusions(attrPos, out, miters, cur, lineNormal, 1);\n        attrDistance.push(d, d, d, d, d);\n\n        // the miter is now the normal for our next join\n        count += 5;\n      }\n    }\n  }\n  const pickData = [];\n  for (let i = 0; i < miters.length; i++) {\n    const totalDistance = attrDistance[attrDistance.length - 1];\n    pickData.push(\n      attrPos[i * 3],\n      attrPos[i * 3 + 1],\n      attrPos[i * 3 + 2],\n      attrDistance[i],\n      miters[i],\n      totalDistance,\n    );\n  }\n  return {\n    normals: out,\n    attrIndex,\n    attrPos: pickData, // [x,y,z, distance, miter ]\n  };\n}\n// [x,y,z, distance, miter ]\n"]},"metadata":{},"sourceType":"module"}