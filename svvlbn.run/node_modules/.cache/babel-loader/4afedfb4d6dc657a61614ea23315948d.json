{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport * as d3 from 'd3-color';\nexport function rgb2arr(str) {\n  var color = d3.color(str);\n  var arr = [0, 0, 0, 0];\n\n  if (color != null) {\n    arr[0] = color.r / 255;\n    arr[1] = color.g / 255;\n    arr[2] = color.b / 255;\n    arr[3] = color.opacity;\n  }\n\n  return arr;\n}\nexport function decodePickingColor(color) {\n  var _color = _slicedToArray(color, 3),\n      i1 = _color[0],\n      i2 = _color[1],\n      i3 = _color[2];\n\n  var index = i1 + i2 * 256 + i3 * 65536 - 1;\n  return index;\n}\nexport function encodePickingColor(featureIdx) {\n  return [featureIdx + 1 & 255, featureIdx + 1 >> 8 & 255, featureIdx + 1 >> 8 >> 8 & 255];\n}\nexport function generateColorRamp(colorRamp) {\n  var canvas = document.createElement('canvas');\n  var ctx = canvas.getContext('2d');\n  canvas.width = 256;\n  canvas.height = 1;\n  var gradient = ctx.createLinearGradient(0, 0, 256, 0);\n  var data = null;\n  var min = colorRamp.positions[0];\n  var max = colorRamp.positions[colorRamp.positions.length - 1];\n\n  for (var i = 0; i < colorRamp.colors.length; ++i) {\n    var value = (colorRamp.positions[i] - min) / (max - min);\n    gradient.addColorStop(value, colorRamp.colors[i]);\n  }\n\n  ctx.fillStyle = gradient;\n  ctx.fillRect(0, 0, 256, 1);\n  data = new Uint8ClampedArray(ctx.getImageData(0, 0, 256, 1).data);\n  return new ImageData(data, 16, 16);\n}","map":{"version":3,"sources":["../src/color.ts"],"names":["color","d3","arr","i1","i2","i3","index","featureIdx","canvas","document","ctx","gradient","data","min","colorRamp","max","i","value"],"mappings":";AAAA,OAAO,KAAP,EAAA,MAAA,UAAA;AAKA,OAAO,SAAA,OAAA,CAAA,GAAA,EAA8B;AACnC,MAAMA,KAAK,GAAGC,EAAE,CAAFA,KAAAA,CAAd,GAAcA,CAAd;AACA,MAAMC,GAAG,GAAG,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAZ,CAAY,CAAZ;;AACA,MAAIF,KAAK,IAAT,IAAA,EAAmB;AACjBE,IAAAA,GAAG,CAAHA,CAAG,CAAHA,GAASF,KAAK,CAALA,CAAAA,GAATE,GAAAA;AACAA,IAAAA,GAAG,CAAHA,CAAG,CAAHA,GAASF,KAAK,CAALA,CAAAA,GAATE,GAAAA;AACAA,IAAAA,GAAG,CAAHA,CAAG,CAAHA,GAASF,KAAK,CAALA,CAAAA,GAATE,GAAAA;AACAA,IAAAA,GAAG,CAAHA,CAAG,CAAHA,GAASF,KAAK,CAAdE,OAAAA;AACD;;AACD,SAAA,GAAA;AACD;AAED,OAAO,SAAA,kBAAA,CAAA,KAAA,EAAuD;AAAA,MAAA,MAAA,GAAA,cAAA,CAAA,KAAA,EAAA,CAAA,CAAA;AAAA,MACrDC,EADqD,GAAA,MAAA,CAAA,CAAA,CAAA;AAAA,MACjDC,EADiD,GAAA,MAAA,CAAA,CAAA,CAAA;AAAA,MAC7CC,EAD6C,GAAA,MAAA,CAAA,CAAA,CAAA;;AAG5D,MAAMC,KAAK,GAAGH,EAAE,GAAGC,EAAE,GAAPD,GAAAA,GAAgBE,EAAE,GAAlBF,KAAAA,GAAd,CAAA;AACA,SAAA,KAAA;AACD;AAED,OAAO,SAAA,kBAAA,CAAA,UAAA,EAEqB;AAC1B,SAAO,CACJI,UAAU,GAAX,CAACA,GADI,GAAA,EAEHA,UAAU,GAAX,CAACA,IAAF,CAAEA,GAFG,GAAA,EAGFA,UAAU,GAAX,CAACA,IAAF,CAAEA,IAAH,CAAGA,GAHL,GAAO,CAAP;AAKD;AAED,OAAO,SAAA,iBAAA,CAAA,SAAA,EAA6D;AAClE,MAAMC,MAAM,GAAGC,QAAQ,CAARA,aAAAA,CAAf,QAAeA,CAAf;AACA,MAAMC,GAAG,GAAGF,MAAM,CAANA,UAAAA,CAAZ,IAAYA,CAAZ;AACAA,EAAAA,MAAM,CAANA,KAAAA,GAAAA,GAAAA;AACAA,EAAAA,MAAM,CAANA,MAAAA,GAAAA,CAAAA;AACA,MAAMG,QAAQ,GAAGD,GAAG,CAAHA,oBAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,GAAAA,EAAjB,CAAiBA,CAAjB;AACA,MAAIE,IAAI,GAAR,IAAA;AACA,MAAMC,GAAG,GAAGC,SAAS,CAATA,SAAAA,CAAZ,CAAYA,CAAZ;AACA,MAAMC,GAAG,GAAGD,SAAS,CAATA,SAAAA,CAAoBA,SAAS,CAATA,SAAAA,CAAAA,MAAAA,GAAhC,CAAYA,CAAZ;;AACA,OAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGF,SAAS,CAATA,MAAAA,CAApB,MAAA,EAA6C,EAA7C,CAAA,EAAkD;AAChD,QAAMG,KAAK,GAAG,CAACH,SAAS,CAATA,SAAAA,CAAAA,CAAAA,IAAD,GAAA,KAAkCC,GAAG,GAAnD,GAAc,CAAd;AACAJ,IAAAA,QAAQ,CAARA,YAAAA,CAAAA,KAAAA,EAA6BG,SAAS,CAATA,MAAAA,CAA7BH,CAA6BG,CAA7BH;AACD;;AACDD,EAAAA,GAAG,CAAHA,SAAAA,GAAAA,QAAAA;AACAA,EAAAA,GAAG,CAAHA,QAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,GAAAA,EAAAA,CAAAA;AACAE,EAAAA,IAAI,GAAG,IAAA,iBAAA,CAAsBF,GAAG,CAAHA,YAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,GAAAA,EAAAA,CAAAA,EAA7BE,IAAO,CAAPA;AAEA,SAAO,IAAA,SAAA,CAAA,IAAA,EAAA,EAAA,EAAP,EAAO,CAAP;AACD","sourcesContent":["import * as d3 from 'd3-color';\nexport interface IColorRamp {\n  positions: number[];\n  colors: string[];\n}\nexport function rgb2arr(str: string) {\n  const color = d3.color(str) as d3.RGBColor;\n  const arr = [0, 0, 0, 0];\n  if (color != null) {\n    arr[0] = color.r / 255;\n    arr[1] = color.g / 255;\n    arr[2] = color.b / 255;\n    arr[3] = color.opacity;\n  }\n  return arr;\n}\n\nexport function decodePickingColor(color: Uint8Array): number {\n  const [i1, i2, i3] = color;\n  // 1 was added to seperate from no selection\n  const index = i1 + i2 * 256 + i3 * 65536 - 1;\n  return index;\n}\n\nexport function encodePickingColor(\n  featureIdx: number,\n): [number, number, number] {\n  return [\n    (featureIdx + 1) & 255,\n    ((featureIdx + 1) >> 8) & 255,\n    (((featureIdx + 1) >> 8) >> 8) & 255,\n  ];\n}\n\nexport function generateColorRamp(colorRamp: IColorRamp): ImageData {\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n  canvas.width = 256;\n  canvas.height = 1;\n  const gradient = ctx.createLinearGradient(0, 0, 256, 0);\n  let data = null;\n  const min = colorRamp.positions[0];\n  const max = colorRamp.positions[colorRamp.positions.length - 1];\n  for (let i = 0; i < colorRamp.colors.length; ++i) {\n    const value = (colorRamp.positions[i] - min) / (max - min);\n    gradient.addColorStop(value, colorRamp.colors[i]);\n  }\n  ctx.fillStyle = gradient;\n  ctx.fillRect(0, 0, 256, 1);\n  data = new Uint8ClampedArray(ctx.getImageData(0, 0, 256, 1).data);\n\n  return new ImageData(data, 16, 16);\n}\n"]},"metadata":{},"sourceType":"module"}