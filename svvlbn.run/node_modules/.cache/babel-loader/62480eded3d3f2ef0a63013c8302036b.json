{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nvar _dec, _class, _temp;\n\nimport { EventEmitter } from 'eventemitter3';\nimport { injectable } from 'inversify';\nimport { buildIconMaping } from '../../utils/font_util';\nvar BUFFER = 3;\nvar MAX_CANVAS_WIDTH = 1024;\nvar imageSize = 64;\nvar IconService = (_dec = injectable(), _dec(_class = (_temp = function (_EventEmitter) {\n  _inherits(IconService, _EventEmitter);\n\n  function IconService() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, IconService);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(IconService)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.canvasHeight = void 0;\n    _this.textrure = void 0;\n    _this.canvas = void 0;\n    _this.iconData = void 0;\n    _this.iconMap = void 0;\n    _this.ctx = void 0;\n    return _this;\n  }\n\n  _createClass(IconService, [{\n    key: \"init\",\n    value: function init() {\n      this.iconData = [];\n      this.iconMap = {};\n      this.canvas = document.createElement('canvas');\n      this.ctx = this.canvas.getContext('2d');\n    }\n  }, {\n    key: \"addImage\",\n    value: function addImage(id, image) {\n      var _this2 = this;\n\n      var imagedata = new Image();\n\n      if (this.hasImage(id)) {\n        throw new Error('Image Id already exists');\n      }\n\n      this.iconData.push({\n        id: id,\n        width: imageSize,\n        height: imageSize\n      });\n      this.updateIconMap();\n      this.loadImage(image).then(function (img) {\n        imagedata = img;\n\n        var iconImage = _this2.iconData.find(function (icon) {\n          return icon.id === id;\n        });\n\n        if (iconImage) {\n          iconImage.image = imagedata;\n        }\n\n        _this2.update();\n      });\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      return this.textrure;\n    }\n  }, {\n    key: \"getIconMap\",\n    value: function getIconMap() {\n      return this.iconMap;\n    }\n  }, {\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      return this.canvas;\n    }\n  }, {\n    key: \"hasImage\",\n    value: function hasImage(id) {\n      return this.iconMap.hasOwnProperty(id);\n    }\n  }, {\n    key: \"removeImage\",\n    value: function removeImage(id) {\n      if (this.hasImage(id)) {\n        this.iconData = this.iconData.filter(function (icon) {\n          return icon.id !== id;\n        });\n        delete this.iconMap[id];\n        this.update();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.iconData = [];\n      this.iconMap = {};\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.updateIconMap();\n      this.updateIconAtlas();\n      this.emit('imageUpdate');\n    }\n  }, {\n    key: \"updateIconAtlas\",\n    value: function updateIconAtlas() {\n      var _this3 = this;\n\n      this.canvas.width = MAX_CANVAS_WIDTH;\n      this.canvas.height = this.canvasHeight;\n      Object.keys(this.iconMap).forEach(function (item) {\n        var _this3$iconMap$item = _this3.iconMap[item],\n            x = _this3$iconMap$item.x,\n            y = _this3$iconMap$item.y,\n            image = _this3$iconMap$item.image;\n\n        if (image) {\n          _this3.ctx.drawImage(image, x, y, imageSize, imageSize);\n        }\n      });\n    }\n  }, {\n    key: \"updateIconMap\",\n    value: function updateIconMap() {\n      var _buildIconMaping = buildIconMaping(this.iconData, BUFFER, MAX_CANVAS_WIDTH),\n          mapping = _buildIconMaping.mapping,\n          canvasHeight = _buildIconMaping.canvasHeight;\n\n      this.iconMap = mapping;\n      this.canvasHeight = canvasHeight;\n    }\n  }, {\n    key: \"loadImage\",\n    value: function loadImage(url) {\n      return new Promise(function (resolve, reject) {\n        if (url instanceof HTMLImageElement) {\n          resolve(url);\n          return;\n        }\n\n        var image = new Image();\n        image.crossOrigin = 'anonymous';\n\n        image.onload = function () {\n          resolve(image);\n        };\n\n        image.onerror = function () {\n          reject(new Error('Could not load image at ' + url));\n        };\n\n        image.src = url instanceof File ? URL.createObjectURL(url) : url;\n      });\n    }\n  }]);\n\n  return IconService;\n}(EventEmitter), _temp)) || _class);\nexport { IconService as default };","map":{"version":3,"sources":["../../../src/services/asset/IconService.ts"],"names":["BUFFER","MAX_CANVAS_WIDTH","imageSize","injectable","IconService","EventEmitter","canvasHeight","textrure","canvas","iconData","iconMap","ctx","document","id","image","imagedata","width","height","iconImage","icon","Object","x","y","mapping","buildIconMaping","url","resolve","reject","URL"],"mappings":"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","sourcesContent":["import { EventEmitter } from 'eventemitter3';\nimport { inject, injectable } from 'inversify';\nimport { TYPES } from '../../types';\nimport { buildIconMaping } from '../../utils/font_util';\nimport { ITexture2D } from '../renderer/ITexture2D';\nimport {\n  IIcon,\n  IICONMap,\n  IIconService,\n  IIconValue,\n  IImage,\n} from './IIconService';\nconst BUFFER = 3;\nconst MAX_CANVAS_WIDTH = 1024;\nconst imageSize = 64;\n@injectable()\nexport default class IconService extends EventEmitter implements IIconService {\n  public canvasHeight: number;\n  private textrure: ITexture2D;\n  private canvas: HTMLCanvasElement;\n  private iconData: IIcon[];\n  private iconMap: IICONMap;\n  private ctx: CanvasRenderingContext2D;\n  public init() {\n    this.iconData = [];\n    this.iconMap = {};\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;\n  }\n\n  public addImage(id: string, image: IImage) {\n    let imagedata = new Image();\n    if (this.hasImage(id)) {\n      throw new Error('Image Id already exists');\n    }\n    this.iconData.push({\n      id,\n      width: imageSize,\n      height: imageSize,\n    });\n    this.updateIconMap();\n    this.loadImage(image).then((img) => {\n      imagedata = img as HTMLImageElement;\n      const iconImage = this.iconData.find((icon: IIcon) => {\n        return icon.id === id;\n      });\n      if (iconImage) {\n        iconImage.image = imagedata;\n      }\n      // this.iconData.push({\n      //   id,\n      //   image: imagedata,\n      //   width: imageSize,\n      //   height: imageSize,\n      // });\n      this.update();\n    });\n  }\n\n  public getTexture(): ITexture2D {\n    return this.textrure;\n  }\n\n  public getIconMap() {\n    return this.iconMap;\n  }\n\n  public getCanvas() {\n    return this.canvas;\n  }\n\n  public hasImage(id: string): boolean {\n    return this.iconMap.hasOwnProperty(id);\n  }\n\n  public removeImage(id: string): void {\n    if (this.hasImage(id)) {\n      this.iconData = this.iconData.filter((icon) => {\n        return icon.id !== id;\n      });\n      delete this.iconMap[id];\n      this.update();\n    }\n  }\n  public destroy(): void {\n    this.iconData = [];\n    this.iconMap = {};\n  }\n  private update() {\n    this.updateIconMap();\n    this.updateIconAtlas();\n    this.emit('imageUpdate');\n  }\n\n  private updateIconAtlas() {\n    this.canvas.width = MAX_CANVAS_WIDTH;\n    this.canvas.height = this.canvasHeight;\n    Object.keys(this.iconMap).forEach((item: string) => {\n      const { x, y, image } = this.iconMap[item];\n      if (image) {\n        this.ctx.drawImage(image, x, y, imageSize, imageSize);\n      }\n    });\n  }\n\n  private updateIconMap() {\n    const { mapping, canvasHeight } = buildIconMaping(\n      this.iconData,\n      BUFFER,\n      MAX_CANVAS_WIDTH,\n    );\n    this.iconMap = mapping;\n    this.canvasHeight = canvasHeight;\n  }\n\n  private loadImage(url: IImage) {\n    return new Promise((resolve, reject) => {\n      if (url instanceof HTMLImageElement) {\n        resolve(url);\n        return;\n      }\n      const image = new Image();\n      image.crossOrigin = 'anonymous';\n      image.onload = () => {\n        resolve(image);\n      };\n      image.onerror = () => {\n        reject(new Error('Could not load image at ' + url));\n      };\n      image.src = url instanceof File ? URL.createObjectURL(url) : url;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}