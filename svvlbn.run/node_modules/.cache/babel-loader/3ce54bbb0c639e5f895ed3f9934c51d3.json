{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\nimport _upperFirst from \"lodash/upperFirst\";\nimport _isNil from \"lodash/isNil\";\nimport _camelCase from \"lodash/camelCase\";\n\nvar _dec, _dec2, _class, _class2, _descriptor, _temp;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { inject, injectable } from 'inversify';\nimport { gl } from '../../../index';\nvar quad = \"attribute vec2 a_Position;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  v_UV = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n}\";\nimport { TYPES } from '../../../types';\nimport { PassType } from '../IMultiPassRenderer';\nvar BasePostProcessingPass = (_dec = injectable(), _dec2 = inject(TYPES.IShaderModuleService), _dec(_class = (_class2 = (_temp = function () {\n  function BasePostProcessingPass() {\n    _classCallCheck(this, BasePostProcessingPass);\n\n    _initializerDefineProperty(this, \"shaderModuleService\", _descriptor, this);\n\n    this.rendererService = void 0;\n    this.config = void 0;\n    this.quad = quad;\n    this.enabled = true;\n    this.renderToScreen = false;\n    this.model = void 0;\n    this.name = void 0;\n    this.optionsToUpdate = {};\n  }\n\n  _createClass(BasePostProcessingPass, [{\n    key: \"getName\",\n    value: function getName() {\n      return this.name;\n    }\n  }, {\n    key: \"setName\",\n    value: function setName(name) {\n      this.name = name;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return PassType.PostProcessing;\n    }\n  }, {\n    key: \"init\",\n    value: function init(layer, config) {\n      this.config = config;\n      this.rendererService = layer.getContainer().get(TYPES.IRendererService);\n      var _this$rendererService = this.rendererService,\n          createAttribute = _this$rendererService.createAttribute,\n          createBuffer = _this$rendererService.createBuffer,\n          createModel = _this$rendererService.createModel;\n\n      var _this$setupShaders = this.setupShaders(),\n          vs = _this$setupShaders.vs,\n          fs = _this$setupShaders.fs,\n          uniforms = _this$setupShaders.uniforms;\n\n      this.model = createModel({\n        vs: vs,\n        fs: fs,\n        attributes: {\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: [-4, -4, 4, -4, 0, 4],\n              type: gl.FLOAT\n            }),\n            size: 2\n          })\n        },\n        uniforms: _objectSpread({\n          u_Texture: null\n        }, uniforms, {}, this.config && this.convertOptionsToUniforms(this.config)),\n        depth: {\n          enable: false\n        },\n        count: 3,\n        blend: {\n          enable: this.getName() === 'copy'\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(layer) {\n      var _this = this;\n\n      var postProcessor = layer.multiPassRenderer.getPostProcessor();\n      var _this$rendererService2 = this.rendererService,\n          useFramebuffer = _this$rendererService2.useFramebuffer,\n          getViewportSize = _this$rendererService2.getViewportSize,\n          clear = _this$rendererService2.clear;\n\n      var _getViewportSize = getViewportSize(),\n          width = _getViewportSize.width,\n          height = _getViewportSize.height;\n\n      useFramebuffer(this.renderToScreen ? null : postProcessor.getWriteFBO(), function () {\n        clear({\n          framebuffer: postProcessor.getWriteFBO(),\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0\n        });\n\n        _this.model.draw({\n          uniforms: _objectSpread({\n            u_Texture: postProcessor.getReadFBO(),\n            u_ViewportSize: [width, height]\n          }, _this.convertOptionsToUniforms(_this.optionsToUpdate))\n        });\n      });\n    }\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.enabled;\n    }\n  }, {\n    key: \"setEnabled\",\n    value: function setEnabled(enabled) {\n      this.enabled = enabled;\n    }\n  }, {\n    key: \"setRenderToScreen\",\n    value: function setRenderToScreen(renderToScreen) {\n      this.renderToScreen = renderToScreen;\n    }\n  }, {\n    key: \"updateOptions\",\n    value: function updateOptions(config) {\n      this.optionsToUpdate = _objectSpread({}, this.optionsToUpdate, {}, config);\n    }\n  }, {\n    key: \"setupShaders\",\n    value: function setupShaders() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"convertOptionsToUniforms\",\n    value: function convertOptionsToUniforms(options) {\n      var uniforms = {};\n      Object.keys(options).forEach(function (optionName) {\n        if (!_isNil(options[optionName])) {\n          uniforms[\"u_\".concat(_upperFirst(_camelCase(optionName)))] = options[optionName];\n        }\n      });\n      return uniforms;\n    }\n  }]);\n\n  return BasePostProcessingPass;\n}(), _temp), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"shaderModuleService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);\nexport { BasePostProcessingPass as default };","map":{"version":3,"sources":["../../../../src/services/renderer/passes/BasePostProcessingPass.ts"],"names":["injectable","BasePostProcessingPass","inject","TYPES","rendererService","config","quad","enabled","renderToScreen","model","name","optionsToUpdate","PassType","layer","createAttribute","createBuffer","createModel","vs","fs","uniforms","attributes","a_Position","buffer","data","type","gl","FLOAT","size","u_Texture","depth","enable","count","blend","postProcessor","useFramebuffer","getViewportSize","clear","width","height","framebuffer","color","stencil","u_ViewportSize","options","Object"],"mappings":"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","sourcesContent":["import { inject, injectable } from 'inversify';\nimport { camelCase, isNil, upperFirst } from 'lodash';\nimport {\n  gl,\n  IModel,\n  IRendererService,\n  IShaderModuleService,\n} from '../../../index';\nimport quad from '../../../shaders/post-processing/quad.glsl';\nimport { TYPES } from '../../../types';\nimport { ILayer } from '../../layer/ILayerService';\nimport { IPostProcessingPass, PassType } from '../IMultiPassRenderer';\nimport { IUniform } from '../IUniform';\n\n/**\n * 后处理 Pass 基类，通过 PostProcessor 驱动。\n *\n * 约定使用 u_Texture 传递渲染纹理。\n */\n@injectable()\nexport default class BasePostProcessingPass<InitializationOptions = {}>\n  implements IPostProcessingPass<InitializationOptions> {\n  @inject(TYPES.IShaderModuleService)\n  protected readonly shaderModuleService: IShaderModuleService;\n\n  protected rendererService: IRendererService;\n\n  protected config: Partial<InitializationOptions> | undefined;\n\n  protected quad: string = quad;\n\n  /**\n   * 启用开关\n   */\n  private enabled: boolean = true;\n\n  /**\n   * 是否渲染到屏幕\n   */\n  private renderToScreen: boolean = false;\n\n  /**\n   * 渲染命令\n   */\n  private model: IModel;\n\n  /**\n   * 效果名，便于在图层中引用\n   */\n  private name: string;\n\n  private optionsToUpdate: Partial<InitializationOptions> = {};\n\n  public getName() {\n    return this.name;\n  }\n\n  public setName(name: string) {\n    this.name = name;\n  }\n\n  public getType() {\n    return PassType.PostProcessing;\n  }\n\n  public init(layer: ILayer, config?: Partial<InitializationOptions>) {\n    this.config = config;\n    this.rendererService = layer\n      .getContainer()\n      .get<IRendererService>(TYPES.IRendererService);\n\n    const { createAttribute, createBuffer, createModel } = this.rendererService;\n    const { vs, fs, uniforms } = this.setupShaders();\n\n    this.model = createModel({\n      vs,\n      fs,\n      attributes: {\n        // 使用一个全屏三角形，相比 Quad 顶点数目更少\n        a_Position: createAttribute({\n          buffer: createBuffer({\n            data: [-4, -4, 4, -4, 0, 4],\n            type: gl.FLOAT,\n          }),\n          size: 2,\n        }),\n      },\n      // @ts-ignore\n      uniforms: {\n        u_Texture: null,\n        ...uniforms,\n        ...(this.config && this.convertOptionsToUniforms(this.config)),\n      },\n      depth: {\n        enable: false,\n      },\n      count: 3,\n      blend: {\n        // copy pass 需要混合\n        enable: this.getName() === 'copy',\n      },\n    });\n  }\n\n  public render(layer: ILayer) {\n    const postProcessor = layer.multiPassRenderer.getPostProcessor();\n    const { useFramebuffer, getViewportSize, clear } = this.rendererService;\n    const { width, height } = getViewportSize();\n    useFramebuffer(\n      this.renderToScreen ? null : postProcessor.getWriteFBO(),\n      () => {\n        clear({\n          framebuffer: postProcessor.getWriteFBO(),\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n        });\n        this.model.draw({\n          uniforms: {\n            u_Texture: postProcessor.getReadFBO(),\n            u_ViewportSize: [width, height],\n            ...this.convertOptionsToUniforms(this.optionsToUpdate),\n          },\n        });\n      },\n    );\n  }\n\n  public isEnabled() {\n    return this.enabled;\n  }\n\n  public setEnabled(enabled: boolean) {\n    this.enabled = enabled;\n  }\n\n  public setRenderToScreen(renderToScreen: boolean) {\n    this.renderToScreen = renderToScreen;\n  }\n\n  public updateOptions(config: Partial<InitializationOptions>) {\n    this.optionsToUpdate = {\n      ...this.optionsToUpdate,\n      ...config,\n    };\n  }\n\n  protected setupShaders(): {\n    vs: string;\n    fs: string;\n    uniforms?: { [key: string]: IUniform };\n  } {\n    throw new Error('Method not implemented.');\n  }\n\n  protected convertOptionsToUniforms(\n    options: Partial<InitializationOptions>,\n  ): {\n    [uniformName: string]: IUniform;\n  } | void {\n    const uniforms: {\n      [key: string]: IUniform;\n    } = {};\n\n    Object.keys(options).forEach((optionName) => {\n      // @ts-ignore\n      if (!isNil(options[optionName])) {\n        uniforms[`u_${upperFirst(camelCase(optionName))}`] =\n          // @ts-ignore\n          options[optionName];\n      }\n    });\n\n    return uniforms;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}