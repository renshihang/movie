{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _isNil from \"lodash/isNil\";\n\nvar _dec, _class;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { injectable } from 'inversify';\nvar blur = \"varying vec2 v_UV;\\n\\nuniform sampler2D u_Texture;\\n\\nuniform vec2 u_ViewportSize: [1.0, 1.0];\\nuniform vec2 u_BlurDir: [1.0, 0.0];\\n\\n// https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl\\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\\n  vec4 color = vec4(0.0);\\n  vec2 off1 = vec2(1.3846153846) * direction;\\n  vec2 off2 = vec2(3.2307692308) * direction;\\n  color += texture2D(image, uv) * 0.2270270270;\\n  color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\\n  color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\\n  color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\\n  color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\\n  return color;\\n}\\n\\nvoid main() {\\n  gl_FragColor = blur9(u_Texture, v_UV, u_ViewportSize, u_BlurDir);\\n}\";\nvar quad = \"attribute vec2 a_Position;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  v_UV = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n}\";\nimport BasePostProcessingPass from '../BasePostProcessingPass';\nvar BlurHPass = (_dec = injectable(), _dec(_class = function (_BasePostProcessingPa) {\n  _inherits(BlurHPass, _BasePostProcessingPa);\n\n  function BlurHPass() {\n    _classCallCheck(this, BlurHPass);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BlurHPass).apply(this, arguments));\n  }\n\n  _createClass(BlurHPass, [{\n    key: \"setupShaders\",\n    value: function setupShaders() {\n      this.shaderModuleService.registerModule('blur-pass', {\n        vs: quad,\n        fs: blur\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule('blur-pass'),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          uniforms = _this$shaderModuleSer.uniforms;\n\n      var _this$rendererService = this.rendererService.getViewportSize(),\n          width = _this$rendererService.width,\n          height = _this$rendererService.height;\n\n      return {\n        vs: vs,\n        fs: fs,\n        uniforms: _objectSpread({}, uniforms, {\n          u_ViewportSize: [width, height]\n        })\n      };\n    }\n  }, {\n    key: \"convertOptionsToUniforms\",\n    value: function convertOptionsToUniforms(options) {\n      var uniforms = {};\n\n      if (!_isNil(options.blurRadius)) {\n        uniforms.u_BlurDir = [options.blurRadius, 0];\n      }\n\n      return uniforms;\n    }\n  }]);\n\n  return BlurHPass;\n}(BasePostProcessingPass)) || _class);\nexport { BlurHPass as default };","map":{"version":3,"sources":["../../../../../src/services/renderer/passes/post-processing/BlurHPass.ts"],"names":["injectable","BlurHPass","BasePostProcessingPass","vs","fs","blur","uniforms","width","height","u_ViewportSize","options"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,UAAA,QAAA,WAAA;;;AAKA,OAAA,sBAAA,MAAA,2BAAA;IAOqBC,S,WADpBD,UAAU,E;;;;;;;;;;;mCAIgB;AACvB,WAAA,mBAAA,CAAA,cAAA,CAAA,WAAA,EAAqD;AACnDG,QAAAA,EAAE,EADiD,IAAA;AAEnDC,QAAAA,EAAE,EAAEC;AAF+C,OAArD;;AADuB,UAAA,qBAAA,GAMM,KAAA,mBAAA,CAAA,SAAA,CANN,WAMM,CANN;AAAA,UAMfF,EANe,GAAA,qBAAA,CAAA,EAAA;AAAA,UAMXC,EANW,GAAA,qBAAA,CAAA,EAAA;AAAA,UAMPE,QANO,GAAA,qBAAA,CAAA,QAAA;;AAAA,UAAA,qBAAA,GASG,KAAA,eAAA,CATH,eASG,EATH;AAAA,UASfC,KATe,GAAA,qBAAA,CAAA,KAAA;AAAA,UASRC,MATQ,GAAA,qBAAA,CAAA,MAAA;;AAWvB,aAAO;AACLL,QAAAA,EAAE,EADG,EAAA;AAELC,QAAAA,EAAE,EAFG,EAAA;AAGLE,QAAAA,QAAQ,EAAA,aAAA,CAAA,EAAA,EAAA,QAAA,EAAA;AAENG,UAAAA,cAAc,EAAE,CAAA,KAAA,EAAA,MAAA;AAFV,SAAA;AAHH,OAAP;AAQD;;;6CAGCC,O,EAGO;AACP,UAAMJ,QAEL,GAFD,EAAA;;AAIA,UAAI,CAAC,MAAA,CAAMI,OAAO,CAAlB,UAAK,CAAL,EAAgC;AAC9BJ,QAAAA,QAAQ,CAARA,SAAAA,GAAqB,CAACI,OAAO,CAAR,UAAA,EAArBJ,CAAqB,CAArBA;AACD;;AAED,aAAA,QAAA;AACD;;;;EAtCoCJ,sB;SAAlBD,S","sourcesContent":["import { injectable } from 'inversify';\nimport { isNil } from 'lodash';\nimport blur from '../../../../shaders/post-processing/blur.glsl';\nimport quad from '../../../../shaders/post-processing/quad.glsl';\nimport { IUniform } from '../../IUniform';\nimport BasePostProcessingPass from '../BasePostProcessingPass';\n\nexport interface IBlurHPassConfig {\n  blurRadius: number;\n}\n\n@injectable()\nexport default class BlurHPass extends BasePostProcessingPass<\n  IBlurHPassConfig\n> {\n  protected setupShaders() {\n    this.shaderModuleService.registerModule('blur-pass', {\n      vs: quad,\n      fs: blur,\n    });\n\n    const { vs, fs, uniforms } = this.shaderModuleService.getModule(\n      'blur-pass',\n    );\n    const { width, height } = this.rendererService.getViewportSize();\n\n    return {\n      vs,\n      fs,\n      uniforms: {\n        ...uniforms,\n        u_ViewportSize: [width, height],\n      },\n    };\n  }\n\n  protected convertOptionsToUniforms(\n    options: Partial<IBlurHPassConfig>,\n  ): {\n    [uniformName: string]: IUniform;\n  } | void {\n    const uniforms: {\n      [key: string]: IUniform;\n    } = {};\n\n    if (!isNil(options.blurRadius)) {\n      uniforms.u_BlurDir = [options.blurRadius, 0];\n    }\n\n    return uniforms;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}