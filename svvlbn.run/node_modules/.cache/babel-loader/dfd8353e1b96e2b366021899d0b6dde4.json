{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport Supercluster from 'supercluster';\nexport function cluster(data, option) {\n  var _option$radius = option.radius,\n      radius = _option$radius === void 0 ? 80 : _option$radius,\n      _option$maxZoom = option.maxZoom,\n      maxZoom = _option$maxZoom === void 0 ? 18 : _option$maxZoom,\n      _option$minZoom = option.minZoom,\n      minZoom = _option$minZoom === void 0 ? 0 : _option$minZoom,\n      field = option.field,\n      _option$zoom = option.zoom,\n      zoom = _option$zoom === void 0 ? 2 : _option$zoom;\n\n  if (data.pointIndex) {\n    var clusterData = data.pointIndex.getClusters(data.extent, zoom);\n    data.dataArray = formatData(clusterData);\n    return data;\n  }\n\n  var pointIndex = new Supercluster({\n    radius: radius,\n    minZoom: minZoom,\n    maxZoom: maxZoom,\n    map: function map(props) {\n      return {\n        sum: props[field]\n      };\n    },\n    reduce: function reduce(accumulated, props) {\n      accumulated.sum += props.sum;\n    }\n  });\n  var geojson = {\n    type: 'FeatureCollection',\n    features: []\n  };\n  geojson.features = data.dataArray.map(function (item) {\n    return {\n      type: 'Feature',\n      properties: _defineProperty({}, field, item[field]),\n      geometry: {\n        type: 'Point',\n        coordinates: item.coordinates\n      }\n    };\n  });\n  pointIndex.load(geojson.features);\n  var clusterPoint = pointIndex.getClusters(data.extent, zoom);\n  var resultData = clusterPoint.map(function (point, index) {\n    return _objectSpread({\n      coordinates: point.geometry.coordinates,\n      _id: index + 1\n    }, point.properties);\n  });\n  data.dataArray = resultData;\n  data.pointIndex = pointIndex;\n  return data;\n}\nexport function formatData(clusterPoint) {\n  return clusterPoint.map(function (point, index) {\n    return _objectSpread({\n      coordinates: point.geometry.coordinates,\n      _id: index + 1\n    }, point.properties);\n  });\n}","map":{"version":3,"sources":["../../src/transform/cluster.ts"],"names":["radius","maxZoom","minZoom","field","zoom","option","data","clusterData","formatData","pointIndex","map","sum","props","reduce","accumulated","geojson","type","features","properties","item","geometry","coordinates","clusterPoint","resultData","point","_id","index"],"mappings":"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","sourcesContent":["import { IParserCfg, IParserData, ISourceCFG, ITransform } from '@antv/l7-core';\nimport Supercluster from 'supercluster';\nexport function cluster(data: IParserData, option: ITransform): IParserData {\n  const { radius = 80, maxZoom = 18, minZoom = 0, field, zoom = 2 } = option;\n  if (data.pointIndex) {\n    const clusterData = data.pointIndex.getClusters(data.extent, zoom);\n    data.dataArray = formatData(clusterData);\n    return data;\n  }\n  const pointIndex = new Supercluster({\n    radius,\n    minZoom,\n    maxZoom,\n    map: (props) => ({ sum: props[field] }), // 根据指定字段求和\n    reduce: (accumulated, props) => {\n      accumulated.sum += props.sum;\n    },\n  });\n  const geojson: {\n    type: string;\n    features: any[];\n  } = {\n    type: 'FeatureCollection',\n    features: [],\n  };\n  geojson.features = data.dataArray.map((item) => {\n    return {\n      type: 'Feature',\n      properties: {\n        [field]: item[field],\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: item.coordinates,\n      },\n    };\n  });\n  pointIndex.load(geojson.features);\n  const clusterPoint = pointIndex.getClusters(data.extent, zoom);\n  const resultData = clusterPoint.map((point, index) => {\n    return {\n      coordinates: point.geometry.coordinates,\n      _id: index + 1,\n      ...point.properties,\n    };\n  });\n  data.dataArray = resultData;\n  data.pointIndex = pointIndex;\n  return data;\n}\nexport function formatData(clusterPoint: any[]) {\n  return clusterPoint.map((point, index) => {\n    return {\n      coordinates: point.geometry.coordinates,\n      _id: index + 1,\n      ...point.properties,\n    };\n  });\n}\n"]},"metadata":{},"sourceType":"module"}