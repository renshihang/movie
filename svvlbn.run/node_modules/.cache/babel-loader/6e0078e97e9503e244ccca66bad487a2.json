{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _isString from \"lodash/isString\";\nimport _isFunction from \"lodash/isFunction\";\nimport _cloneDeep from \"lodash/cloneDeep\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { extent } from '@antv/l7-utils';\nimport { EventEmitter } from 'eventemitter3';\nimport Supercluster from 'supercluster';\nimport { SyncHook } from 'tapable';\nimport { getParser, getTransform } from './';\nimport { statMap } from './utils/statistics';\nimport { getColumn } from './utils/util';\n\nvar Source = function (_EventEmitter) {\n  _inherits(Source, _EventEmitter);\n\n  function Source(data, cfg) {\n    var _this;\n\n    _classCallCheck(this, Source);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Source).call(this));\n    _this.data = void 0;\n    _this.extent = void 0;\n    _this.hooks = {\n      init: new SyncHook(['source']),\n      layout: new SyncHook(['source']),\n      update: new SyncHook(['source'])\n    };\n    _this.parser = {\n      type: 'geojson'\n    };\n    _this.transforms = [];\n    _this.cluster = false;\n    _this.clusterOptions = {\n      enable: false,\n      radius: 40,\n      maxZoom: 20,\n      zoom: -99,\n      method: 'count'\n    };\n    _this.originData = void 0;\n    _this.rawData = void 0;\n    _this.clusterIndex = void 0;\n    _this.rawData = _cloneDeep(data);\n    _this.originData = data;\n\n    if (cfg) {\n      if (cfg.parser) {\n        _this.parser = cfg.parser;\n      }\n\n      if (cfg.transforms) {\n        _this.transforms = cfg.transforms;\n      }\n\n      _this.cluster = cfg.cluster || false;\n\n      if (cfg.clusterOptions) {\n        _this.cluster = true;\n        _this.clusterOptions = _objectSpread({}, _this.clusterOptions, {}, cfg.clusterOptions);\n      }\n    }\n\n    _this.hooks.init.tap('parser', function () {\n      _this.excuteParser();\n    });\n\n    _this.hooks.init.tap('cluster', function () {\n      _this.initCluster();\n    });\n\n    _this.hooks.init.tap('transform', function () {\n      _this.executeTrans();\n    });\n\n    _this.init();\n\n    return _this;\n  }\n\n  _createClass(Source, [{\n    key: \"setData\",\n    value: function setData(data) {\n      this.rawData = data;\n      this.originData = _cloneDeep(data);\n      this.init();\n      this.emit('update');\n    }\n  }, {\n    key: \"getClusters\",\n    value: function getClusters(zoom) {\n      return this.clusterIndex.getClusters(this.extent, zoom);\n    }\n  }, {\n    key: \"getClustersLeaves\",\n    value: function getClustersLeaves(id) {\n      return this.clusterIndex.getLeaves(id, Infinity);\n    }\n  }, {\n    key: \"updateClusterData\",\n    value: function updateClusterData(zoom) {\n      var _this2 = this;\n\n      var _this$clusterOptions = this.clusterOptions,\n          _this$clusterOptions$ = _this$clusterOptions.method,\n          method = _this$clusterOptions$ === void 0 ? 'sum' : _this$clusterOptions$,\n          field = _this$clusterOptions.field;\n      var data = this.clusterIndex.getClusters(this.extent, zoom);\n      this.clusterOptions.zoom = zoom;\n      data.forEach(function (p) {\n        if (!p.id) {\n          p.properties.point_count = 1;\n        }\n      });\n\n      if (field || _isFunction(method)) {\n        data = data.map(function (item) {\n          var id = item.id;\n\n          if (id) {\n            var points = _this2.clusterIndex.getLeaves(id, Infinity);\n\n            var properties = points.map(function (d) {\n              return d.properties;\n            });\n            var statNum;\n\n            if (_isString(method) && field) {\n              var column = getColumn(properties, field);\n              statNum = statMap[method](column);\n            }\n\n            if (_isFunction(method)) {\n              statNum = method(properties);\n            }\n\n            item.properties.stat = statNum;\n          } else {\n            item.properties.point_count = 1;\n          }\n\n          return item;\n        });\n      }\n\n      this.data = getParser('geojson')({\n        type: 'FeatureCollection',\n        features: data\n      });\n      this.executeTrans();\n    }\n  }, {\n    key: \"getFeatureById\",\n    value: function getFeatureById(id) {\n      var _this$parser$type = this.parser.type,\n          type = _this$parser$type === void 0 ? 'geojson' : _this$parser$type;\n\n      if (type === 'geojson' && !this.cluster) {\n        return id < this.rawData.features.length ? this.rawData.features[id] : 'null';\n      } else {\n        return id < this.data.dataArray.length ? this.data.dataArray[id] : 'null';\n      }\n    }\n  }, {\n    key: \"getFeatureId\",\n    value: function getFeatureId(field, value) {\n      var feature = this.data.dataArray.find(function (dataItem) {\n        return dataItem[field] === name;\n      });\n      return feature === null || feature === void 0 ? void 0 : feature._id;\n    }\n  }, {\n    key: \"excuteParser\",\n    value: function excuteParser() {\n      var parser = this.parser;\n      var type = parser.type || 'geojson';\n      var sourceParser = getParser(type);\n      this.data = sourceParser(this.originData, parser);\n      this.extent = extent(this.data.dataArray);\n    }\n  }, {\n    key: \"executeTrans\",\n    value: function executeTrans() {\n      var _this3 = this;\n\n      var trans = this.transforms;\n      trans.forEach(function (tran) {\n        var type = tran.type;\n        var data = getTransform(type)(_this3.data, tran);\n        Object.assign(_this3.data, data);\n      });\n    }\n  }, {\n    key: \"initCluster\",\n    value: function initCluster() {\n      if (!this.cluster) {\n        return;\n      }\n\n      var _this$clusterOptions2 = this.clusterOptions,\n          radius = _this$clusterOptions2.radius,\n          _this$clusterOptions3 = _this$clusterOptions2.minZoom,\n          minZoom = _this$clusterOptions3 === void 0 ? 0 : _this$clusterOptions3,\n          maxZoom = _this$clusterOptions2.maxZoom;\n      this.clusterIndex = new Supercluster({\n        radius: radius,\n        minZoom: minZoom,\n        maxZoom: maxZoom\n      });\n      this.clusterIndex.load(this.rawData.features);\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.hooks.init.call(this);\n    }\n  }]);\n\n  return Source;\n}(EventEmitter);\n\nexport { Source as default };","map":{"version":3,"sources":["../src/source.ts"],"names":["Source","EventEmitter","data","extent","hooks","init","layout","update","parser","type","transforms","cluster","clusterOptions","enable","radius","maxZoom","zoom","method","originData","rawData","clusterIndex","cfg","id","field","p","item","points","properties","d","column","getColumn","statNum","statMap","features","value","feature","dataItem","sourceParser","getParser","trans","tran","getTransform","Object","minZoom"],"mappings":"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","sourcesContent":["import {\n  IClusterOptions,\n  IMapService,\n  IParseDataItem,\n  IParserCfg,\n  IParserData,\n  ISourceCFG,\n  ITransform,\n  lazyInject,\n  TYPES,\n} from '@antv/l7-core';\nimport { extent } from '@antv/l7-utils';\nimport {\n  BBox,\n  Feature,\n  FeatureCollection,\n  Geometries,\n  Properties,\n} from '@turf/helpers';\nimport { EventEmitter } from 'eventemitter3';\nimport { Container } from 'inversify';\nimport { cloneDeep, isFunction, isString } from 'lodash';\nimport Supercluster from 'supercluster';\nimport { SyncHook } from 'tapable';\nimport { getParser, getTransform } from './';\nimport { statMap } from './utils/statistics';\nimport { getColumn } from './utils/util';\nexport default class Source extends EventEmitter {\n  public data: IParserData;\n\n  // 数据范围\n  public extent: BBox;\n  // 生命周期钩子\n  public hooks = {\n    init: new SyncHook(['source']),\n    layout: new SyncHook(['source']),\n    update: new SyncHook(['source']),\n  };\n  public parser: IParserCfg = { type: 'geojson' };\n  public transforms: ITransform[] = [];\n  public cluster: boolean = false;\n  public clusterOptions: Partial<IClusterOptions> = {\n    enable: false,\n    radius: 40,\n    maxZoom: 20,\n    zoom: -99,\n    method: 'count',\n  };\n\n  // 原始数据\n  private originData: any;\n  private rawData: any;\n\n  private clusterIndex: Supercluster;\n\n  constructor(data: any, cfg?: ISourceCFG) {\n    super();\n    this.rawData = cloneDeep(data);\n    this.originData = data;\n    if (cfg) {\n      if (cfg.parser) {\n        this.parser = cfg.parser;\n      }\n      if (cfg.transforms) {\n        this.transforms = cfg.transforms;\n      }\n      this.cluster = cfg.cluster || false;\n      if (cfg.clusterOptions) {\n        this.cluster = true;\n        this.clusterOptions = {\n          ...this.clusterOptions,\n          ...cfg.clusterOptions,\n        };\n      }\n    }\n\n    this.hooks.init.tap('parser', () => {\n      this.excuteParser();\n    });\n    this.hooks.init.tap('cluster', () => {\n      this.initCluster();\n    });\n    this.hooks.init.tap('transform', () => {\n      this.executeTrans();\n    });\n    this.init();\n  }\n\n  public setData(data: any) {\n    this.rawData = data;\n    this.originData = cloneDeep(data);\n    this.init();\n    this.emit('update');\n  }\n  public getClusters(zoom: number): any {\n    return this.clusterIndex.getClusters(this.extent, zoom);\n  }\n  public getClustersLeaves(id: number): any {\n    return this.clusterIndex.getLeaves(id, Infinity);\n  }\n  public updateClusterData(zoom: number): void {\n    const { method = 'sum', field } = this.clusterOptions;\n    let data = this.clusterIndex.getClusters(this.extent, zoom);\n    this.clusterOptions.zoom = zoom;\n    data.forEach((p) => {\n      if (!p.id) {\n        p.properties.point_count = 1;\n      }\n    });\n    if (field || isFunction(method)) {\n      data = data.map((item) => {\n        const id = item.id as number;\n        if (id) {\n          const points = this.clusterIndex.getLeaves(id, Infinity);\n          const properties = points.map((d) => d.properties);\n          let statNum;\n          if (isString(method) && field) {\n            const column = getColumn(properties, field);\n            statNum = statMap[method](column);\n          }\n          if (isFunction(method)) {\n            statNum = method(properties);\n          }\n          item.properties.stat = statNum;\n        } else {\n          item.properties.point_count = 1;\n        }\n        return item;\n      });\n    }\n    this.data = getParser('geojson')({\n      type: 'FeatureCollection',\n      features: data,\n    });\n    this.executeTrans();\n  }\n  public getFeatureById(id: number): unknown {\n    const { type = 'geojson' } = this.parser;\n    if (type === 'geojson' && !this.cluster) {\n      //  TODO： 聚合图层返回聚合和后的数据\n      return id < this.rawData.features.length\n        ? this.rawData.features[id]\n        : 'null';\n    } else {\n      return id < this.data.dataArray.length ? this.data.dataArray[id] : 'null';\n    }\n  }\n\n  public getFeatureId(field: string, value: any): number | undefined {\n    const feature = this.data.dataArray.find((dataItem: IParseDataItem) => {\n      return dataItem[field] === name;\n    });\n    return feature?._id;\n  }\n\n  private excuteParser(): void {\n    const parser = this.parser;\n    const type: string = parser.type || 'geojson';\n    const sourceParser = getParser(type);\n    this.data = sourceParser(this.originData, parser);\n    // 计算范围\n    this.extent = extent(this.data.dataArray);\n  }\n  /**\n   * 数据统计\n   */\n  private executeTrans() {\n    const trans = this.transforms;\n    trans.forEach((tran: ITransform) => {\n      const { type } = tran;\n      const data = getTransform(type)(this.data, tran);\n      Object.assign(this.data, data);\n    });\n  }\n\n  private initCluster() {\n    if (!this.cluster) {\n      return;\n    }\n    const { radius, minZoom = 0, maxZoom } = this.clusterOptions;\n    this.clusterIndex = new Supercluster({\n      radius,\n      minZoom,\n      maxZoom,\n    });\n    this.clusterIndex.load(this.rawData.features);\n  }\n\n  private init() {\n    this.hooks.init.call(this);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}