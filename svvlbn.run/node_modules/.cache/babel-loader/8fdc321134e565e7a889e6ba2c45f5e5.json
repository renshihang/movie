{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from '../../core/BaseModel';\nimport { LineArcTriangulation } from '../../core/triangulation';\nvar line_arc_frag = \"#define LineTypeSolid 0.0\\n#define LineTypeDash 1.0\\n#define Animate 0.0\\n\\nuniform float u_opacity;\\nuniform float u_blur : 0.9;\\nuniform float u_line_type: 0.0;\\nvarying vec2 v_normal;\\nvarying vec2 v_dash_array;\\nvarying float v_distance_ratio;\\nvarying vec4 v_color;\\n\\nuniform float u_time;\\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  gl_FragColor = v_color;\\n  float blur = 1.- smoothstep(u_blur, 1., length(v_normal.xy));\\n  gl_FragColor.a *= (blur * u_opacity);\\n  if(u_line_type == LineTypeDash) {\\n    gl_FragColor.a *= blur  * (1.0- step(v_dash_array.x, mod(v_distance_ratio, v_dash_array.x +v_dash_array.y)));\\n  }\\n\\n  if(u_aimate.x == Animate) {\\n      float alpha =1.0 - fract( mod(1.0- v_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\\n      alpha = smoothstep(0., 1., alpha);\\n      gl_FragColor.a *= alpha;\\n  }\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\nvar line_arc2d_vert = \"#define LineTypeSolid 0.0\\n#define LineTypeDash 1.0\\n#define Animate 0.0\\nattribute vec4 a_Color;\\nattribute vec3 a_Position;\\nattribute vec4 a_Instance;\\nattribute float a_Size;\\nuniform mat4 u_ModelMatrix;\\nuniform float segmentNumber;\\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\n\\nvarying float v_distance_ratio;\\nuniform float u_line_type: 0.0;\\nuniform vec2 u_dash_array: [10.0, 5.];\\nvarying vec2 v_dash_array;\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"project\\\"\\n#pragma include \\\"picking\\\"\\n\\nfloat bezier3(vec3 arr, float t) {\\n  float ut = 1. - t;\\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\\n}\\nvec2 midPoint(vec2 source, vec2 target) {\\n  vec2 center = target - source;\\n  float r = length(center);\\n  float theta = atan(center.y, center.x);\\n  float thetaOffset = 0.314;\\n  float r2 = r / 2.0 / cos(thetaOffset);\\n  float theta2 = theta + thetaOffset;\\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\\n  return mid;\\n}\\nfloat getSegmentRatio(float index) {\\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\\n}\\nvec2 interpolate (vec2 source, vec2 target, float t) {\\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\\n  vec2 mid = midPoint(source, target);\\n  vec3 x = vec3(source.x, mid.x, target.x);\\n  vec3 y = vec3(source.y, mid.y, target.y);\\n  return vec2(bezier3(x ,t), bezier3(y,t));\\n}\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace);\\n  // rotate by 90 degrees\\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n  vec2 offset = dir_screenspace * offset_direction * a_Size / 2.0;\\n  return offset * vec2(1.0, -1.0);\\n}\\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace);\\n  // rotate by 90 degrees\\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\\n}\\n\\nvoid main() {\\n  v_color = a_Color;\\n  vec2 source = a_Instance.rg;\\n  vec2 target =  a_Instance.ba;\\n  float segmentIndex = a_Position.x;\\n  float segmentRatio = getSegmentRatio(segmentIndex);\\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\\n  if(u_line_type == LineTypeDash) {\\n      v_distance_ratio = segmentIndex / segmentNumber;\\n      float total_Distance = pixelDistance(a_Instance.rg, a_Instance.ba) / 2.0 * PI;\\n      v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\\n    }\\n  if(u_aimate.x == Animate) {\\n      v_distance_ratio = segmentIndex / segmentNumber;\\n  }\\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio), 0.0, 1.0));\\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio), 0.0, 1.0));\\n  v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\\n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nvar lineStyleObj = {\n  solid: 0.0,\n  dash: 1.0\n};\n\nvar ArcModel = function (_BaseModel) {\n  _inherits(ArcModel, _BaseModel);\n\n  function ArcModel() {\n    _classCallCheck(this, ArcModel);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ArcModel).apply(this, arguments));\n  }\n\n  _createClass(ArcModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          opacity = _ref.opacity,\n          _ref$lineType = _ref.lineType,\n          lineType = _ref$lineType === void 0 ? 'solid' : _ref$lineType,\n          _ref$dashArray = _ref.dashArray,\n          dashArray = _ref$dashArray === void 0 ? [10, 5] : _ref$dashArray;\n\n      return {\n        u_opacity: opacity || 1,\n        segmentNumber: 30,\n        u_line_type: lineStyleObj[lineType || 'solid'],\n        u_dash_array: dashArray\n      };\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      var _ref2 = this.layer.getLayerConfig(),\n          animateOption = _ref2.animateOption;\n\n      return {\n        u_aimate: this.animateOption2Array(animateOption),\n        u_time: this.layer.getLayerAnimateTime()\n      };\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      return [this.layer.buildLayerModel({\n        moduleName: 'arc2dline',\n        vertexShader: line_arc2d_vert,\n        fragmentShader: line_arc_frag,\n        triangulation: LineArcTriangulation,\n        depth: {\n          enable: false\n        },\n        blend: this.getBlend()\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var size = feature.size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'instance',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Instance',\n          buffer: {\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 4,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4], vertex[5], vertex[6]];\n          }\n        }\n      });\n    }\n  }]);\n\n  return ArcModel;\n}(BaseModel);\n\nexport { ArcModel as default };","map":{"version":3,"sources":["../../../src/line/models/arc.ts"],"names":["lineStyleObj","solid","dash","ArcModel","BaseModel","opacity","lineType","dashArray","u_opacity","segmentNumber","u_line_type","u_dash_array","animateOption","u_aimate","u_time","moduleName","vertexShader","fragmentShader","triangulation","depth","enable","blend","name","type","AttributeType","descriptor","buffer","usage","gl","data","FLOAT","size","update","feature","Array","vertex"],"mappings":";;;;;AAAA,SAAA,aAAA,EAAA,EAAA,QAAA,eAAA;AAUA,OAAA,SAAA,MAAA,sBAAA;AAEA,SAAA,oBAAA,QAAA,0BAAA;;;AAGA,IAAMA,YAAuC,GAAG;AAC9CC,EAAAA,KAAK,EADyC,GAAA;AAE9CC,EAAAA,IAAI,EAAE;AAFwC,CAAhD;;IAIqBC,Q;;;;;;;;;;;mCACkB;AAAA,UAAA,IAAA,GAK/B,KAAA,KAAA,CAL+B,cAK/B,EAL+B;AAAA,UAEjCE,OAFiC,GAAA,IAAA,CAAA,OAAA;AAAA,UAAA,aAAA,GAAA,IAAA,CAAA,QAAA;AAAA,UAGjCC,QAHiC,GAAA,aAAA,KAAA,KAAA,CAAA,GAAA,OAAA,GAAA,aAAA;AAAA,UAAA,cAAA,GAAA,IAAA,CAAA,SAAA;AAAA,UAIjCC,SAJiC,GAAA,cAAA,KAAA,KAAA,CAAA,GAIrB,CAAA,EAAA,EAJqB,CAIrB,CAJqB,GAAA,cAAA;;AAMnC,aAAO;AACLC,QAAAA,SAAS,EAAEH,OAAO,IADb,CAAA;AAELI,QAAAA,aAAa,EAFR,EAAA;AAGLC,QAAAA,WAAW,EAAEV,YAAY,CAACM,QAAQ,IAH7B,OAGoB,CAHpB;AAILK,QAAAA,YAAY,EAAEJ;AAJT,OAAP;AAMD;;;yCAE0C;AAAA,UAAA,KAAA,GACf,KAAA,KAAA,CADe,cACf,EADe;AAAA,UACjCK,aADiC,GAAA,KAAA,CAAA,aAAA;;AAEzC,aAAO;AACLC,QAAAA,QAAQ,EAAE,KAAA,mBAAA,CADL,aACK,CADL;AAELC,QAAAA,MAAM,EAAE,KAAA,KAAA,CAAA,mBAAA;AAFH,OAAP;AAID;;;kCAE8B;AAC7B,aAAO,CACL,KAAA,KAAA,CAAA,eAAA,CAA2B;AACzBC,QAAAA,UAAU,EADe,WAAA;AAEzBC,QAAAA,YAAY,EAFa,eAAA;AAGzBC,QAAAA,cAAc,EAHW,aAAA;AAIzBC,QAAAA,aAAa,EAJY,oBAAA;AAKzBC,QAAAA,KAAK,EAAE;AAAEC,UAAAA,MAAM,EAAE;AAAV,SALkB;AAMzBC,QAAAA,KAAK,EAAE,KAAA,QAAA;AANkB,OAA3B,CADK,CAAP;AAUD;;;gDAEqC;AAEpC,WAAA,qBAAA,CAAA,sBAAA,CAAkD;AAChDC,QAAAA,IAAI,EAD4C,MAAA;AAEhDC,QAAAA,IAAI,EAAEC,aAAa,CAF6B,SAAA;AAGhDC,QAAAA,UAAU,EAAE;AACVH,UAAAA,IAAI,EADM,QAAA;AAEVI,UAAAA,MAAM,EAAE;AAENC,YAAAA,KAAK,EAAEC,EAAE,CAFH,YAAA;AAGNC,YAAAA,IAAI,EAHE,EAAA;AAINN,YAAAA,IAAI,EAAEK,EAAE,CAACE;AAJH,WAFE;AAQVC,UAAAA,IAAI,EARM,CAAA;AASVC,UAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,OAAA,EAAA,UAAA,EAAA,MAAA,EAAA,YAAA,EAKH;AAAA,gBACKD,IADL,GACcE,OADd,CAAA,IAAA;AAEH,mBAAOC,KAAK,CAALA,OAAAA,CAAAA,IAAAA,IAAsB,CAACH,IAAI,CAA3BG,CAA2B,CAAL,CAAtBA,GAAkC,CAAzC,IAAyC,CAAzC;AACD;AAjBS;AAHoC,OAAlD;AAwBA,WAAA,qBAAA,CAAA,sBAAA,CAAkD;AAChDZ,QAAAA,IAAI,EAD4C,UAAA;AAEhDC,QAAAA,IAAI,EAAEC,aAAa,CAF6B,SAAA;AAGhDC,QAAAA,UAAU,EAAE;AACVH,UAAAA,IAAI,EADM,YAAA;AAEVI,UAAAA,MAAM,EAAE;AACNC,YAAAA,KAAK,EAAEC,EAAE,CADH,WAAA;AAENC,YAAAA,IAAI,EAFE,EAAA;AAGNN,YAAAA,IAAI,EAAEK,EAAE,CAACE;AAHH,WAFE;AAOVC,UAAAA,IAAI,EAPM,CAAA;AAQVC,UAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,OAAA,EAAA,UAAA,EAAA,MAAA,EAAA,YAAA,EAKH;AACH,mBAAO,CAACG,MAAM,CAAP,CAAO,CAAP,EAAYA,MAAM,CAAlB,CAAkB,CAAlB,EAAuBA,MAAM,CAA7B,CAA6B,CAA7B,EAAkCA,MAAM,CAA/C,CAA+C,CAAxC,CAAP;AACD;AAfS;AAHoC,OAAlD;AAqBD;;;;EAnFmC/B,S;;SAAjBD,Q","sourcesContent":["import {\n  AttributeType,\n  gl,\n  IAnimateOption,\n  IEncodeFeature,\n  ILayerConfig,\n  IModel,\n  IModelUniform,\n} from '@antv/l7-core';\n\nimport BaseModel from '../../core/BaseModel';\nimport { ILineLayerStyleOptions, lineStyleType } from '../../core/interface';\nimport { LineArcTriangulation } from '../../core/triangulation';\nimport line_arc_frag from '../shaders/line_arc_frag.glsl';\nimport line_arc2d_vert from '../shaders/line_bezier_vert.glsl';\nconst lineStyleObj: { [key: string]: number } = {\n  solid: 0.0,\n  dash: 1.0,\n};\nexport default class ArcModel extends BaseModel {\n  public getUninforms(): IModelUniform {\n    const {\n      opacity,\n      lineType = 'solid',\n      dashArray = [10, 5],\n    } = this.layer.getLayerConfig() as ILineLayerStyleOptions;\n    return {\n      u_opacity: opacity || 1,\n      segmentNumber: 30,\n      u_line_type: lineStyleObj[lineType || 'solid'],\n      u_dash_array: dashArray,\n    };\n  }\n\n  public getAnimateUniforms(): IModelUniform {\n    const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;\n    return {\n      u_aimate: this.animateOption2Array(animateOption as IAnimateOption),\n      u_time: this.layer.getLayerAnimateTime(),\n    };\n  }\n\n  public buildModels(): IModel[] {\n    return [\n      this.layer.buildLayerModel({\n        moduleName: 'arc2dline',\n        vertexShader: line_arc2d_vert,\n        fragmentShader: line_arc_frag,\n        triangulation: LineArcTriangulation,\n        depth: { enable: false },\n        blend: this.getBlend(),\n      }),\n    ];\n  }\n\n  protected registerBuiltinAttributes() {\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 1,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const { size } = feature;\n          return Array.isArray(size) ? [size[0]] : [size as number];\n        },\n      },\n    });\n\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'instance', // 弧线起始点信息\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Instance',\n        buffer: {\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 4,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          return [vertex[3], vertex[4], vertex[5], vertex[6]];\n        },\n      },\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}