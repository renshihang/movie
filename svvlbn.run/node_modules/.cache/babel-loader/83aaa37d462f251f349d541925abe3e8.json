{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { generateColorRamp } from '@antv/l7-utils';\nimport { mat4 } from 'gl-matrix';\nimport BaseModel from '../../core/BaseModel';\nimport { HeatmapTriangulation } from '../../core/triangulation';\nvar heatmap3DFrag = \"uniform sampler2D u_texture;\\nuniform sampler2D u_colorTexture;\\nuniform float u_opacity;\\nvarying vec2 v_texCoord;\\nvarying float v_intensity;\\n\\nvoid main(){\\n   \\n     float intensity = texture2D(u_texture, v_texCoord).r;\\n     vec2 ramp_pos = vec2(\\n        fract(16.0 * (1.0 - v_intensity)),\\n        floor(16.0 * (1.0 - v_intensity)) / 16.0);\\n    // vec4 color = texture2D(u_colorTexture,vec2(0.5,1.0-intensity));\\n    vec4 color = texture2D(u_colorTexture,ramp_pos);\\n    gl_FragColor = color;\\n    gl_FragColor.a = color.a * smoothstep(0.1,0.2,intensity)* u_opacity;\\n}\\n\";\nvar heatmap3DVert = \"precision highp float;\\nattribute vec3 a_Position;\\nattribute vec2 a_Uv;\\nuniform sampler2D u_texture;\\nvarying vec2 v_texCoord;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_InverseViewProjectionMatrix;\\nvarying float v_intensity;\\n\\nvec2 toBezier(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\\n    float t2 = t * t;\\n    float one_minus_t = 1.0 - t;\\n    float one_minus_t2 = one_minus_t * one_minus_t;\\n    return (P0 * one_minus_t2 * one_minus_t + P1 * 3.0 * t * one_minus_t2 + P2 * 3.0 * t2 * one_minus_t + P3 * t2 * t);\\n}\\nvec2 toBezier(float t, vec4 p){\\n    return toBezier(t, vec2(0.0, 0.0), vec2(p.x, p.y), vec2(p.z, p.w), vec2(1.0, 1.0));\\n}\\n#pragma include \\\"projection\\\"\\nvoid main() {\\n  v_texCoord = a_Uv;\\n\\n  vec2 pos = 1.8 * (a_Uv * vec2(2.0) - vec2(1.0));\\n\\n\\n  vec4 p1 = vec4(pos, 0.0, 1.0);\\n\\tvec4 p2 = vec4(pos, 1.0, 1.0);\\n\\n\\tvec4 inverseP1 = unproject_clipspace_to_position(p1, u_InverseViewProjectionMatrix);\\n\\tvec4 inverseP2 = unproject_clipspace_to_position(p2, u_InverseViewProjectionMatrix) ;\\n\\n  inverseP1 = inverseP1 / inverseP1.w;\\n\\tinverseP2 = inverseP2 / inverseP2.w;\\n\\n\\tfloat zPos = (0.0 - inverseP1.z) / (inverseP2.z - inverseP1.z);\\n\\tvec4 position = inverseP1 + zPos * (inverseP2 - inverseP1);\\n\\n  vec4 b= vec4(0.5000, 0, 1, 0.5000);\\n  float fh;\\n\\n  v_intensity = texture2D(u_texture, v_texCoord).r;\\n  fh = toBezier(v_intensity, b).y;\\n  gl_Position = project_common_position_to_clipspace(vec4(position.xy, fh * 50., 1.0));\\n\\n}\\n\";\nvar heatmapColorFrag = \"uniform sampler2D u_texture;\\nuniform sampler2D u_colorTexture;\\nuniform float u_opacity;\\nvarying vec2 v_texCoord;\\nvarying float v_intensity;\\n\\nvoid main(){\\n     float intensity = texture2D(u_texture, v_texCoord).r;\\n     vec2 ramp_pos = vec2(\\n        fract(16.0 * (1.0 - intensity)),\\n        floor(16.0 * (1.0 - intensity)) / 16.0);\\n    // vec4 color = texture2D(u_colorTexture,vec2(0.5,1.0-intensity));\\n    vec4 color = texture2D(u_colorTexture,ramp_pos);\\n    gl_FragColor = color;\\n    gl_FragColor.a = color.a * smoothstep(0.,0.05,intensity) * u_opacity;\\n\\n}\\n\";\nvar heatmapFrag = \"precision highp float;\\nuniform float u_intensity;\\nvarying float v_weight;\\nvarying vec2 v_extrude;\\n\\n\\nvoid main(){\\n    float GAUSS_COEF = 0.3989422804014327;\\n    float d = -0.5 * 3.0 * 3.0 * dot(v_extrude, v_extrude);\\n    float val = v_weight * u_intensity * GAUSS_COEF * exp(d);\\n    gl_FragColor = vec4(val, val, val, val);\\n}\\n\";\nvar heatmapVert = \"precision highp float;\\nattribute vec3 a_Position;\\nattribute float a_Size;\\nattribute vec2 a_Dir;\\nuniform float u_intensity;\\nuniform float u_radius;\\nvarying vec2 v_extrude;\\nvarying float v_weight;\\nuniform mat4 u_ModelMatrix;\\n\\n#pragma include \\\"projection\\\"\\n\\nvoid main(){\\n    v_weight = a_Size;\\n    float GAUSS_COEF = 0.3989422804014327;\\n    float ZERO = 1.0 / 255.0 / 16.0;\\n    float extrude_x = a_Dir.x * 2.0 -1.0;\\n    float extrude_y = a_Dir.y * 2.0 -1.0;\\n    vec2 extrude_dir = normalize(vec2(extrude_x,extrude_y));\\n    float S = sqrt(-2.0 * log(ZERO / a_Size / u_intensity / GAUSS_COEF)) / 3.0;\\n    v_extrude = extrude_dir * S;\\n\\n    vec2 offset = project_pixel(v_extrude * u_radius);\\n    vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\\n\\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\\n}\\n\";\nvar heatmapColorVert = \"precision highp float;\\nattribute vec3 a_Position;\\nattribute vec2 a_Uv;\\nuniform sampler2D u_texture;\\nvarying vec2 v_texCoord;\\nvarying float v_intensity;\\nvoid main() {\\n   v_texCoord = a_Uv;\\n  v_intensity = texture2D(u_texture, v_texCoord).r;\\n   gl_Position = vec4(a_Position.xy, 0, 1.);\\n}\\n\";\nimport { heatMap3DTriangulation } from '../triangulation';\n\nvar HeatMapModel = function (_BaseModel) {\n  _inherits(HeatMapModel, _BaseModel);\n\n  function HeatMapModel() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, HeatMapModel);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(HeatMapModel)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.texture = void 0;\n    _this.colorTexture = void 0;\n    _this.heatmapFramerBuffer = void 0;\n    _this.intensityModel = void 0;\n    _this.colorModel = void 0;\n    _this.shapeType = void 0;\n    return _this;\n  }\n\n  _createClass(HeatMapModel, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$rendererService = this.rendererService,\n          clear = _this$rendererService.clear,\n          useFramebuffer = _this$rendererService.useFramebuffer;\n      useFramebuffer(this.heatmapFramerBuffer, function () {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: _this2.heatmapFramerBuffer\n        });\n\n        _this2.drawIntensityMode();\n      });\n      this.shapeType === 'heatmap' ? this.drawColorMode() : this.draw3DHeatMap();\n    }\n  }, {\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      var _shapeAttr$scale;\n\n      var _this$rendererService2 = this.rendererService,\n          createFramebuffer = _this$rendererService2.createFramebuffer,\n          clear = _this$rendererService2.clear,\n          getViewportSize = _this$rendererService2.getViewportSize,\n          createTexture2D = _this$rendererService2.createTexture2D,\n          useFramebuffer = _this$rendererService2.useFramebuffer;\n      var shapeAttr = this.styleAttributeService.getLayerStyleAttribute('shape');\n      var shapeType = (shapeAttr === null || shapeAttr === void 0 ? void 0 : (_shapeAttr$scale = shapeAttr.scale) === null || _shapeAttr$scale === void 0 ? void 0 : _shapeAttr$scale.field) || 'heatmap';\n      this.shapeType = shapeType;\n      this.intensityModel = this.buildHeatMapIntensity();\n      this.colorModel = shapeType === 'heatmap' ? this.buildHeatmapColor() : this.build3dHeatMap();\n\n      var _ref = this.layer.getLayerConfig(),\n          rampColors = _ref.rampColors;\n\n      var imageData = generateColorRamp(rampColors);\n\n      var _getViewportSize = getViewportSize(),\n          width = _getViewportSize.width,\n          height = _getViewportSize.height;\n\n      this.heatmapFramerBuffer = createFramebuffer({\n        color: createTexture2D({\n          width: width,\n          height: height,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE,\n          min: gl.LINEAR,\n          mag: gl.LINEAR\n        })\n      });\n      this.colorTexture = createTexture2D({\n        data: imageData.data,\n        width: imageData.width,\n        height: imageData.height,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n        min: gl.LINEAR,\n        mag: gl.LINEAR,\n        flipY: true\n      });\n      return [this.intensityModel, this.colorModel];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'dir',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Dir',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 2,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4]];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var _feature$size = feature.size,\n                size = _feature$size === void 0 ? 2 : _feature$size;\n            return [size];\n          }\n        }\n      });\n    }\n  }, {\n    key: \"buildHeatMapIntensity\",\n    value: function buildHeatMapIntensity() {\n      return this.layer.buildLayerModel({\n        moduleName: 'heatmapintensity',\n        vertexShader: heatmapVert,\n        fragmentShader: heatmapFrag,\n        triangulation: HeatmapTriangulation,\n        depth: {\n          enable: false\n        },\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.ONE,\n            srcAlpha: gl.ONE_MINUS_SRC_ALPHA,\n            dstRGB: gl.ONE,\n            dstAlpha: gl.ONE_MINUS_SRC_ALPHA\n          }\n        }\n      });\n    }\n  }, {\n    key: \"buildHeatmapColor\",\n    value: function buildHeatmapColor() {\n      this.shaderModuleService.registerModule('heatmapColor', {\n        vs: heatmapColorVert,\n        fs: heatmapColorFrag\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule('heatmapColor'),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          uniforms = _this$shaderModuleSer.uniforms;\n\n      var _this$rendererService3 = this.rendererService,\n          createAttribute = _this$rendererService3.createAttribute,\n          createElements = _this$rendererService3.createElements,\n          createBuffer = _this$rendererService3.createBuffer,\n          createModel = _this$rendererService3.createModel;\n      return createModel({\n        vs: vs,\n        fs: fs,\n        attributes: {\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: [-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],\n              type: gl.FLOAT\n            }),\n            size: 3\n          }),\n          a_Uv: createAttribute({\n            buffer: createBuffer({\n              data: [0, 1, 1, 1, 0, 0, 1, 0],\n              type: gl.FLOAT\n            }),\n            size: 2\n          })\n        },\n        uniforms: _objectSpread({}, uniforms),\n        depth: {\n          enable: false\n        },\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.SRC_ALPHA,\n            srcAlpha: 1,\n            dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n            dstAlpha: 1\n          }\n        },\n        count: 6,\n        elements: createElements({\n          data: [0, 2, 1, 2, 3, 1],\n          type: gl.UNSIGNED_INT,\n          count: 6\n        })\n      });\n    }\n  }, {\n    key: \"drawIntensityMode\",\n    value: function drawIntensityMode() {\n      var _ref2 = this.layer.getLayerConfig(),\n          opacity = _ref2.opacity,\n          _ref2$intensity = _ref2.intensity,\n          intensity = _ref2$intensity === void 0 ? 10 : _ref2$intensity,\n          _ref2$radius = _ref2.radius,\n          radius = _ref2$radius === void 0 ? 5 : _ref2$radius;\n\n      this.intensityModel.draw({\n        uniforms: {\n          u_opacity: opacity || 1.0,\n          u_radius: radius,\n          u_intensity: intensity\n        }\n      });\n    }\n  }, {\n    key: \"drawColorMode\",\n    value: function drawColorMode() {\n      var _ref3 = this.layer.getLayerConfig(),\n          opacity = _ref3.opacity;\n\n      this.colorModel.draw({\n        uniforms: {\n          u_opacity: opacity || 1.0,\n          u_colorTexture: this.colorTexture,\n          u_texture: this.heatmapFramerBuffer\n        }\n      });\n    }\n  }, {\n    key: \"draw3DHeatMap\",\n    value: function draw3DHeatMap() {\n      var _ref4 = this.layer.getLayerConfig(),\n          opacity = _ref4.opacity;\n\n      var invert = mat4.invert(mat4.create(), mat4.fromValues.apply(mat4, _toConsumableArray(this.cameraService.getViewProjectionMatrix())));\n      this.colorModel.draw({\n        uniforms: {\n          u_opacity: opacity || 1.0,\n          u_colorTexture: this.colorTexture,\n          u_texture: this.heatmapFramerBuffer,\n          u_InverseViewProjectionMatrix: _toConsumableArray(invert)\n        }\n      });\n    }\n  }, {\n    key: \"build3dHeatMap\",\n    value: function build3dHeatMap() {\n      var getViewportSize = this.rendererService.getViewportSize;\n\n      var _getViewportSize2 = getViewportSize(),\n          width = _getViewportSize2.width,\n          height = _getViewportSize2.height;\n\n      var triangulation = heatMap3DTriangulation(width / 2.0, height / 2.0);\n      this.shaderModuleService.registerModule('heatmap3dColor', {\n        vs: heatmap3DVert,\n        fs: heatmap3DFrag\n      });\n\n      var _this$shaderModuleSer2 = this.shaderModuleService.getModule('heatmap3dColor'),\n          vs = _this$shaderModuleSer2.vs,\n          fs = _this$shaderModuleSer2.fs,\n          uniforms = _this$shaderModuleSer2.uniforms;\n\n      var _this$rendererService4 = this.rendererService,\n          createAttribute = _this$rendererService4.createAttribute,\n          createElements = _this$rendererService4.createElements,\n          createBuffer = _this$rendererService4.createBuffer,\n          createModel = _this$rendererService4.createModel;\n      return createModel({\n        vs: vs,\n        fs: fs,\n        attributes: {\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: triangulation.vertices,\n              type: gl.FLOAT\n            }),\n            size: 3\n          }),\n          a_Uv: createAttribute({\n            buffer: createBuffer({\n              data: triangulation.uvs,\n              type: gl.FLOAT\n            }),\n            size: 2\n          })\n        },\n        primitive: gl.TRIANGLES,\n        uniforms: _objectSpread({}, uniforms),\n        depth: {\n          enable: true\n        },\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.SRC_ALPHA,\n            srcAlpha: 1,\n            dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n            dstAlpha: 1\n          }\n        },\n        elements: createElements({\n          data: triangulation.indices,\n          type: gl.UNSIGNED_INT,\n          count: triangulation.indices.length\n        })\n      });\n    }\n  }]);\n\n  return HeatMapModel;\n}(BaseModel);\n\nexport { HeatMapModel as default };","map":{"version":3,"sources":["../../../src/heatmap/models/heatmap.ts"],"names":["HeatMapModel","BaseModel","texture","colorTexture","heatmapFramerBuffer","intensityModel","colorModel","shapeType","clear","useFramebuffer","color","depth","stencil","framebuffer","createFramebuffer","getViewportSize","createTexture2D","shapeAttr","rampColors","imageData","generateColorRamp","width","height","wrapS","gl","wrapT","min","mag","LINEAR","data","flipY","name","type","AttributeType","descriptor","buffer","usage","FLOAT","size","update","vertex","feature","moduleName","vertexShader","fragmentShader","triangulation","enable","blend","func","srcRGB","srcAlpha","dstRGB","dstAlpha","ONE_MINUS_SRC_ALPHA","vs","fs","heatmapColorFrag","uniforms","createAttribute","createElements","createBuffer","createModel","attributes","a_Position","a_Uv","count","elements","opacity","intensity","radius","u_opacity","u_radius","u_intensity","u_colorTexture","u_texture","invert","mat4","u_InverseViewProjectionMatrix","heatMap3DTriangulation","heatmap3DFrag","primitive","length"],"mappings":"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","sourcesContent":["import {\n  AttributeType,\n  gl,\n  IEncodeFeature,\n  IFramebuffer,\n  IModel,\n  IModelUniform,\n  ITexture2D,\n} from '@antv/l7-core';\nimport { generateColorRamp, IColorRamp } from '@antv/l7-utils';\nimport { mat4 } from 'gl-matrix';\nimport BaseModel from '../../core/BaseModel';\nimport { HeatmapTriangulation } from '../../core/triangulation';\nimport heatmap3DFrag from '../shaders/heatmap_3d_frag.glsl';\nimport heatmap3DVert from '../shaders/heatmap_3d_vert.glsl';\nimport heatmapColorFrag from '../shaders/heatmap_frag.glsl';\nimport heatmapFrag from '../shaders/heatmap_framebuffer_frag.glsl';\nimport heatmapVert from '../shaders/heatmap_framebuffer_vert.glsl';\nimport heatmapColorVert from '../shaders/heatmap_vert.glsl';\nimport { heatMap3DTriangulation } from '../triangulation';\ninterface IHeatMapLayerStyleOptions {\n  opacity: number;\n  intensity: number;\n  radius: number;\n  rampColors: IColorRamp;\n}\n\nexport default class HeatMapModel extends BaseModel {\n  protected texture: ITexture2D;\n  protected colorTexture: ITexture2D;\n  protected heatmapFramerBuffer: IFramebuffer;\n  private intensityModel: IModel;\n  private colorModel: IModel;\n  private shapeType: string;\n\n  public render() {\n    const { clear, useFramebuffer } = this.rendererService;\n    useFramebuffer(this.heatmapFramerBuffer, () => {\n      clear({\n        color: [0, 0, 0, 0],\n        depth: 1,\n        stencil: 0,\n        framebuffer: this.heatmapFramerBuffer,\n      });\n      this.drawIntensityMode();\n    });\n    this.shapeType === 'heatmap' ? this.drawColorMode() : this.draw3DHeatMap();\n  }\n\n  public getUninforms(): IModelUniform {\n    throw new Error('Method not implemented.');\n  }\n\n  public buildModels(): IModel[] {\n    const {\n      createFramebuffer,\n      clear,\n      getViewportSize,\n      createTexture2D,\n      useFramebuffer,\n    } = this.rendererService;\n    const shapeAttr = this.styleAttributeService.getLayerStyleAttribute(\n      'shape',\n    );\n    const shapeType = shapeAttr?.scale?.field || 'heatmap';\n    this.shapeType = shapeType as string;\n    // 生成热力图密度图\n    this.intensityModel = this.buildHeatMapIntensity();\n    // 渲染到屏幕\n    this.colorModel =\n      shapeType === 'heatmap'\n        ? this.buildHeatmapColor() // 2D\n        : this.build3dHeatMap(); // 3D\n\n    const {\n      rampColors,\n    } = this.layer.getLayerConfig() as IHeatMapLayerStyleOptions;\n    const imageData = generateColorRamp(rampColors as IColorRamp);\n    const { width, height } = getViewportSize();\n\n    // 初始化密度图纹理\n    this.heatmapFramerBuffer = createFramebuffer({\n      color: createTexture2D({\n        width,\n        height,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n        min: gl.LINEAR,\n        mag: gl.LINEAR,\n      }),\n    });\n\n    // 初始化颜色纹理\n\n    this.colorTexture = createTexture2D({\n      data: imageData.data,\n      width: imageData.width,\n      height: imageData.height,\n      wrapS: gl.CLAMP_TO_EDGE,\n      wrapT: gl.CLAMP_TO_EDGE,\n      min: gl.LINEAR,\n      mag: gl.LINEAR,\n      flipY: true,\n    });\n\n    return [this.intensityModel, this.colorModel];\n  }\n  protected registerBuiltinAttributes() {\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'dir',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Dir',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 2,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          return [vertex[3], vertex[4]];\n        },\n      },\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 1,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const { size = 2 } = feature;\n          return [size as number];\n        },\n      },\n    });\n  }\n  private buildHeatMapIntensity(): IModel {\n    return this.layer.buildLayerModel({\n      moduleName: 'heatmapintensity',\n      vertexShader: heatmapVert,\n      fragmentShader: heatmapFrag,\n      triangulation: HeatmapTriangulation,\n      depth: {\n        enable: false,\n      },\n      blend: {\n        enable: true,\n        func: {\n          srcRGB: gl.ONE,\n          srcAlpha: gl.ONE_MINUS_SRC_ALPHA,\n          dstRGB: gl.ONE,\n          dstAlpha: gl.ONE_MINUS_SRC_ALPHA,\n        },\n      },\n    });\n  }\n\n  private buildHeatmapColor(): IModel {\n    this.shaderModuleService.registerModule('heatmapColor', {\n      vs: heatmapColorVert,\n      fs: heatmapColorFrag,\n    });\n\n    const { vs, fs, uniforms } = this.shaderModuleService.getModule(\n      'heatmapColor',\n    );\n    const {\n      createAttribute,\n      createElements,\n      createBuffer,\n      createModel,\n    } = this.rendererService;\n    return createModel({\n      vs,\n      fs,\n      attributes: {\n        a_Position: createAttribute({\n          buffer: createBuffer({\n            data: [-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],\n            type: gl.FLOAT,\n          }),\n          size: 3,\n        }),\n        a_Uv: createAttribute({\n          buffer: createBuffer({\n            data: [0, 1, 1, 1, 0, 0, 1, 0],\n            type: gl.FLOAT,\n          }),\n          size: 2,\n        }),\n      },\n      uniforms: {\n        ...uniforms,\n      },\n      depth: {\n        enable: false,\n      },\n      blend: {\n        enable: true,\n        func: {\n          srcRGB: gl.SRC_ALPHA,\n          srcAlpha: 1,\n          dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n          dstAlpha: 1,\n        },\n      },\n      count: 6,\n      elements: createElements({\n        data: [0, 2, 1, 2, 3, 1],\n        type: gl.UNSIGNED_INT,\n        count: 6,\n      }),\n    });\n  }\n\n  private drawIntensityMode() {\n    const {\n      opacity,\n      intensity = 10,\n      radius = 5,\n    } = this.layer.getLayerConfig() as IHeatMapLayerStyleOptions;\n    this.intensityModel.draw({\n      uniforms: {\n        u_opacity: opacity || 1.0,\n        u_radius: radius,\n        u_intensity: intensity,\n      },\n    });\n  }\n\n  private drawColorMode() {\n    const {\n      opacity,\n    } = this.layer.getLayerConfig() as IHeatMapLayerStyleOptions;\n    this.colorModel.draw({\n      uniforms: {\n        u_opacity: opacity || 1.0,\n        u_colorTexture: this.colorTexture,\n        u_texture: this.heatmapFramerBuffer,\n      },\n    });\n  }\n\n  private draw3DHeatMap() {\n    const {\n      opacity,\n    } = this.layer.getLayerConfig() as IHeatMapLayerStyleOptions;\n    const invert = mat4.invert(\n      mat4.create(),\n      // @ts-ignore\n      mat4.fromValues(...this.cameraService.getViewProjectionMatrix()),\n    ) as mat4;\n    this.colorModel.draw({\n      uniforms: {\n        u_opacity: opacity || 1.0,\n        u_colorTexture: this.colorTexture,\n        u_texture: this.heatmapFramerBuffer,\n        u_InverseViewProjectionMatrix: [...invert],\n      },\n    });\n  }\n  private build3dHeatMap() {\n    const { getViewportSize } = this.rendererService;\n    const { width, height } = getViewportSize();\n    const triangulation = heatMap3DTriangulation(width / 2.0, height / 2.0);\n    this.shaderModuleService.registerModule('heatmap3dColor', {\n      vs: heatmap3DVert,\n      fs: heatmap3DFrag,\n    });\n\n    const { vs, fs, uniforms } = this.shaderModuleService.getModule(\n      'heatmap3dColor',\n    );\n    const {\n      createAttribute,\n      createElements,\n      createBuffer,\n      createModel,\n    } = this.rendererService;\n    return createModel({\n      vs,\n      fs,\n      attributes: {\n        a_Position: createAttribute({\n          buffer: createBuffer({\n            data: triangulation.vertices,\n            type: gl.FLOAT,\n          }),\n          size: 3,\n        }),\n        a_Uv: createAttribute({\n          buffer: createBuffer({\n            data: triangulation.uvs,\n            type: gl.FLOAT,\n          }),\n          size: 2,\n        }),\n      },\n      primitive: gl.TRIANGLES,\n      uniforms: {\n        ...uniforms,\n      },\n      depth: {\n        enable: true,\n      },\n      blend: {\n        enable: true,\n        func: {\n          srcRGB: gl.SRC_ALPHA,\n          srcAlpha: 1,\n          dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n          dstAlpha: 1,\n        },\n      },\n      elements: createElements({\n        data: triangulation.indices,\n        type: gl.UNSIGNED_INT,\n        count: triangulation.indices.length,\n      }),\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}