{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nimport CollisionIndex from '../../utils/collision-index';\nimport { calculteCentroid } from '../../utils/geo';\nimport { getGlyphQuads, shapeText } from '../../utils/symbol-layout';\nvar textFrag = \"#define SDF_PX 8.0\\n#define EDGE_GAMMA 0.105\\nuniform sampler2D u_sdf_map;\\nuniform float u_gamma_scale : 0.5;\\nuniform float u_font_size : 24;\\nuniform float u_opacity : 1.0;\\nuniform vec4 u_stroke : [0, 0, 0, 1];\\nuniform float u_strokeWidth : 2.0;\\nuniform float u_halo_blur : 0.5;\\nuniform float u_DevicePixelRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_uv;\\nvarying float v_gamma_scale;\\n\\n#pragma include \\\"picking\\\"\\nvoid main() {\\n  // get sdf from atlas\\n  float dist = texture2D(u_sdf_map, v_uv).a;\\n\\n  float fontScale = u_font_size / 24.0;\\n\\n  lowp float buff = (6.0 - u_strokeWidth / fontScale) / SDF_PX;\\n  highp float gamma = (u_halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * u_gamma_scale) / 1.0;\\n\\n  highp float gamma_scaled = gamma * v_gamma_scale;\\n\\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\\n\\n  gl_FragColor = mix(v_color * u_opacity, u_stroke, smoothstep(0., 0.5, 1. - dist)) * alpha;\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\nvar textVert = \"#define SDF_PX 8.0\\n#define EDGE_GAMMA 0.105\\nattribute vec3 a_Position;\\nattribute vec2 a_tex;\\nattribute vec2 a_textOffsets;\\nattribute vec4 a_Color;\\nattribute float a_Size;\\n\\nuniform vec2 u_sdf_map_size;\\nuniform mat4 u_ModelMatrix;\\n\\nvarying vec2 v_uv;\\nvarying float v_gamma_scale;\\nvarying vec4 v_color;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  v_color = a_Color;\\n  v_uv = a_tex / u_sdf_map_size;\\n\\n  // \\u6587\\u672C\\u7F29\\u653E\\u6BD4\\u4F8B\\n  float fontScale = a_Size / 24.;\\n\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n\\n  vec4 projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\\n\\n  gl_Position = vec4(projected_position.xy / projected_position.w\\n    + a_textOffsets * fontScale / u_ViewportSize * 2. * u_DevicePixelRatio, 0.0, 1.0);\\n  v_gamma_scale = gl_Position.w;\\n  setPickingColor(a_PickingColor);\\n\\n}\\n\";\nexport function TextTriangulation(feature) {\n  var centroid = feature.centroid;\n  var glyphQuads = feature.glyphQuads;\n  var vertices = [];\n  var indices = [];\n  var coord = centroid.length === 2 ? [centroid[0], centroid[1], 0] : centroid;\n  glyphQuads.forEach(function (quad, index) {\n    vertices.push.apply(vertices, _toConsumableArray(coord).concat([quad.tex.x, quad.tex.y + quad.tex.height, quad.tl.x, quad.tl.y], _toConsumableArray(coord), [quad.tex.x + quad.tex.width, quad.tex.y + quad.tex.height, quad.tr.x, quad.tr.y], _toConsumableArray(coord), [quad.tex.x + quad.tex.width, quad.tex.y, quad.br.x, quad.br.y], _toConsumableArray(coord), [quad.tex.x, quad.tex.y, quad.bl.x, quad.bl.y]));\n    indices.push(0 + index * 4, 1 + index * 4, 2 + index * 4, 2 + index * 4, 3 + index * 4, 0 + index * 4);\n  });\n  return {\n    vertices: vertices,\n    indices: indices,\n    size: 7\n  };\n}\n\nvar TextModel = function (_BaseModel) {\n  _inherits(TextModel, _BaseModel);\n\n  function TextModel() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, TextModel);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TextModel)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.texture = void 0;\n    _this.glyphInfo = void 0;\n    _this.currentZoom = -1;\n    _this.extent = void 0;\n    return _this;\n  }\n\n  _createClass(TextModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          _ref$fontWeight = _ref.fontWeight,\n          fontWeight = _ref$fontWeight === void 0 ? 800 : _ref$fontWeight,\n          _ref$fontFamily = _ref.fontFamily,\n          fontFamily = _ref$fontFamily === void 0 ? 'sans-serif' : _ref$fontFamily,\n          _ref$stroke = _ref.stroke,\n          stroke = _ref$stroke === void 0 ? '#fff' : _ref$stroke,\n          _ref$strokeWidth = _ref.strokeWidth,\n          strokeWidth = _ref$strokeWidth === void 0 ? 0 : _ref$strokeWidth;\n\n      var canvas = this.fontService.canvas;\n      return {\n        u_opacity: 1.0,\n        u_sdf_map: this.texture,\n        u_stroke: rgb2arr(stroke),\n        u_halo_blur: 0.5,\n        u_sdf_map_size: [canvas.width, canvas.height],\n        u_strokeWidth: strokeWidth\n      };\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      this.extent = this.textExtent();\n      this.initGlyph();\n      this.updateTexture();\n      this.filterGlyphs();\n      return [this.layer.buildLayerModel({\n        moduleName: 'pointText',\n        vertexShader: textVert,\n        fragmentShader: textFrag,\n        triangulation: TextTriangulation,\n        depth: {\n          enable: false\n        },\n        blend: this.getBlend()\n      })];\n    }\n  }, {\n    key: \"needUpdate\",\n    value: function needUpdate() {\n      var _ref2 = this.layer.getLayerConfig(),\n          _ref2$textAllowOverla = _ref2.textAllowOverlap,\n          textAllowOverlap = _ref2$textAllowOverla === void 0 ? false : _ref2$textAllowOverla;\n\n      var zoom = this.mapService.getZoom();\n      var extent = this.mapService.getBounds();\n      var flag = extent[0][0] < this.extent[0][0] || extent[0][1] < this.extent[0][1] || extent[1][0] > this.extent[1][0] || extent[1][1] < this.extent[1][1];\n\n      if (!textAllowOverlap && (Math.abs(this.currentZoom - zoom) > 1 || flag)) {\n        this.filterGlyphs();\n        this.layer.models = [this.layer.buildLayerModel({\n          moduleName: 'pointText',\n          vertexShader: textVert,\n          fragmentShader: textFrag,\n          triangulation: TextTriangulation,\n          depth: {\n            enable: false\n          },\n          blend: this.getBlend()\n        })];\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'textOffsets',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_textOffsets',\n          buffer: {\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 2,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[5], vertex[6]];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var size = feature.size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'textUv',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_tex',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 2,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4]];\n          }\n        }\n      });\n    }\n  }, {\n    key: \"textExtent\",\n    value: function textExtent() {\n      var bounds = this.mapService.getBounds();\n      var step = Math.min(bounds[1][0] - bounds[0][0], bounds[1][1] - bounds[1][0]) / 2;\n      return [[bounds[0][0] - step, bounds[0][1] - step], [bounds[1][0] + step, bounds[1][1] + step]];\n    }\n  }, {\n    key: \"initTextFont\",\n    value: function initTextFont() {\n      var _ref3 = this.layer.getLayerConfig(),\n          _ref3$fontWeight = _ref3.fontWeight,\n          fontWeight = _ref3$fontWeight === void 0 ? '800' : _ref3$fontWeight,\n          fontFamily = _ref3.fontFamily;\n\n      var data = this.layer.getEncodedData();\n      var characterSet = [];\n      data.forEach(function (item) {\n        var _item$shape = item.shape,\n            shape = _item$shape === void 0 ? '' : _item$shape;\n        shape = shape.toString();\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = shape[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var char = _step.value;\n\n            if (characterSet.indexOf(char) === -1) {\n              characterSet.push(char);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      });\n      this.fontService.setFontOptions({\n        characterSet: characterSet,\n        fontWeight: fontWeight,\n        fontFamily: fontFamily\n      });\n    }\n  }, {\n    key: \"generateGlyphLayout\",\n    value: function generateGlyphLayout() {\n      var mapping = this.fontService.mapping;\n\n      var _ref4 = this.layer.getLayerConfig(),\n          _ref4$spacing = _ref4.spacing,\n          spacing = _ref4$spacing === void 0 ? 2 : _ref4$spacing,\n          _ref4$textAnchor = _ref4.textAnchor,\n          textAnchor = _ref4$textAnchor === void 0 ? 'center' : _ref4$textAnchor,\n          textOffset = _ref4.textOffset;\n\n      var data = this.layer.getEncodedData();\n      this.glyphInfo = data.map(function (feature) {\n        var _feature$shape = feature.shape,\n            shape = _feature$shape === void 0 ? '' : _feature$shape,\n            coordinates = feature.coordinates;\n        var shaping = shapeText(shape.toString(), mapping, 24, textAnchor, 'center', spacing, textOffset);\n        var glyphQuads = getGlyphQuads(shaping, textOffset, false);\n        feature.shaping = shaping;\n        feature.glyphQuads = glyphQuads;\n        feature.centroid = calculteCentroid(coordinates);\n        return feature;\n      });\n    }\n  }, {\n    key: \"filterGlyphs\",\n    value: function filterGlyphs() {\n      var _this2 = this;\n\n      var _ref5 = this.layer.getLayerConfig(),\n          _ref5$padding = _ref5.padding,\n          padding = _ref5$padding === void 0 ? [4, 4] : _ref5$padding,\n          _ref5$textAllowOverla = _ref5.textAllowOverlap,\n          textAllowOverlap = _ref5$textAllowOverla === void 0 ? false : _ref5$textAllowOverla;\n\n      if (textAllowOverlap) {\n        return;\n      }\n\n      this.currentZoom = this.mapService.getZoom();\n      this.extent = this.textExtent();\n\n      var _this$rendererService = this.rendererService.getViewportSize(),\n          width = _this$rendererService.width,\n          height = _this$rendererService.height;\n\n      var collisionIndex = new CollisionIndex(width, height);\n      var filterData = this.glyphInfo.filter(function (feature) {\n        var shaping = feature.shaping,\n            _feature$id = feature.id,\n            id = _feature$id === void 0 ? 0 : _feature$id;\n        var centroid = feature.centroid;\n        var size = feature.size;\n        var fontScale = size / 24;\n\n        var pixels = _this2.mapService.lngLatToContainer(centroid);\n\n        var _collisionIndex$place = collisionIndex.placeCollisionBox({\n          x1: shaping.left * fontScale - padding[0],\n          x2: shaping.right * fontScale + padding[0],\n          y1: shaping.top * fontScale - padding[1],\n          y2: shaping.bottom * fontScale + padding[1],\n          anchorPointX: pixels.x,\n          anchorPointY: pixels.y\n        }),\n            box = _collisionIndex$place.box;\n\n        if (box && box.length) {\n          collisionIndex.insertCollisionBox(box, id);\n          return true;\n        } else {\n          return false;\n        }\n      });\n      this.layer.setEncodedData(filterData);\n    }\n  }, {\n    key: \"initGlyph\",\n    value: function initGlyph() {\n      this.initTextFont();\n      this.generateGlyphLayout();\n    }\n  }, {\n    key: \"updateTexture\",\n    value: function updateTexture() {\n      var createTexture2D = this.rendererService.createTexture2D;\n      var canvas = this.fontService.canvas;\n      this.texture = createTexture2D({\n        data: canvas,\n        width: canvas.width,\n        height: canvas.height\n      });\n    }\n  }]);\n\n  return TextModel;\n}(BaseModel);\n\nexport { TextModel as default };","map":{"version":3,"sources":["../../../src/point/models/text.ts"],"names":["centroid","feature","glyphQuads","vertices","indices","coord","quad","index","size","TextModel","BaseModel","texture","glyphInfo","currentZoom","extent","fontWeight","fontFamily","stroke","strokeWidth","canvas","u_opacity","u_sdf_map","u_stroke","rgb2arr","u_halo_blur","u_sdf_map_size","u_strokeWidth","moduleName","vertexShader","fragmentShader","triangulation","depth","enable","blend","textAllowOverlap","zoom","flag","Math","name","type","AttributeType","descriptor","buffer","usage","gl","data","FLOAT","update","vertex","Array","bounds","step","characterSet","shape","item","char","mapping","spacing","textAnchor","textOffset","coordinates","shaping","shapeText","getGlyphQuads","calculteCentroid","padding","width","height","collisionIndex","filterData","id","fontScale","pixels","box","x1","x2","y1","y2","anchorPointX","anchorPointY","y","createTexture2D"],"mappings":"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","sourcesContent":["import {\n  AttributeType,\n  BlendType,\n  gl,\n  IEncodeFeature,\n  ILayer,\n  ILayerConfig,\n  IModel,\n  IModelUniform,\n  ITexture2D,\n} from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nimport CollisionIndex from '../../utils/collision-index';\nimport { calculteCentroid } from '../../utils/geo';\nimport {\n  getGlyphQuads,\n  IGlyphQuad,\n  shapeText,\n} from '../../utils/symbol-layout';\nimport textFrag from '../shaders/text_frag.glsl';\nimport textVert from '../shaders/text_vert.glsl';\ninterface IPointTextLayerStyleOptions {\n  opacity: number;\n  textAnchor: string;\n  spacing: number;\n  padding: [number, number];\n  stroke: string;\n  strokeWidth: number;\n  strokeOpacity: number;\n  fontWeight: string;\n  fontFamily: string;\n  textOffset: [number, number];\n  textAllowOverlap: boolean;\n}\nexport function TextTriangulation(feature: IEncodeFeature) {\n  const centroid = feature.centroid as number[]; // 计算中心点\n  const { glyphQuads } = feature;\n  const vertices: number[] = [];\n  const indices: number[] = [];\n  const coord =\n    centroid.length === 2 ? [centroid[0], centroid[1], 0] : centroid;\n  glyphQuads.forEach((quad: IGlyphQuad, index: number) => {\n    vertices.push(\n      ...coord,\n      quad.tex.x,\n      quad.tex.y + quad.tex.height,\n      quad.tl.x,\n      quad.tl.y,\n      ...coord,\n      quad.tex.x + quad.tex.width,\n      quad.tex.y + quad.tex.height,\n      quad.tr.x,\n      quad.tr.y,\n      ...coord,\n      quad.tex.x + quad.tex.width,\n      quad.tex.y,\n      quad.br.x,\n      quad.br.y,\n      ...coord,\n      quad.tex.x,\n      quad.tex.y,\n      quad.bl.x,\n      quad.bl.y,\n    );\n    indices.push(\n      0 + index * 4,\n      1 + index * 4,\n      2 + index * 4,\n      2 + index * 4,\n      3 + index * 4,\n      0 + index * 4,\n    );\n  });\n  return {\n    vertices, // [ x, y, z, tex.x,tex.y, offset.x. offset.y]\n    indices,\n    size: 7,\n  };\n}\n\nexport default class TextModel extends BaseModel {\n  private texture: ITexture2D;\n  private glyphInfo: IEncodeFeature[];\n  private currentZoom: number = -1;\n  private extent: [[number, number], [number, number]];\n\n  public getUninforms(): IModelUniform {\n    const {\n      fontWeight = 800,\n      fontFamily = 'sans-serif',\n      stroke = '#fff',\n      strokeWidth = 0,\n    } = this.layer.getLayerConfig() as IPointTextLayerStyleOptions;\n    const { canvas } = this.fontService;\n    return {\n      u_opacity: 1.0,\n      u_sdf_map: this.texture,\n      u_stroke: rgb2arr(stroke),\n      u_halo_blur: 0.5,\n      u_sdf_map_size: [canvas.width, canvas.height],\n      u_strokeWidth: strokeWidth,\n    };\n  }\n\n  public buildModels(): IModel[] {\n    this.extent = this.textExtent();\n    this.initGlyph();\n    this.updateTexture();\n    this.filterGlyphs();\n    return [\n      this.layer.buildLayerModel({\n        moduleName: 'pointText',\n        vertexShader: textVert,\n        fragmentShader: textFrag,\n        triangulation: TextTriangulation,\n        depth: { enable: false },\n        blend: this.getBlend(),\n      }),\n    ];\n  }\n  public needUpdate() {\n    const {\n      textAllowOverlap = false,\n    } = this.layer.getLayerConfig() as IPointTextLayerStyleOptions;\n    const zoom = this.mapService.getZoom();\n    const extent = this.mapService.getBounds();\n    const flag =\n      extent[0][0] < this.extent[0][0] ||\n      extent[0][1] < this.extent[0][1] ||\n      extent[1][0] > this.extent[1][0] ||\n      extent[1][1] < this.extent[1][1];\n\n    if (!textAllowOverlap && (Math.abs(this.currentZoom - zoom) > 1 || flag)) {\n      this.filterGlyphs();\n      this.layer.models = [\n        this.layer.buildLayerModel({\n          moduleName: 'pointText',\n          vertexShader: textVert,\n          fragmentShader: textFrag,\n          triangulation: TextTriangulation,\n          depth: { enable: false },\n          blend: this.getBlend(),\n        }),\n      ];\n      return true;\n    }\n    return false;\n  }\n\n  protected registerBuiltinAttributes() {\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'textOffsets',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_textOffsets',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 2,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          return [vertex[5], vertex[6]];\n        },\n      },\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 1,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const { size } = feature;\n          return Array.isArray(size) ? [size[0]] : [size as number];\n        },\n      },\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'textUv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_tex',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 2,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          return [vertex[3], vertex[4]];\n        },\n      },\n    });\n  }\n  private textExtent(): [[number, number], [number, number]] {\n    const bounds = this.mapService.getBounds();\n    const step =\n      Math.min(bounds[1][0] - bounds[0][0], bounds[1][1] - bounds[1][0]) / 2;\n    return [\n      [bounds[0][0] - step, bounds[0][1] - step],\n      [bounds[1][0] + step, bounds[1][1] + step],\n    ];\n  }\n  /**\n   * 生成文字纹理\n   */\n  private initTextFont() {\n    const {\n      fontWeight = '800',\n      fontFamily,\n    } = this.layer.getLayerConfig() as IPointTextLayerStyleOptions;\n    const data = this.layer.getEncodedData();\n    const characterSet: string[] = [];\n    data.forEach((item: IEncodeFeature) => {\n      let { shape = '' } = item;\n      shape = shape.toString();\n      for (const char of shape) {\n        // 去重\n        if (characterSet.indexOf(char) === -1) {\n          characterSet.push(char);\n        }\n      }\n    });\n    this.fontService.setFontOptions({\n      characterSet,\n      fontWeight,\n      fontFamily,\n    });\n  }\n  /**\n   * 生成文字布局\n   */\n  private generateGlyphLayout() {\n    const { mapping } = this.fontService;\n    const {\n      spacing = 2,\n      textAnchor = 'center',\n      textOffset,\n    } = this.layer.getLayerConfig() as IPointTextLayerStyleOptions;\n    const data = this.layer.getEncodedData();\n    this.glyphInfo = data.map((feature: IEncodeFeature) => {\n      const { shape = '', coordinates } = feature;\n      const shaping = shapeText(\n        shape.toString(),\n        mapping,\n        24,\n        textAnchor,\n        'center',\n        spacing,\n        textOffset,\n      );\n      const glyphQuads = getGlyphQuads(shaping, textOffset, false);\n      feature.shaping = shaping;\n      feature.glyphQuads = glyphQuads;\n      feature.centroid = calculteCentroid(coordinates);\n      return feature;\n    });\n  }\n  /**\n   * 文字避让\n   */\n  private filterGlyphs() {\n    const {\n      padding = [4, 4],\n      textAllowOverlap = false,\n    } = this.layer.getLayerConfig() as IPointTextLayerStyleOptions;\n    if (textAllowOverlap) {\n      return;\n    }\n    this.currentZoom = this.mapService.getZoom();\n    this.extent = this.textExtent();\n    const { width, height } = this.rendererService.getViewportSize();\n    const collisionIndex = new CollisionIndex(width, height);\n    const filterData = this.glyphInfo.filter((feature: IEncodeFeature) => {\n      const { shaping, id = 0 } = feature;\n      const centroid = feature.centroid as [number, number];\n      const size = feature.size as number;\n      const fontScale: number = size / 24;\n      const pixels = this.mapService.lngLatToContainer(centroid);\n      const { box } = collisionIndex.placeCollisionBox({\n        x1: shaping.left * fontScale - padding[0],\n        x2: shaping.right * fontScale + padding[0],\n        y1: shaping.top * fontScale - padding[1],\n        y2: shaping.bottom * fontScale + padding[1],\n        anchorPointX: pixels.x,\n        anchorPointY: pixels.y,\n      });\n      if (box && box.length) {\n        // TODO：featureIndex\n        collisionIndex.insertCollisionBox(box, id);\n        return true;\n      } else {\n        return false;\n      }\n    });\n    this.layer.setEncodedData(filterData);\n  }\n  /**\n   * 初始化文字布局\n   */\n  private initGlyph() {\n    // 1.生成文字纹理\n    this.initTextFont();\n    // 2.生成文字布局\n    this.generateGlyphLayout();\n  }\n  /**\n   * 更新文字纹理\n   */\n  private updateTexture() {\n    const { createTexture2D } = this.rendererService;\n    const { canvas } = this.fontService;\n    this.texture = createTexture2D({\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}