{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport rewind from '@mapbox/geojson-rewind';\nexport default function json(data, cfg) {\n  var x = cfg.x,\n      y = cfg.y,\n      x1 = cfg.x1,\n      y1 = cfg.y1,\n      coordinates = cfg.coordinates;\n  var resultData = [];\n  data.forEach(function (col, featureIndex) {\n    var coords = [];\n\n    if (x && y) {\n      coords = [parseFloat(col[x]), parseFloat(col[y])];\n    }\n\n    if (x && y && x1 && y1) {\n      coords = [[parseFloat(col[x]), parseFloat(col[y])], [parseFloat(col[x1]), parseFloat(col[y1])]];\n    }\n\n    if (coordinates) {\n      var type = 'Polygon';\n\n      if (!Array.isArray(coordinates[0])) {\n        type = 'Point';\n      }\n\n      if (Array.isArray(coordinates[0]) && !Array.isArray(coordinates[0][0])) {\n        type = 'LineString';\n      }\n\n      var geometry = {\n        type: type,\n        coordinates: _toConsumableArray(col[coordinates])\n      };\n      rewind(geometry, true);\n      coords = geometry.coordinates;\n    }\n\n    var dataItem = _objectSpread({}, col, {\n      _id: featureIndex,\n      coordinates: coords\n    });\n\n    resultData.push(dataItem);\n  });\n  return {\n    dataArray: resultData\n  };\n}","map":{"version":3,"sources":["../../src/parser/json.ts"],"names":["x","y","x1","y1","coordinates","cfg","resultData","data","coords","parseFloat","col","type","Array","geometry","rewind","dataItem","_id","dataArray"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA,OAAA,MAAA,MAAA,wBAAA;AACA,eAAe,SAAA,IAAA,CAAA,IAAA,EAAA,GAAA,EAA6D;AAAA,MAClEA,CADkE,GACpCK,GADoC,CAAA,CAAA;AAAA,MAC/DJ,CAD+D,GACpCI,GADoC,CAAA,CAAA;AAAA,MAC5DH,EAD4D,GACpCG,GADoC,CAAA,EAAA;AAAA,MACxDF,EADwD,GACpCE,GADoC,CAAA,EAAA;AAAA,MACpDD,WADoD,GACpCC,GADoC,CAAA,WAAA;AAE1E,MAAMC,UAA4B,GAAlC,EAAA;AACAC,EAAAA,IAAI,CAAJA,OAAAA,CAAa,UAAA,GAAA,EAAA,YAAA,EAA0C;AACrD,QAAIC,MAAM,GAAV,EAAA;;AACA,QAAIR,CAAC,IAAL,CAAA,EAAY;AACVQ,MAAAA,MAAM,GAAG,CAACC,UAAU,CAACC,GAAG,CAAf,CAAe,CAAJ,CAAX,EAAqBD,UAAU,CAACC,GAAG,CAA5CF,CAA4C,CAAJ,CAA/B,CAATA;AACD;;AACD,QAAIR,CAAC,IAADA,CAAAA,IAAAA,EAAAA,IAAJ,EAAA,EAAwB;AAEtBQ,MAAAA,MAAM,GAAG,CACP,CAACC,UAAU,CAACC,GAAG,CAAf,CAAe,CAAJ,CAAX,EAAqBD,UAAU,CAACC,GAAG,CAD5B,CAC4B,CAAJ,CAA/B,CADO,EAEP,CAACD,UAAU,CAACC,GAAG,CAAf,EAAe,CAAJ,CAAX,EAAsBD,UAAU,CAACC,GAAG,CAFtCF,EAEsC,CAAJ,CAAhC,CAFO,CAATA;AAID;;AACD,QAAA,WAAA,EAAiB;AACf,UAAIG,IAAI,GAAR,SAAA;;AACA,UAAI,CAACC,KAAK,CAALA,OAAAA,CAAcR,WAAW,CAA9B,CAA8B,CAAzBQ,CAAL,EAAoC;AAClCD,QAAAA,IAAI,GAAJA,OAAAA;AACD;;AACD,UAAIC,KAAK,CAALA,OAAAA,CAAcR,WAAW,CAAzBQ,CAAyB,CAAzBA,KAAiC,CAACA,KAAK,CAALA,OAAAA,CAAcR,WAAW,CAAXA,CAAW,CAAXA,CAApD,CAAoDA,CAAdQ,CAAtC,EAAwE;AACtED,QAAAA,IAAI,GAAJA,YAAAA;AACD;;AACD,UAAME,QAAQ,GAAG;AACfF,QAAAA,IAAI,EADW,IAAA;AAEfP,QAAAA,WAAW,EAAA,kBAAA,CAAMM,GAAG,CAAT,WAAS,CAAT;AAFI,OAAjB;AAIAI,MAAAA,MAAM,CAAA,QAAA,EAANA,IAAM,CAANA;AACAN,MAAAA,MAAM,GAAGK,QAAQ,CAAjBL,WAAAA;AACD;;AACD,QAAMO,QAAQ,GAAA,aAAA,CAAA,EAAA,EAAA,GAAA,EAAA;AAEZC,MAAAA,GAAG,EAFS,YAAA;AAGZZ,MAAAA,WAAW,EAAEI;AAHD,KAAA,CAAd;;AAKAF,IAAAA,UAAU,CAAVA,IAAAA,CAAAA,QAAAA;AAhCFC,GAAAA;AAkCA,SAAO;AACLU,IAAAA,SAAS,EAAEX;AADN,GAAP;AAGD","sourcesContent":["// @ts-ignore\nimport {\n  IJsonData,\n  IJsonItem,\n  IParseDataItem,\n  IParserCfg,\n  IParserData,\n} from '@antv/l7-core';\n// @ts-ignore\nimport rewind from '@mapbox/geojson-rewind';\nexport default function json(data: IJsonData, cfg: IParserCfg): IParserData {\n  const { x, y, x1, y1, coordinates } = cfg;\n  const resultData: IParseDataItem[] = [];\n  data.forEach((col: IJsonItem, featureIndex: number) => {\n    let coords = [];\n    if (x && y) {\n      coords = [parseFloat(col[x]), parseFloat(col[y])];\n    } // 点数据\n    if (x && y && x1 && y1) {\n      // 弧线 或者线段\n      coords = [\n        [parseFloat(col[x]), parseFloat(col[y])],\n        [parseFloat(col[x1]), parseFloat(col[y1])],\n      ];\n    }\n    if (coordinates) {\n      let type = 'Polygon';\n      if (!Array.isArray(coordinates[0])) {\n        type = 'Point';\n      }\n      if (Array.isArray(coordinates[0]) && !Array.isArray(coordinates[0][0])) {\n        type = 'LineString';\n      }\n      const geometry = {\n        type,\n        coordinates: [...col[coordinates]],\n      };\n      rewind(geometry, true);\n      coords = geometry.coordinates;\n    }\n    const dataItem = {\n      ...col,\n      _id: featureIndex,\n      coordinates: coords,\n    };\n    resultData.push(dataItem);\n  });\n  return {\n    dataArray: resultData,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}