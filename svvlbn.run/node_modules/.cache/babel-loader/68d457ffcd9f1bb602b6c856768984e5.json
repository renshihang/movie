{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from '../../core/BaseModel';\nimport { LineArcTriangulation } from '../../core/triangulation';\nvar line_arc2d_vert = \"#define LineTypeSolid 0.0\\n#define LineTypeDash 1.0\\n#define Animate 0.0\\nattribute vec4 a_Color;\\nattribute vec3 a_Position;\\nattribute vec4 a_Instance;\\nattribute float a_Size;\\nuniform mat4 u_ModelMatrix;\\nuniform float segmentNumber;\\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\n\\nvarying float v_distance_ratio;\\nuniform float u_line_type: 0.0;\\nuniform vec2 u_dash_array: [10.0, 5.];\\nvarying vec2 v_dash_array;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"project\\\"\\n#pragma include \\\"picking\\\"\\n\\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\\n}\\n\\nfloat getSegmentRatio(float index) {\\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\\n}\\n\\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\\n    vec2 x = mix(source, target, ratio);\\n    vec2 center = mix(source, target, 0.5);\\n    float dSourceCenter = distance(source, center);\\n    float dXCenter = distance(x, center);\\n    return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\\n}\\n\\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\\n     float vertex_height = paraboloid(source, target, segmentRatio);\\n\\n    return vec3(\\n    mix(source, target, segmentRatio),\\n    sqrt(max(0.0, vertex_height))\\n    );\\n}\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace);\\n  // rotate by 90 degrees\\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n  vec2 offset = dir_screenspace * offset_direction * a_Size / 2.0;\\n  return offset * vec2(1.0, -1.0);\\n}\\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace);\\n  // rotate by 90 degrees\\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\\n}\\nfloat getAngularDist (vec2 source, vec2 target) {\\n  vec2 delta = source - target;\\n  vec2 sin_half_delta = sin(delta / 2.0);\\n  float a =\\n    sin_half_delta.y * sin_half_delta.y +\\n    cos(source.y) * cos(target.y) *\\n    sin_half_delta.x * sin_half_delta.x;\\n  return 2.0 * atan(sqrt(a), sqrt(1.0 - a));\\n}\\nvec2 interpolate (vec2 source, vec2 target, float angularDist, float t) {\\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\\n  if(abs(angularDist - PI) < 0.001) {\\n    return (1.0 - t) * source + t * target;\\n  }\\n  float a = sin((1.0 - t) * angularDist) / sin(angularDist);\\n  float b = sin(t * angularDist) / sin(angularDist);\\n  vec2 sin_source = sin(source);\\n  vec2 cos_source = cos(source);\\n  vec2 sin_target = sin(target);\\n  vec2 cos_target = cos(target);\\n  float x = a * cos_source.y * cos_source.x + b * cos_target.y * cos_target.x;\\n  float y = a * cos_source.y * sin_source.x + b * cos_target.y * sin_target.x;\\n  float z = a * sin_source.y + b * sin_target.y;\\n  return vec2(atan(y, x), atan(z, sqrt(x * x + y * y)));\\n}\\n\\nvoid main() {\\n  v_color = a_Color;\\n  vec2 source = radians(a_Instance.rg);\\n  vec2 target = radians(a_Instance.ba);\\n  float angularDist = getAngularDist(source, target);\\n  float segmentIndex = a_Position.x;\\n  float segmentRatio = getSegmentRatio(segmentIndex);\\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\\n  if(u_line_type == LineTypeDash) {\\n    v_distance_ratio = segmentIndex / segmentNumber;\\n    float total_Distance = pixelDistance(a_Instance.rg, a_Instance.ba);\\n    v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\\n  }\\n  if(u_aimate.x == Animate) {\\n      v_distance_ratio = segmentIndex / segmentNumber;\\n  }\\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\\n  v_distance_ratio = segmentIndex / segmentNumber;\\n  vec4 curr = project_position(vec4(degrees(interpolate(source, target, angularDist, segmentRatio)), 0.0, 1.0));\\n  vec4 next = project_position(vec4(degrees(interpolate(source, target, angularDist, nextSegmentRatio)), 0.0, 1.0));\\n  v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\\n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\\n  //  vec4 project_pos = project_position(vec4(curr.xy, 0, 1.0));\\n  gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, curr.z, 1.0));\\n  setPickingColor(a_PickingColor);\\n}\\n\\n\";\nvar line_arc_frag = \"#define LineTypeSolid 0.0\\n#define LineTypeDash 1.0\\n#define Animate 0.0\\n\\nuniform float u_opacity;\\nuniform float u_blur : 0.9;\\nuniform float u_line_type: 0.0;\\nvarying vec2 v_normal;\\nvarying vec2 v_dash_array;\\nvarying float v_distance_ratio;\\nvarying vec4 v_color;\\n\\nuniform float u_time;\\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  gl_FragColor = v_color;\\n  float blur = 1.- smoothstep(u_blur, 1., length(v_normal.xy));\\n  gl_FragColor.a *= (blur * u_opacity);\\n  if(u_line_type == LineTypeDash) {\\n    gl_FragColor.a *= blur  * (1.0- step(v_dash_array.x, mod(v_distance_ratio, v_dash_array.x +v_dash_array.y)));\\n  }\\n\\n  if(u_aimate.x == Animate) {\\n      float alpha =1.0 - fract( mod(1.0- v_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\\n      alpha = smoothstep(0., 1., alpha);\\n      gl_FragColor.a *= alpha;\\n  }\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\nvar lineStyleObj = {\n  solid: 0.0,\n  dash: 1.0\n};\n\nvar GreatCircleModel = function (_BaseModel) {\n  _inherits(GreatCircleModel, _BaseModel);\n\n  function GreatCircleModel() {\n    _classCallCheck(this, GreatCircleModel);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GreatCircleModel).apply(this, arguments));\n  }\n\n  _createClass(GreatCircleModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          opacity = _ref.opacity,\n          _ref$lineType = _ref.lineType,\n          lineType = _ref$lineType === void 0 ? 'solid' : _ref$lineType,\n          _ref$dashArray = _ref.dashArray,\n          dashArray = _ref$dashArray === void 0 ? [10, 5] : _ref$dashArray;\n\n      return {\n        u_opacity: opacity || 1,\n        segmentNumber: 30,\n        u_line_type: lineStyleObj[lineType] || 0.0,\n        u_dash_array: dashArray\n      };\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      var _ref2 = this.layer.getLayerConfig(),\n          animateOption = _ref2.animateOption;\n\n      return {\n        u_aimate: this.animateOption2Array(animateOption),\n        u_time: this.layer.getLayerAnimateTime()\n      };\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      return [this.layer.buildLayerModel({\n        moduleName: 'arc2dline',\n        vertexShader: line_arc2d_vert,\n        fragmentShader: line_arc_frag,\n        triangulation: LineArcTriangulation,\n        depth: {\n          enable: false\n        },\n        blend: this.getBlend()\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var size = feature.size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'instance',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Instance',\n          buffer: {\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 4,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4], vertex[5], vertex[6]];\n          }\n        }\n      });\n    }\n  }]);\n\n  return GreatCircleModel;\n}(BaseModel);\n\nexport { GreatCircleModel as default };","map":{"version":3,"sources":["../../../src/line/models/great_circle.ts"],"names":["lineStyleObj","solid","dash","GreatCircleModel","BaseModel","opacity","lineType","dashArray","u_opacity","segmentNumber","u_line_type","u_dash_array","animateOption","u_aimate","u_time","moduleName","vertexShader","fragmentShader","triangulation","depth","enable","blend","name","type","AttributeType","descriptor","buffer","usage","gl","data","FLOAT","size","update","feature","Array","vertex"],"mappings":"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","sourcesContent":["import {\n  AttributeType,\n  gl,\n  IAnimateOption,\n  IEncodeFeature,\n  ILayerConfig,\n  IModel,\n  IModelUniform,\n} from '@antv/l7-core';\n\nimport BaseModel from '../../core/BaseModel';\nimport { ILineLayerStyleOptions, lineStyleType } from '../../core/interface';\nimport { LineArcTriangulation } from '../../core/triangulation';\nimport line_arc2d_vert from '../shaders/line_arc2d_vert.glsl';\nimport line_arc_frag from '../shaders/line_arc_frag.glsl';\nconst lineStyleObj: { [key: string]: number } = {\n  solid: 0.0,\n  dash: 1.0,\n};\n\nexport default class GreatCircleModel extends BaseModel {\n  public getUninforms(): IModelUniform {\n    const {\n      opacity,\n      lineType = 'solid',\n      dashArray = [10, 5],\n    } = this.layer.getLayerConfig() as Partial<ILineLayerStyleOptions>;\n    return {\n      u_opacity: opacity || 1,\n      segmentNumber: 30,\n      u_line_type: lineStyleObj[lineType as string] || 0.0,\n      u_dash_array: dashArray,\n    };\n  }\n  public getAnimateUniforms(): IModelUniform {\n    const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;\n    return {\n      u_aimate: this.animateOption2Array(animateOption as IAnimateOption),\n      u_time: this.layer.getLayerAnimateTime(),\n    };\n  }\n\n  public buildModels(): IModel[] {\n    return [\n      this.layer.buildLayerModel({\n        moduleName: 'arc2dline',\n        vertexShader: line_arc2d_vert,\n        fragmentShader: line_arc_frag,\n        triangulation: LineArcTriangulation,\n        depth: { enable: false },\n        blend: this.getBlend(),\n      }),\n    ];\n  }\n  protected registerBuiltinAttributes() {\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 1,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const { size } = feature;\n          return Array.isArray(size) ? [size[0]] : [size as number];\n        },\n      },\n    });\n\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'instance', // 弧线起始点信息\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Instance',\n        buffer: {\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 4,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          return [vertex[3], vertex[4], vertex[5], vertex[6]];\n        },\n      },\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}