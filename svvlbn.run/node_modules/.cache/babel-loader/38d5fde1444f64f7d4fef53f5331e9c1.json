{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nimport { PointFillTriangulation } from '../../core/triangulation';\nvar pointFillFrag = \"#define Animate 0.0\\n\\nuniform float u_blur : 0;\\nuniform float u_opacity : 1;\\nuniform float u_stroke_width : 1;\\nuniform vec4 u_stroke_color : [0, 0, 0, 0];\\nuniform float u_stroke_opacity : 1;\\n\\nvarying vec4 v_data;\\nvarying vec4 v_color;\\nvarying float v_radius;\\nuniform float u_time;\\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\\n\\n#pragma include \\\"sdf_2d\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  int shape = int(floor(v_data.w + 0.5));\\n\\n  lowp float antialiasblur = v_data.z;\\n  float antialiased_blur = -max(u_blur, antialiasblur);\\n  float r = v_radius / (v_radius + u_stroke_width);\\n\\n  float outer_df;\\n  float inner_df;\\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\\n  if (shape == 0) {\\n    outer_df = sdCircle(v_data.xy, 1.0);\\n    inner_df = sdCircle(v_data.xy, r);\\n  } else if (shape == 1) {\\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\\n  } else if (shape == 2) {\\n    outer_df = sdBox(v_data.xy, vec2(1.));\\n    inner_df = sdBox(v_data.xy, vec2(r));\\n  } else if (shape == 3) {\\n    outer_df = sdPentagon(v_data.xy, 0.8);\\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\\n  } else if (shape == 4) {\\n    outer_df = sdHexagon(v_data.xy, 0.8);\\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\\n  } else if (shape == 5) {\\n    outer_df = sdOctogon(v_data.xy, 1.0);\\n    inner_df = sdOctogon(v_data.xy, r);\\n  } else if (shape == 6) {\\n    outer_df = sdHexagram(v_data.xy, 0.52);\\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\\n  } else if (shape == 7) {\\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\\n    inner_df = sdRhombus(v_data.xy, vec2(r));\\n  } else if (shape == 8) {\\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\\n  }\\n\\n  float opacity_t = smoothstep(0.0, antialiased_blur, outer_df);\\n  if(u_stroke_width <0.01 ) {\\n     gl_FragColor = v_color * opacity_t;\\n     return;\\n  }\\n  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\\n    antialiased_blur,\\n    0.0,\\n    inner_df\\n  );\\n  vec4 strokeColor = u_stroke_color == vec4(0) ? v_color : u_stroke_color;\\n  float PI = 3.14159;\\n  float N_RINGS = 3.0;\\n  float FREQ = 1.0;\\n\\n  // gl_FragColor = v_color * color_t;\\n  // gl_FragColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), strokeColor * u_stroke_opacity, color_t);\\n  gl_FragColor = opacity_t * mix(vec4(v_color.rgb, v_color.a * u_opacity), strokeColor * u_stroke_opacity, color_t);\\n\\n  if(u_aimate.x == Animate) {\\n    float d = length(v_data.xy);\\n    float intensity = clamp(cos(d * PI), 0.0, 1.0) * clamp(cos(2.0 * PI * (d * 2.0 * u_aimate.z - u_aimate.y * u_time)), 0.0, 1.0);\\n    gl_FragColor = vec4(gl_FragColor.xyz * intensity, intensity);\\n  }\\n\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\nvar pointFillVert = \"attribute vec4 a_Color;\\nattribute vec3 a_Position;\\nattribute vec2 a_Extrude;\\nattribute float a_Size;\\nattribute float a_Shape;\\nuniform mat4 u_ModelMatrix;\\n\\nuniform float u_stroke_width : 2;\\n\\nvarying vec4 v_data;\\nvarying vec4 v_color;\\nvarying float v_radius;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  // unpack color(vec2)\\n  v_color = a_Color;\\n  vec2 extrude = a_Extrude;\\n\\n  float shape_type = a_Shape;\\n\\n  // radius(16-bit)\\n  v_radius = a_Size;\\n\\n  vec2 offset = project_pixel(extrude * (a_Size + u_stroke_width));\\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\\n\\n  // TODO: billboard\\n  // anti-alias\\n  float antialiasblur = 1.0 / (a_Size + u_stroke_width);\\n\\n  // construct point coords\\n  v_data = vec4(extrude, antialiasblur,shape_type);\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\n\nvar FillModel = function (_BaseModel) {\n  _inherits(FillModel, _BaseModel);\n\n  function FillModel() {\n    _classCallCheck(this, FillModel);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(FillModel).apply(this, arguments));\n  }\n\n  _createClass(FillModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          _ref$opacity = _ref.opacity,\n          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,\n          _ref$stroke = _ref.stroke,\n          stroke = _ref$stroke === void 0 ? 'rgb(0,0,0,0)' : _ref$stroke,\n          _ref$strokeWidth = _ref.strokeWidth,\n          strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth;\n\n      return {\n        u_opacity: opacity,\n        u_stroke_width: strokeWidth,\n        u_stroke_color: rgb2arr(stroke)\n      };\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      var _ref2 = this.layer.getLayerConfig(),\n          animateOption = _ref2.animateOption;\n\n      return {\n        u_aimate: this.animateOption2Array(animateOption),\n        u_time: this.layer.getLayerAnimateTime()\n      };\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute() {\n      return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      return [this.layer.buildLayerModel({\n        moduleName: 'pointfill',\n        vertexShader: pointFillVert,\n        fragmentShader: pointFillFrag,\n        triangulation: PointFillTriangulation,\n        depth: {\n          enable: false\n        }\n      })];\n    }\n  }, {\n    key: \"animateOption2Array\",\n    value: function animateOption2Array(option) {\n      return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      var _this = this;\n\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'extrude',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Extrude',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 2,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var extrude = [-1, -1, 1, -1, 1, 1, -1, 1];\n            var extrudeIndex = attributeIdx % 4 * 2;\n            return [extrude[extrudeIndex], extrude[extrudeIndex + 1]];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var size = feature.size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'shape',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Shape',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var _feature$shape = feature.shape,\n                shape = _feature$shape === void 0 ? 2 : _feature$shape;\n\n            var shape2d = _this.layer.getLayerConfig().shape2d;\n\n            var shapeIndex = shape2d.indexOf(shape);\n            return [shapeIndex];\n          }\n        }\n      });\n    }\n  }]);\n\n  return FillModel;\n}(BaseModel);\n\nexport { FillModel as default };","map":{"version":3,"sources":["../../../src/point/models/fill.ts"],"names":["FillModel","BaseModel","opacity","stroke","strokeWidth","u_opacity","u_stroke_width","u_stroke_color","rgb2arr","animateOption","u_aimate","u_time","moduleName","vertexShader","fragmentShader","triangulation","depth","enable","option","name","type","AttributeType","descriptor","buffer","usage","gl","data","FLOAT","size","update","extrude","extrudeIndex","attributeIdx","feature","Array","shape","shape2d","shapeIndex"],"mappings":"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","sourcesContent":["import {\n  AttributeType,\n  gl,\n  IAnimateOption,\n  IAttribute,\n  IElements,\n  IEncodeFeature,\n  ILayerConfig,\n  IModel,\n  IModelUniform,\n} from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nimport { PointFillTriangulation } from '../../core/triangulation';\nimport pointFillFrag from '../shaders/fill_frag.glsl';\nimport pointFillVert from '../shaders/fill_vert.glsl';\ninterface IPointLayerStyleOptions {\n  opacity: number;\n  strokeWidth: number;\n  stroke: string;\n}\nexport default class FillModel extends BaseModel {\n  public getUninforms(): IModelUniform {\n    const {\n      opacity = 1,\n      stroke = 'rgb(0,0,0,0)',\n      strokeWidth = 1,\n    } = this.layer.getLayerConfig() as IPointLayerStyleOptions;\n    return {\n      u_opacity: opacity,\n      u_stroke_width: strokeWidth,\n      u_stroke_color: rgb2arr(stroke),\n    };\n  }\n  public getAnimateUniforms(): IModelUniform {\n    const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;\n    return {\n      u_aimate: this.animateOption2Array(animateOption as IAnimateOption),\n      u_time: this.layer.getLayerAnimateTime(),\n    };\n  }\n\n  public getAttribute(): {\n    attributes: {\n      [attributeName: string]: IAttribute;\n    };\n    elements: IElements;\n  } {\n    return this.styleAttributeService.createAttributesAndIndices(\n      this.layer.getEncodedData(),\n      PointFillTriangulation,\n    );\n  }\n  public buildModels(): IModel[] {\n    return [\n      this.layer.buildLayerModel({\n        moduleName: 'pointfill',\n        vertexShader: pointFillVert,\n        fragmentShader: pointFillFrag,\n        triangulation: PointFillTriangulation,\n        depth: { enable: false },\n      }),\n    ];\n  }\n  protected animateOption2Array(option: IAnimateOption): number[] {\n    return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];\n  }\n  protected registerBuiltinAttributes() {\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'extrude',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Extrude',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 2,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const extrude = [-1, -1, 1, -1, 1, 1, -1, 1];\n          const extrudeIndex = (attributeIdx % 4) * 2;\n          return [extrude[extrudeIndex], extrude[extrudeIndex + 1]];\n        },\n      },\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 1,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const { size } = feature;\n          return Array.isArray(size) ? [size[0]] : [size as number];\n        },\n      },\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'shape',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Shape',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 1,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const { shape = 2 } = feature;\n          const shape2d = this.layer.getLayerConfig().shape2d as string[];\n          const shapeIndex = shape2d.indexOf(shape as string);\n          return [shapeIndex];\n        },\n      },\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}