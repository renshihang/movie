{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _merge from \"lodash/merge\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { TYPES } from '@antv/l7-core';\nimport { bindAll, DOM, Satistics } from '@antv/l7-utils';\nimport { EventEmitter } from 'eventemitter3';\nimport Supercluster from 'supercluster';\nimport Marker from './marker';\n\nvar MarkerLayer = function (_EventEmitter) {\n  _inherits(MarkerLayer, _EventEmitter);\n\n  function MarkerLayer(option) {\n    var _this$markerLayerOpti;\n\n    var _this;\n\n    _classCallCheck(this, MarkerLayer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MarkerLayer).call(this));\n    _this.markers = [];\n    _this.markerLayerOption = void 0;\n    _this.clusterIndex = void 0;\n    _this.points = [];\n    _this.clusterMarkers = [];\n    _this.mapsService = void 0;\n    _this.scene = void 0;\n    _this.zoom = void 0;\n    _this.markerLayerOption = _merge(_this.getDefault(), option);\n    bindAll(['update'], _assertThisInitialized(_this));\n    _this.zoom = ((_this$markerLayerOpti = _this.markerLayerOption.clusterOption) === null || _this$markerLayerOpti === void 0 ? void 0 : _this$markerLayerOpti.zoom) || -99;\n    return _this;\n  }\n\n  _createClass(MarkerLayer, [{\n    key: \"getDefault\",\n    value: function getDefault() {\n      return {\n        cluster: false,\n        clusterOption: {\n          radius: 80,\n          maxZoom: 20,\n          minZoom: 0,\n          zoom: -99,\n          style: {},\n          className: '',\n          element: this.generateElement\n        }\n      };\n    }\n  }, {\n    key: \"addTo\",\n    value: function addTo(scene) {\n      this.scene = scene;\n      this.mapsService = scene.get(TYPES.IMapService);\n\n      if (this.markerLayerOption.cluster) {\n        this.initCluster();\n        this.update();\n        this.mapsService.on('zoom', this.update);\n        this.mapsService.on('zoomchange', this.update);\n      }\n\n      this.addMarkers();\n      return this;\n    }\n  }, {\n    key: \"addMarker\",\n    value: function addMarker(marker) {\n      var cluster = this.markerLayerOption.cluster;\n\n      if (cluster) {\n        this.addPoint(marker, this.markers.length);\n      }\n\n      this.markers.push(marker);\n    }\n  }, {\n    key: \"removeMarker\",\n    value: function removeMarker(marker) {\n      this.markers.indexOf(marker);\n      var markerIndex = this.markers.indexOf(marker);\n\n      if (markerIndex > -1) {\n        this.markers.splice(markerIndex, 1);\n      }\n    }\n  }, {\n    key: \"getMarkers\",\n    value: function getMarkers() {\n      var cluster = this.markerLayerOption.cluster;\n      return cluster ? this.clusterMarkers : this.markers;\n    }\n  }, {\n    key: \"addMarkers\",\n    value: function addMarkers() {\n      var _this2 = this;\n\n      this.getMarkers().forEach(function (marker) {\n        marker.addTo(_this2.scene);\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.markers.forEach(function (marker) {\n        marker.remove();\n      });\n      this.mapsService.off('zoom', this.update);\n      this.mapsService.off('zoomchange', this.update);\n      this.markers = [];\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.clear();\n      this.removeAllListeners();\n    }\n  }, {\n    key: \"addPoint\",\n    value: function addPoint(marker, id) {\n      var _marker$getLnglat = marker.getLnglat(),\n          lng = _marker$getLnglat.lng,\n          lat = _marker$getLnglat.lat;\n\n      var feature = {\n        geometry: {\n          type: 'Point',\n          coordinates: [lng, lat]\n        },\n        properties: _objectSpread({}, marker.getExtData(), {\n          marker_id: id\n        })\n      };\n      this.points.push(feature);\n    }\n  }, {\n    key: \"initCluster\",\n    value: function initCluster() {\n      if (!this.markerLayerOption.cluster) {\n        return;\n      }\n\n      var _ref = this.markerLayerOption.clusterOption,\n          radius = _ref.radius,\n          _ref$minZoom = _ref.minZoom,\n          minZoom = _ref$minZoom === void 0 ? 0 : _ref$minZoom,\n          maxZoom = _ref.maxZoom;\n      this.clusterIndex = new Supercluster({\n        radius: radius,\n        minZoom: minZoom,\n        maxZoom: maxZoom\n      });\n      this.clusterIndex.load(this.points);\n    }\n  }, {\n    key: \"getClusterMarker\",\n    value: function getClusterMarker(zoom) {\n      var _this3 = this;\n\n      var clusterPoint = this.clusterIndex.getClusters([-180, -85, 180, 85], zoom);\n      this.clusterMarkers.forEach(function (marker) {\n        marker.remove();\n      });\n      this.clusterMarkers = [];\n      clusterPoint.forEach(function (feature) {\n        var _feature$properties;\n\n        var _this3$markerLayerOpt = _this3.markerLayerOption.clusterOption,\n            field = _this3$markerLayerOpt.field,\n            method = _this3$markerLayerOpt.method;\n\n        if (feature.properties && ((_feature$properties = feature.properties) === null || _feature$properties === void 0 ? void 0 : _feature$properties.cluster_id)) {\n          var _feature$properties2;\n\n          var clusterData = _this3.getLeaves((_feature$properties2 = feature.properties) === null || _feature$properties2 === void 0 ? void 0 : _feature$properties2.cluster_id);\n\n          feature.properties.clusterData = clusterData;\n\n          if (field && method) {\n            var columnData = clusterData === null || clusterData === void 0 ? void 0 : clusterData.map(function (item) {\n              var data = _defineProperty({}, field, item.properties[field]);\n\n              return data;\n            });\n            var column = Satistics.getColumn(columnData, field);\n            var stat = Satistics.getSatByColumn(method, column);\n            var fieldName = 'point_' + method;\n            feature.properties[fieldName] = stat;\n          }\n        }\n\n        var marker = feature.properties && feature.properties.hasOwnProperty('point_count') ? _this3.clusterMarker(feature) : _this3.normalMarker(feature);\n\n        _this3.clusterMarkers.push(marker);\n\n        marker.addTo(_this3.scene);\n      });\n    }\n  }, {\n    key: \"getLeaves\",\n    value: function getLeaves(clusterId) {\n      var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      if (!clusterId) {\n        return null;\n      }\n\n      return this.clusterIndex.getLeaves(clusterId, limit, offset);\n    }\n  }, {\n    key: \"clusterMarker\",\n    value: function clusterMarker(feature) {\n      var clusterOption = this.markerLayerOption.clusterOption;\n      var _ref2 = clusterOption,\n          element = _ref2.element;\n      var marker = new Marker({\n        element: element(feature)\n      }).setLnglat({\n        lng: feature.geometry.coordinates[0],\n        lat: feature.geometry.coordinates[1]\n      });\n      return marker;\n    }\n  }, {\n    key: \"normalMarker\",\n    value: function normalMarker(feature) {\n      var marker_id = feature.properties.marker_id;\n      return marker_id ? new Marker().setLnglat({\n        lng: feature.geometry.coordinates[0],\n        lat: feature.geometry.coordinates[1]\n      }) : this.markers[marker_id];\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var zoom = this.mapsService.getZoom();\n\n      if (Math.abs(zoom - this.zoom) > 1) {\n        this.getClusterMarker(Math.floor(zoom));\n        this.zoom = Math.floor(zoom);\n      }\n    }\n  }, {\n    key: \"generateElement\",\n    value: function generateElement(feature) {\n      var el = DOM.create('div', 'l7-marker-cluster');\n      var label = DOM.create('div', '', el);\n      var span = DOM.create('span', '', label);\n      span.textContent = feature.properties.point_count;\n      return el;\n    }\n  }]);\n\n  return MarkerLayer;\n}(EventEmitter);\n\nexport { MarkerLayer as default };","map":{"version":3,"sources":["../src/markerlayer.ts"],"names":["MarkerLayer","EventEmitter","markers","markerLayerOption","clusterIndex","points","clusterMarkers","mapsService","scene","zoom","bindAll","cluster","clusterOption","radius","maxZoom","minZoom","style","className","element","generateElement","TYPES","marker","markerIndex","id","lng","lat","feature","geometry","type","coordinates","properties","marker_id","clusterPoint","field","method","clusterData","columnData","data","item","column","Satistics","stat","fieldName","clusterId","limit","Infinity","offset","Math","el","DOM","label","span"],"mappings":"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","sourcesContent":["import { IMapService, IMarker, TYPES } from '@antv/l7-core';\nimport { bindAll, DOM, Satistics } from '@antv/l7-utils';\nimport { EventEmitter } from 'eventemitter3';\nimport { Container } from 'inversify';\nimport { merge } from 'lodash';\nimport Supercluster from 'supercluster';\nimport Marker from './marker';\ntype CallBack = (...args: any[]) => any;\ninterface IMarkerStyleOption {\n  element: CallBack;\n  style: { [key: string]: any } | CallBack;\n  className: string;\n  field?: string;\n  method?: 'sum' | 'max' | 'min' | 'mean';\n  radius: number;\n  maxZoom: number;\n  minZoom: number;\n  zoom: number;\n}\n\ninterface IMarkerLayerOption {\n  cluster: boolean;\n  clusterOption: Partial<IMarkerStyleOption>;\n}\n\ninterface IPointFeature {\n  geometry: {\n    type: 'Point';\n    coordinates: [number, number];\n  };\n  properties: any;\n}\nexport default class MarkerLayer extends EventEmitter {\n  private markers: IMarker[] = [];\n  private markerLayerOption: IMarkerLayerOption;\n  private clusterIndex: Supercluster;\n  private points: IPointFeature[] = [];\n  private clusterMarkers: IMarker[] = [];\n  private mapsService: IMapService<unknown>;\n  private scene: Container;\n  private zoom: number;\n\n  constructor(option?: Partial<IMarkerLayerOption>) {\n    super();\n    this.markerLayerOption = merge(this.getDefault(), option);\n    bindAll(['update'], this);\n    this.zoom = this.markerLayerOption.clusterOption?.zoom || -99;\n  }\n  public getDefault() {\n    return {\n      cluster: false,\n      clusterOption: {\n        radius: 80,\n        maxZoom: 20,\n        minZoom: 0,\n        zoom: -99,\n        style: {},\n        className: '',\n        element: this.generateElement,\n      },\n    };\n  }\n  public addTo(scene: Container) {\n    // this.remove();\n    this.scene = scene;\n    this.mapsService = scene.get<IMapService>(TYPES.IMapService);\n    if (this.markerLayerOption.cluster) {\n      this.initCluster();\n      this.update();\n      this.mapsService.on('zoom', this.update);\n      this.mapsService.on('zoomchange', this.update);\n    }\n    this.addMarkers();\n    return this;\n  }\n  public addMarker(marker: IMarker) {\n    const cluster = this.markerLayerOption.cluster;\n    if (cluster) {\n      this.addPoint(marker, this.markers.length);\n    }\n    this.markers.push(marker);\n  }\n\n  public removeMarker(marker: IMarker) {\n    this.markers.indexOf(marker);\n    const markerIndex = this.markers.indexOf(marker);\n    if (markerIndex > -1) {\n      this.markers.splice(markerIndex, 1);\n    }\n  }\n\n  public getMarkers() {\n    const cluster = this.markerLayerOption.cluster;\n    return cluster ? this.clusterMarkers : this.markers;\n  }\n\n  public addMarkers() {\n    this.getMarkers().forEach((marker: IMarker) => {\n      marker.addTo(this.scene);\n    });\n  }\n  public clear() {\n    this.markers.forEach((marker: IMarker) => {\n      marker.remove();\n    });\n    this.mapsService.off('zoom', this.update);\n    this.mapsService.off('zoomchange', this.update);\n    this.markers = [];\n  }\n\n  public destroy() {\n    this.clear();\n    this.removeAllListeners();\n  }\n\n  private addPoint(marker: IMarker, id: number) {\n    const { lng, lat } = marker.getLnglat();\n    const feature: IPointFeature = {\n      geometry: {\n        type: 'Point',\n        coordinates: [lng, lat],\n      },\n      properties: {\n        ...marker.getExtData(),\n        marker_id: id,\n      },\n    };\n    this.points.push(feature);\n  }\n\n  private initCluster() {\n    if (!this.markerLayerOption.cluster) {\n      return;\n    }\n    const { radius, minZoom = 0, maxZoom } = this.markerLayerOption\n      .clusterOption as IMarkerStyleOption;\n    this.clusterIndex = new Supercluster({\n      radius,\n      minZoom,\n      maxZoom,\n    });\n    // @ts-ignore\n    this.clusterIndex.load(this.points);\n  }\n\n  private getClusterMarker(zoom: number) {\n    const clusterPoint = this.clusterIndex.getClusters(\n      [-180, -85, 180, 85],\n      zoom,\n    );\n    this.clusterMarkers.forEach((marker: IMarker) => {\n      marker.remove();\n    });\n    this.clusterMarkers = [];\n    clusterPoint.forEach((feature) => {\n      const { field, method } = this.markerLayerOption.clusterOption;\n      // 处理聚合数据\n      if (feature.properties && feature.properties?.cluster_id) {\n        const clusterData = this.getLeaves(feature.properties?.cluster_id);\n        feature.properties.clusterData = clusterData;\n        if (field && method) {\n          const columnData = clusterData?.map((item) => {\n            const data = {\n              [field]: item.properties[field],\n            };\n            return data;\n          });\n          const column = Satistics.getColumn(columnData as any, field);\n          const stat = Satistics.getSatByColumn(method, column);\n          const fieldName = 'point_' + method;\n          feature.properties[fieldName] = stat;\n        }\n      }\n      const marker =\n        feature.properties && feature.properties.hasOwnProperty('point_count')\n          ? this.clusterMarker(feature)\n          : this.normalMarker(feature);\n\n      this.clusterMarkers.push(marker);\n      marker.addTo(this.scene);\n    });\n  }\n  private getLeaves(\n    clusterId: number,\n    limit: number = Infinity,\n    offset: number = 0,\n  ) {\n    if (!clusterId) {\n      return null;\n    }\n    return this.clusterIndex.getLeaves(clusterId, limit, offset);\n  }\n  private clusterMarker(feature: any) {\n    const clusterOption = this.markerLayerOption.clusterOption;\n\n    const { element } = clusterOption as IMarkerStyleOption;\n    const marker = new Marker({\n      element: element(feature),\n    }).setLnglat({\n      lng: feature.geometry.coordinates[0],\n      lat: feature.geometry.coordinates[1],\n    });\n    return marker;\n  }\n  private normalMarker(feature: any) {\n    const marker_id = feature.properties.marker_id;\n    return marker_id\n      ? new Marker().setLnglat({\n          lng: feature.geometry.coordinates[0],\n          lat: feature.geometry.coordinates[1],\n        })\n      : this.markers[marker_id];\n  }\n  private update() {\n    const zoom = this.mapsService.getZoom();\n    if (Math.abs(zoom - this.zoom) > 1) {\n      this.getClusterMarker(Math.floor(zoom));\n      this.zoom = Math.floor(zoom);\n    }\n  }\n  private generateElement(feature: any) {\n    const el = DOM.create('div', 'l7-marker-cluster');\n    const label = DOM.create('div', '', el);\n    const span = DOM.create('span', '', label);\n    span.textContent = feature.properties.point_count;\n    // if (className !== '') {\n    //   DOM.addClass(el, className);\n    // }\n    // span.textContent = feature.properties.point_count;\n    // const elStyle = isFunction(style)\n    //   ? style(feature.properties.point_count)\n    //   : style;\n\n    // Object.keys(elStyle).forEach((key: string) => {\n    //   // @ts-ignore\n    //   el.style[key] = elStyle[key];\n    // });\n    return el;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}