{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _isTypedArray from \"lodash/isTypedArray\";\nimport _isPlainObject from \"lodash/isPlainObject\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { gl } from '@antv/l7-core';\nimport { blendEquationMap, blendFuncMap, cullFaceMap, depthFuncMap, primitiveMap, stencilFuncMap, stencilOpMap } from './constants';\n\nvar ReglModel = function () {\n  function ReglModel(reGl, options) {\n    _classCallCheck(this, ReglModel);\n\n    this.reGl = void 0;\n    this.drawCommand = void 0;\n    this.uniforms = {};\n    this.reGl = reGl;\n    var vs = options.vs,\n        fs = options.fs,\n        attributes = options.attributes,\n        uniforms = options.uniforms,\n        primitive = options.primitive,\n        count = options.count,\n        elements = options.elements,\n        depth = options.depth,\n        blend = options.blend,\n        stencil = options.stencil,\n        cull = options.cull,\n        instances = options.instances;\n    var reglUniforms = {};\n\n    if (uniforms) {\n      this.uniforms = this.extractUniforms(uniforms);\n      Object.keys(uniforms).forEach(function (uniformName) {\n        reglUniforms[uniformName] = reGl.prop(uniformName);\n      });\n    }\n\n    var reglAttributes = {};\n    Object.keys(attributes).forEach(function (name) {\n      reglAttributes[name] = attributes[name].get();\n    });\n    var drawParams = {\n      attributes: reglAttributes,\n      frag: fs,\n      uniforms: reglUniforms,\n      vert: vs,\n      primitive: primitiveMap[primitive === undefined ? gl.TRIANGLES : primitive]\n    };\n\n    if (instances) {\n      drawParams.instances = instances;\n    }\n\n    if (count) {\n      drawParams.count = count;\n    }\n\n    if (elements) {\n      drawParams.elements = elements.get();\n    }\n\n    this.initDepthDrawParams({\n      depth: depth\n    }, drawParams);\n    this.initBlendDrawParams({\n      blend: blend\n    }, drawParams);\n    this.initStencilDrawParams({\n      stencil: stencil\n    }, drawParams);\n    this.initCullDrawParams({\n      cull: cull\n    }, drawParams);\n    this.drawCommand = reGl(drawParams);\n  }\n\n  _createClass(ReglModel, [{\n    key: \"addUniforms\",\n    value: function addUniforms(uniforms) {\n      this.uniforms = _objectSpread({}, this.uniforms, {}, this.extractUniforms(uniforms));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(options) {\n      var uniforms = _objectSpread({}, this.uniforms, {}, this.extractUniforms(options.uniforms || {}));\n\n      var reglDrawProps = {};\n      Object.keys(uniforms).forEach(function (uniformName) {\n        var type = _typeof(uniforms[uniformName]);\n\n        if (type === 'boolean' || type === 'number' || Array.isArray(uniforms[uniformName]) || uniforms[uniformName].BYTES_PER_ELEMENT) {\n          reglDrawProps[uniformName] = uniforms[uniformName];\n        } else {\n          reglDrawProps[uniformName] = uniforms[uniformName].get();\n        }\n      });\n      this.drawCommand(reglDrawProps);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {}\n  }, {\n    key: \"initDepthDrawParams\",\n    value: function initDepthDrawParams(_ref, drawParams) {\n      var depth = _ref.depth;\n\n      if (depth) {\n        drawParams.depth = {\n          enable: depth.enable === undefined ? true : !!depth.enable,\n          mask: depth.mask === undefined ? true : !!depth.mask,\n          func: depthFuncMap[depth.func || gl.LESS],\n          range: depth.range || [0, 1]\n        };\n      }\n    }\n  }, {\n    key: \"initBlendDrawParams\",\n    value: function initBlendDrawParams(_ref2, drawParams) {\n      var blend = _ref2.blend;\n\n      if (blend) {\n        var enable = blend.enable,\n            func = blend.func,\n            equation = blend.equation,\n            _blend$color = blend.color,\n            color = _blend$color === void 0 ? [0, 0, 0, 0] : _blend$color;\n        drawParams.blend = {\n          enable: !!enable,\n          func: {\n            srcRGB: blendFuncMap[func && func.srcRGB || gl.SRC_ALPHA],\n            srcAlpha: blendFuncMap[func && func.srcAlpha || gl.SRC_ALPHA],\n            dstRGB: blendFuncMap[func && func.dstRGB || gl.ONE_MINUS_SRC_ALPHA],\n            dstAlpha: blendFuncMap[func && func.dstAlpha || gl.ONE_MINUS_SRC_ALPHA]\n          },\n          equation: {\n            rgb: blendEquationMap[equation && equation.rgb || gl.FUNC_ADD],\n            alpha: blendEquationMap[equation && equation.alpha || gl.FUNC_ADD]\n          },\n          color: color\n        };\n      }\n    }\n  }, {\n    key: \"initStencilDrawParams\",\n    value: function initStencilDrawParams(_ref3, drawParams) {\n      var stencil = _ref3.stencil;\n\n      if (stencil) {\n        var enable = stencil.enable,\n            _stencil$mask = stencil.mask,\n            mask = _stencil$mask === void 0 ? -1 : _stencil$mask,\n            _stencil$func = stencil.func,\n            func = _stencil$func === void 0 ? {\n          cmp: gl.ALWAYS,\n          ref: 0,\n          mask: -1\n        } : _stencil$func,\n            _stencil$opFront = stencil.opFront,\n            opFront = _stencil$opFront === void 0 ? {\n          fail: gl.KEEP,\n          zfail: gl.KEEP,\n          zpass: gl.KEEP\n        } : _stencil$opFront,\n            _stencil$opBack = stencil.opBack,\n            opBack = _stencil$opBack === void 0 ? {\n          fail: gl.KEEP,\n          zfail: gl.KEEP,\n          zpass: gl.KEEP\n        } : _stencil$opBack;\n        drawParams.stencil = {\n          enable: !!enable,\n          mask: mask,\n          func: _objectSpread({}, func, {\n            cmp: stencilFuncMap[func.cmp]\n          }),\n          opFront: {\n            fail: stencilOpMap[opFront.fail],\n            zfail: stencilOpMap[opFront.zfail],\n            zpass: stencilOpMap[opFront.zpass]\n          },\n          opBack: {\n            fail: stencilOpMap[opBack.fail],\n            zfail: stencilOpMap[opBack.zfail],\n            zpass: stencilOpMap[opBack.zpass]\n          }\n        };\n      }\n    }\n  }, {\n    key: \"initCullDrawParams\",\n    value: function initCullDrawParams(_ref4, drawParams) {\n      var cull = _ref4.cull;\n\n      if (cull) {\n        var enable = cull.enable,\n            _cull$face = cull.face,\n            face = _cull$face === void 0 ? gl.BACK : _cull$face;\n        drawParams.cull = {\n          enable: !!enable,\n          face: cullFaceMap[face]\n        };\n      }\n    }\n  }, {\n    key: \"extractUniforms\",\n    value: function extractUniforms(uniforms) {\n      var _this = this;\n\n      var extractedUniforms = {};\n      Object.keys(uniforms).forEach(function (uniformName) {\n        _this.extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, '');\n      });\n      return extractedUniforms;\n    }\n  }, {\n    key: \"extractUniformsRecursively\",\n    value: function extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {\n      var _this2 = this;\n\n      if (uniformValue === null || typeof uniformValue === 'number' || typeof uniformValue === 'boolean' || Array.isArray(uniformValue) && typeof uniformValue[0] === 'number' || _isTypedArray(uniformValue) || uniformValue === '' || 'resize' in uniformValue) {\n        uniforms[\"\".concat(prefix && prefix + '.').concat(uniformName)] = uniformValue;\n        return;\n      }\n\n      if (_isPlainObject(uniformValue)) {\n        Object.keys(uniformValue).forEach(function (childName) {\n          _this2.extractUniformsRecursively(childName, uniformValue[childName], uniforms, \"\".concat(prefix && prefix + '.').concat(uniformName));\n        });\n      }\n\n      if (Array.isArray(uniformValue)) {\n        uniformValue.forEach(function (child, idx) {\n          Object.keys(child).forEach(function (childName) {\n            _this2.extractUniformsRecursively(childName, child[childName], uniforms, \"\".concat(prefix && prefix + '.').concat(uniformName, \"[\").concat(idx, \"]\"));\n          });\n        });\n      }\n    }\n  }]);\n\n  return ReglModel;\n}();\n\nexport { ReglModel as default };","map":{"version":3,"sources":["../../src/regl/ReglModel.ts"],"names":["ReglModel","reGl","drawCommand","uniforms","vs","fs","attributes","primitive","count","elements","depth","blend","stencil","cull","instances","options","reglUniforms","Object","reglAttributes","drawParams","frag","vert","primitiveMap","gl","reglDrawProps","type","Array","enable","mask","func","depthFuncMap","range","equation","color","srcRGB","blendFuncMap","srcAlpha","dstRGB","dstAlpha","rgb","blendEquationMap","alpha","cmp","ref","opFront","fail","zfail","zpass","KEEP","opBack","stencilFuncMap","stencilOpMap","face","cullFaceMap","extractedUniforms","uniformName","uniformValue","prefix","child"],"mappings":"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","sourcesContent":["import {\n  gl,\n  IModel,\n  IModelDrawOptions,\n  IModelInitializationOptions,\n  IUniform,\n} from '@antv/l7-core';\nimport { isPlainObject, isTypedArray } from 'lodash';\nimport regl from 'regl';\nimport {\n  blendEquationMap,\n  blendFuncMap,\n  cullFaceMap,\n  depthFuncMap,\n  primitiveMap,\n  stencilFuncMap,\n  stencilOpMap,\n} from './constants';\nimport ReglAttribute from './ReglAttribute';\nimport ReglElements from './ReglElements';\nimport ReglFramebuffer from './ReglFramebuffer';\nimport ReglTexture2D from './ReglTexture2D';\n\n/**\n * adaptor for regl.DrawCommand\n */\nexport default class ReglModel implements IModel {\n  private reGl: regl.Regl;\n  private drawCommand: regl.DrawCommand;\n  private uniforms: {\n    [key: string]: IUniform;\n  } = {};\n\n  constructor(reGl: regl.Regl, options: IModelInitializationOptions) {\n    this.reGl = reGl;\n    const {\n      vs,\n      fs,\n      attributes,\n      uniforms,\n      primitive,\n      count,\n      elements,\n      depth,\n      blend,\n      stencil,\n      cull,\n      instances,\n    } = options;\n    const reglUniforms: { [key: string]: IUniform } = {};\n    if (uniforms) {\n      this.uniforms = this.extractUniforms(uniforms);\n      Object.keys(uniforms).forEach((uniformName) => {\n        // use regl prop API\n        // @ts-ignore\n        reglUniforms[uniformName] = reGl.prop(uniformName);\n      });\n    }\n\n    const reglAttributes: { [key: string]: regl.Attribute } = {};\n    Object.keys(attributes).forEach((name: string) => {\n      reglAttributes[name] = (attributes[name] as ReglAttribute).get();\n    });\n    const drawParams: regl.DrawConfig = {\n      attributes: reglAttributes,\n      frag: fs,\n      uniforms: reglUniforms,\n      vert: vs,\n      primitive:\n        primitiveMap[primitive === undefined ? gl.TRIANGLES : primitive],\n    };\n    if (instances) {\n      drawParams.instances = instances;\n    }\n\n    // elements 中可能包含 count，此时不应传入\n    if (count) {\n      drawParams.count = count;\n    }\n\n    if (elements) {\n      drawParams.elements = (elements as ReglElements).get();\n    }\n\n    this.initDepthDrawParams({ depth }, drawParams);\n    this.initBlendDrawParams({ blend }, drawParams);\n    this.initStencilDrawParams({ stencil }, drawParams);\n    this.initCullDrawParams({ cull }, drawParams);\n    this.drawCommand = reGl(drawParams);\n  }\n\n  public addUniforms(uniforms: { [key: string]: IUniform }) {\n    this.uniforms = {\n      ...this.uniforms,\n      ...this.extractUniforms(uniforms),\n    };\n  }\n\n  public draw(options: IModelDrawOptions) {\n    const uniforms: {\n      [key: string]: IUniform;\n    } = {\n      ...this.uniforms,\n      ...this.extractUniforms(options.uniforms || {}),\n    };\n    const reglDrawProps: {\n      [key: string]:\n        | regl.Framebuffer\n        | regl.Texture2D\n        | number\n        | number[]\n        | boolean;\n    } = {};\n\n    Object.keys(uniforms).forEach((uniformName: string) => {\n      const type = typeof uniforms[uniformName];\n      if (\n        type === 'boolean' ||\n        type === 'number' ||\n        Array.isArray(uniforms[uniformName]) ||\n        // @ts-ignore\n        uniforms[uniformName].BYTES_PER_ELEMENT\n      ) {\n        reglDrawProps[uniformName] = uniforms[uniformName] as\n          | number\n          | number[]\n          | boolean;\n      } else {\n        reglDrawProps[uniformName] = (uniforms[uniformName] as\n          | ReglFramebuffer\n          | ReglTexture2D).get();\n      }\n    });\n    this.drawCommand(reglDrawProps);\n  }\n\n  public destroy() {\n    // don't need do anything since we will call `rendererService.cleanup()`\n  }\n\n  /**\n   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#depth-buffer\n   */\n  private initDepthDrawParams(\n    { depth }: Pick<IModelInitializationOptions, 'depth'>,\n    drawParams: regl.DrawConfig,\n  ) {\n    if (depth) {\n      drawParams.depth = {\n        enable: depth.enable === undefined ? true : !!depth.enable,\n        mask: depth.mask === undefined ? true : !!depth.mask,\n        func: depthFuncMap[depth.func || gl.LESS],\n        range: depth.range || [0, 1],\n      };\n    }\n  }\n\n  /**\n   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#blending\n   */\n  private initBlendDrawParams(\n    { blend }: Pick<IModelInitializationOptions, 'blend'>,\n    drawParams: regl.DrawConfig,\n  ) {\n    if (blend) {\n      const { enable, func, equation, color = [0, 0, 0, 0] } = blend;\n      // @ts-ignore\n      drawParams.blend = {\n        enable: !!enable,\n        func: {\n          srcRGB: blendFuncMap[(func && func.srcRGB) || gl.SRC_ALPHA],\n          srcAlpha: blendFuncMap[(func && func.srcAlpha) || gl.SRC_ALPHA],\n          dstRGB: blendFuncMap[(func && func.dstRGB) || gl.ONE_MINUS_SRC_ALPHA],\n          dstAlpha:\n            blendFuncMap[(func && func.dstAlpha) || gl.ONE_MINUS_SRC_ALPHA],\n        },\n        equation: {\n          rgb: blendEquationMap[(equation && equation.rgb) || gl.FUNC_ADD],\n          alpha: blendEquationMap[(equation && equation.alpha) || gl.FUNC_ADD],\n        },\n        color,\n      };\n    }\n  }\n\n  /**\n   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil\n   */\n  private initStencilDrawParams(\n    { stencil }: Pick<IModelInitializationOptions, 'stencil'>,\n    drawParams: regl.DrawConfig,\n  ) {\n    if (stencil) {\n      const {\n        enable,\n        mask = -1,\n        func = {\n          cmp: gl.ALWAYS,\n          ref: 0,\n          mask: -1,\n        },\n        opFront = {\n          fail: gl.KEEP,\n          zfail: gl.KEEP,\n          zpass: gl.KEEP,\n        },\n        opBack = {\n          fail: gl.KEEP,\n          zfail: gl.KEEP,\n          zpass: gl.KEEP,\n        },\n      } = stencil;\n      drawParams.stencil = {\n        enable: !!enable,\n        mask,\n        func: {\n          ...func,\n          cmp: stencilFuncMap[func.cmp],\n        },\n        opFront: {\n          fail: stencilOpMap[opFront.fail],\n          zfail: stencilOpMap[opFront.zfail],\n          zpass: stencilOpMap[opFront.zpass],\n        },\n        opBack: {\n          fail: stencilOpMap[opBack.fail],\n          zfail: stencilOpMap[opBack.zfail],\n          zpass: stencilOpMap[opBack.zpass],\n        },\n      };\n    }\n  }\n\n  /**\n   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling\n   */\n  private initCullDrawParams(\n    { cull }: Pick<IModelInitializationOptions, 'cull'>,\n    drawParams: regl.DrawConfig,\n  ) {\n    if (cull) {\n      const { enable, face = gl.BACK } = cull;\n      drawParams.cull = {\n        enable: !!enable,\n        face: cullFaceMap[face],\n      };\n    }\n  }\n\n  /**\n   * 考虑结构体命名, eg:\n   * a: { b: 1 }  ->  'a.b'\n   * a: [ { b: 1 } ] -> 'a[0].b'\n   */\n  private extractUniforms(uniforms: {\n    [key: string]: IUniform;\n  }): {\n    [key: string]: IUniform;\n  } {\n    const extractedUniforms = {};\n    Object.keys(uniforms).forEach((uniformName) => {\n      this.extractUniformsRecursively(\n        uniformName,\n        uniforms[uniformName],\n        extractedUniforms,\n        '',\n      );\n    });\n\n    return extractedUniforms;\n  }\n\n  private extractUniformsRecursively(\n    uniformName: string,\n    uniformValue: IUniform,\n    uniforms: {\n      [key: string]: IUniform;\n    },\n    prefix: string,\n  ) {\n    if (\n      uniformValue === null ||\n      typeof uniformValue === 'number' || // u_A: 1\n      typeof uniformValue === 'boolean' || // u_A: false\n      (Array.isArray(uniformValue) && typeof uniformValue[0] === 'number') || // u_A: [1, 2, 3]\n      isTypedArray(uniformValue) || // u_A: Float32Array\n      // @ts-ignore\n      uniformValue === '' ||\n      'resize' in uniformValue\n    ) {\n      uniforms[`${prefix && prefix + '.'}${uniformName}`] = uniformValue;\n      return;\n    }\n\n    // u_Struct.a.b.c\n    if (isPlainObject(uniformValue)) {\n      Object.keys(uniformValue).forEach((childName) => {\n        this.extractUniformsRecursively(\n          childName,\n          // @ts-ignore\n          uniformValue[childName],\n          uniforms,\n          `${prefix && prefix + '.'}${uniformName}`,\n        );\n      });\n    }\n\n    // u_Struct[0].a\n    if (Array.isArray(uniformValue)) {\n      uniformValue.forEach((child, idx) => {\n        Object.keys(child).forEach((childName) => {\n          this.extractUniformsRecursively(\n            childName,\n            // @ts-ignore\n            child[childName],\n            uniforms,\n            `${prefix && prefix + '.'}${uniformName}[${idx}]`,\n          );\n        });\n      });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}