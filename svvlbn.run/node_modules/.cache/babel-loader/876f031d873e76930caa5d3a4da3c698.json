{"ast":null,"code":"import _slicedToArray from \"/Users/renshihang/Desktop/svvlbn.run/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport KDBush from 'kdbush';\nconst defaultOptions = {\n  minZoom: 0,\n  // min zoom to generate clusters on\n  maxZoom: 16,\n  // max zoom level to cluster the points on\n  radius: 40,\n  // cluster radius in pixels\n  extent: 512,\n  // tile extent (radius is calculated relative to it)\n  nodeSize: 64,\n  // size of the KD-tree leaf node, affects performance\n  log: false,\n  // whether to log timing info\n  // a reduce function for calculating custom cluster properties\n  reduce: null,\n  // (accumulated, props) => { accumulated.sum += props.sum; }\n  // properties to use for individual points when running the reducer\n  map: props => props // props => ({sum: props.my_value})\n\n};\nexport default class Supercluster {\n  constructor(options) {\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n  }\n\n  load(points) {\n    const _this$options = this.options,\n          log = _this$options.log,\n          minZoom = _this$options.minZoom,\n          maxZoom = _this$options.maxZoom,\n          nodeSize = _this$options.nodeSize;\n    if (log) console.time('total time');\n    const timerId = `prepare ${points.length} points`;\n    if (log) console.time(timerId);\n    this.points = points; // generate a cluster object for each point and index input points into a KD-tree\n\n    let clusters = [];\n\n    for (let i = 0; i < points.length; i++) {\n      if (!points[i].geometry) continue;\n      clusters.push(createPointCluster(points[i], i));\n    }\n\n    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n    if (log) console.timeEnd(timerId); // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n\n    for (let z = maxZoom; z >= minZoom; z--) {\n      const now = +Date.now(); // create a new set of clusters for the zoom and index them with a KD-tree\n\n      clusters = this._cluster(clusters, z);\n      this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n      if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n    }\n\n    if (log) console.timeEnd('total time');\n    return this;\n  }\n\n  getClusters(bbox, zoom) {\n    let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    const minLat = Math.max(-90, Math.min(90, bbox[1]));\n    let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n    if (bbox[2] - bbox[0] >= 360) {\n      minLng = -180;\n      maxLng = 180;\n    } else if (minLng > maxLng) {\n      const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n      const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n      return easternHem.concat(westernHem);\n    }\n\n    const tree = this.trees[this._limitZoom(zoom)];\n\n    const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    const clusters = [];\n\n    for (const id of ids) {\n      const c = tree.points[id];\n      clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n    }\n\n    return clusters;\n  }\n\n  getChildren(clusterId) {\n    const originId = clusterId >> 5;\n    const originZoom = clusterId % 32;\n    const errorMsg = 'No cluster with the specified id.';\n    const index = this.trees[originZoom];\n    if (!index) throw new Error(errorMsg);\n    const origin = index.points[originId];\n    if (!origin) throw new Error(errorMsg);\n    const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    const ids = index.within(origin.x, origin.y, r);\n    const children = [];\n\n    for (const id of ids) {\n      const c = index.points[id];\n\n      if (c.parentId === clusterId) {\n        children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n      }\n    }\n\n    if (children.length === 0) throw new Error(errorMsg);\n    return children;\n  }\n\n  getLeaves(clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n    const leaves = [];\n\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n    return leaves;\n  }\n\n  getTile(z, x, y) {\n    const tree = this.trees[this._limitZoom(z)];\n\n    const z2 = Math.pow(2, z);\n    const _this$options2 = this.options,\n          extent = _this$options2.extent,\n          radius = _this$options2.radius;\n    const p = radius / extent;\n    const top = (y - p) / z2;\n    const bottom = (y + 1 + p) / z2;\n    const tile = {\n      features: []\n    };\n\n    this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);\n\n    if (x === 0) {\n      this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);\n    }\n\n    if (x === z2 - 1) {\n      this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);\n    }\n\n    return tile.features.length ? tile : null;\n  }\n\n  getClusterExpansionZoom(clusterId) {\n    let clusterZoom = clusterId % 32 - 1;\n\n    while (clusterZoom <= this.options.maxZoom) {\n      const children = this.getChildren(clusterId);\n      clusterZoom++;\n      if (children.length !== 1) break;\n      clusterId = children[0].properties.cluster_id;\n    }\n\n    return clusterZoom;\n  }\n\n  _appendLeaves(result, clusterId, limit, offset, skipped) {\n    const children = this.getChildren(clusterId);\n\n    for (const child of children) {\n      const props = child.properties;\n\n      if (props && props.cluster) {\n        if (skipped + props.point_count <= offset) {\n          // skip the whole cluster\n          skipped += props.point_count;\n        } else {\n          // enter the cluster\n          skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped); // exit the cluster\n        }\n      } else if (skipped < offset) {\n        // skip a single point\n        skipped++;\n      } else {\n        // add a single point\n        result.push(child);\n      }\n\n      if (result.length === limit) break;\n    }\n\n    return skipped;\n  }\n\n  _addTileFeatures(ids, points, x, y, z2, tile) {\n    for (const i of ids) {\n      const c = points[i];\n      const f = {\n        type: 1,\n        geometry: [[Math.round(this.options.extent * (c.x * z2 - x)), Math.round(this.options.extent * (c.y * z2 - y))]],\n        tags: c.numPoints ? getClusterProperties(c) : this.points[c.index].properties\n      };\n      const id = c.numPoints ? c.id : this.points[c.index].id;\n\n      if (id !== undefined) {\n        f.id = id;\n      }\n\n      tile.features.push(f);\n    }\n  }\n\n  _limitZoom(z) {\n    return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));\n  }\n\n  _cluster(points, zoom) {\n    const clusters = [];\n    const _this$options3 = this.options,\n          radius = _this$options3.radius,\n          extent = _this$options3.extent,\n          reduce = _this$options3.reduce;\n    const r = radius / (extent * Math.pow(2, zoom)); // loop through each point\n\n    for (let i = 0; i < points.length; i++) {\n      const p = points[i]; // if we've already visited the point at this zoom level, skip it\n\n      if (p.zoom <= zoom) continue;\n      p.zoom = zoom; // find all nearby points\n\n      const tree = this.trees[zoom + 1];\n      const neighborIds = tree.within(p.x, p.y, r);\n      let numPoints = p.numPoints || 1;\n      let wx = p.x * numPoints;\n      let wy = p.y * numPoints;\n      let clusterProperties = reduce && numPoints > 1 ? this._map(p, true) : null; // encode both zoom and point index on which the cluster originated\n\n      const id = (i << 5) + (zoom + 1);\n\n      for (const neighborId of neighborIds) {\n        const b = tree.points[neighborId]; // filter out neighbors that are already processed\n\n        if (b.zoom <= zoom) continue;\n        b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n        const numPoints2 = b.numPoints || 1;\n        wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n\n        wy += b.y * numPoints2;\n        numPoints += numPoints2;\n        b.parentId = id;\n\n        if (reduce) {\n          if (!clusterProperties) clusterProperties = this._map(p, true);\n          reduce(clusterProperties, this._map(b));\n        }\n      }\n\n      if (numPoints === 1) {\n        clusters.push(p);\n      } else {\n        p.parentId = id;\n        clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n      }\n    }\n\n    return clusters;\n  }\n\n  _map(point, clone) {\n    if (point.numPoints) {\n      return clone ? extend({}, point.properties) : point.properties;\n    }\n\n    const original = this.points[point.index].properties;\n    const result = this.options.map(original);\n    return clone && result === original ? extend({}, result) : result;\n  }\n\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n  return {\n    x,\n    // weighted cluster center\n    y,\n    zoom: Infinity,\n    // the last zoom the cluster was processed at\n    id,\n    // encodes index of the first child of the cluster and its zoom level\n    parentId: -1,\n    // parent cluster id\n    numPoints,\n    properties\n  };\n}\n\nfunction createPointCluster(p, id) {\n  const _p$geometry$coordinat = _slicedToArray(p.geometry.coordinates, 2),\n        x = _p$geometry$coordinat[0],\n        y = _p$geometry$coordinat[1];\n\n  return {\n    x: lngX(x),\n    // projected point coordinates\n    y: latY(y),\n    zoom: Infinity,\n    // the last zoom the point was processed at\n    index: id,\n    // index of the source feature in the original input array,\n    parentId: -1 // parent cluster id\n\n  };\n}\n\nfunction getClusterJSON(cluster) {\n  return {\n    type: 'Feature',\n    id: cluster.id,\n    properties: getClusterProperties(cluster),\n    geometry: {\n      type: 'Point',\n      coordinates: [xLng(cluster.x), yLat(cluster.y)]\n    }\n  };\n}\n\nfunction getClusterProperties(cluster) {\n  const count = cluster.numPoints;\n  const abbrev = count >= 10000 ? `${Math.round(count / 1000)}k` : count >= 1000 ? `${Math.round(count / 100) / 10}k` : count;\n  return extend(extend({}, cluster.properties), {\n    cluster: true,\n    cluster_id: cluster.id,\n    point_count: count,\n    point_count_abbreviated: abbrev\n  });\n} // longitude/latitude to spherical mercator in [0..1] range\n\n\nfunction lngX(lng) {\n  return lng / 360 + 0.5;\n}\n\nfunction latY(lat) {\n  const sin = Math.sin(lat * Math.PI / 180);\n  const y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n} // spherical mercator to longitude/latitude\n\n\nfunction xLng(x) {\n  return (x - 0.5) * 360;\n}\n\nfunction yLat(y) {\n  const y2 = (180 - y * 360) * Math.PI / 180;\n  return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n  for (const id in src) dest[id] = src[id];\n\n  return dest;\n}\n\nfunction getX(p) {\n  return p.x;\n}\n\nfunction getY(p) {\n  return p.y;\n}","map":{"version":3,"sources":["/Users/renshihang/Desktop/svvlbn.run/node_modules/@antv/l7-source/node_modules/supercluster/index.js"],"names":["KDBush","defaultOptions","minZoom","maxZoom","radius","extent","nodeSize","log","reduce","map","props","Supercluster","constructor","options","extend","Object","create","trees","Array","load","points","console","time","timerId","length","clusters","i","geometry","push","createPointCluster","getX","getY","Float32Array","timeEnd","z","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","Math","max","min","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","ids","range","lngX","latY","id","c","numPoints","getClusterJSON","index","getChildren","clusterId","originId","originZoom","errorMsg","Error","origin","r","pow","within","x","y","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","p","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","clusterZoom","properties","cluster_id","result","skipped","child","cluster","point_count","f","type","round","tags","getClusterProperties","undefined","neighborIds","wx","wy","clusterProperties","_map","neighborId","b","numPoints2","createCluster","point","clone","original","Infinity","coordinates","xLng","yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","exp","dest","src"],"mappings":"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","sourcesContent":["\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = clusterId >> 5;\n        const originZoom = clusterId % 32;\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let clusterZoom = (clusterId % 32) - 1;\n        while (clusterZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            clusterZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return clusterZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (c.x * z2 - x)),\n                    Math.round(this.options.extent * (c.y * z2 - y))\n                ]],\n                tags: c.numPoints ? getClusterProperties(c) : this.points[c.index].properties\n            };\n            const id = c.numPoints ? c.id : this.points[c.index].id;\n            if (id !== undefined) {\n                f.id = id;\n            }\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            let numPoints = p.numPoints || 1;\n            let wx = p.x * numPoints;\n            let wy = p.y * numPoints;\n\n            let clusterProperties = reduce && numPoints > 1 ? this._map(p, true) : null;\n\n            // encode both zoom and point index on which the cluster originated\n            const id = (i << 5) + (zoom + 1);\n\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom <= zoom) continue;\n                b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                const numPoints2 = b.numPoints || 1;\n                wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                wy += b.y * numPoints2;\n\n                numPoints += numPoints2;\n                b.parentId = id;\n\n                if (reduce) {\n                    if (!clusterProperties) clusterProperties = this._map(p, true);\n                    reduce(clusterProperties, this._map(b));\n                }\n            }\n\n            if (numPoints === 1) {\n                clusters.push(p);\n            } else {\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n            }\n        }\n\n        return clusters;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x, // weighted cluster center\n        y,\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: lngX(x), // projected point coordinates\n        y: latY(y),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n"]},"metadata":{},"sourceType":"module"}