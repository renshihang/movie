"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextTriangulation = TextTriangulation;
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _l7Core = require("@antv/l7-core");

var _l7Utils = require("@antv/l7-utils");

var _BaseModel2 = _interopRequireDefault(require("../../core/BaseModel"));

var _collisionIndex = _interopRequireDefault(require("../../utils/collision-index"));

var _geo = require("../../utils/geo");

var _symbolLayout = require("../../utils/symbol-layout");

var textFrag = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\nuniform sampler2D u_sdf_map;\nuniform float u_gamma_scale : 0.5;\nuniform float u_font_size : 24;\nuniform float u_opacity : 1.0;\nuniform vec4 u_stroke : [0, 0, 0, 1];\nuniform float u_strokeWidth : 2.0;\nuniform float u_halo_blur : 0.5;\nuniform float u_DevicePixelRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\n\n#pragma include \"picking\"\nvoid main() {\n  // get sdf from atlas\n  float dist = texture2D(u_sdf_map, v_uv).a;\n\n  float fontScale = u_font_size / 24.0;\n\n  lowp float buff = (6.0 - u_strokeWidth / fontScale) / SDF_PX;\n  highp float gamma = (u_halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * u_gamma_scale) / 1.0;\n\n  highp float gamma_scaled = gamma * v_gamma_scale;\n\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n\n  gl_FragColor = mix(v_color * u_opacity, u_stroke, smoothstep(0., 0.5, 1. - dist)) * alpha;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var textVert = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\nattribute vec3 a_Position;\nattribute vec2 a_tex;\nattribute vec2 a_textOffsets;\nattribute vec4 a_Color;\nattribute float a_Size;\n\nuniform vec2 u_sdf_map_size;\nuniform mat4 u_ModelMatrix;\n\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying vec4 v_color;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  v_color = a_Color;\n  v_uv = a_tex / u_sdf_map_size;\n\n  // \u6587\u672C\u7F29\u653E\u6BD4\u4F8B\n  float fontScale = a_Size / 24.;\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n  vec4 projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  gl_Position = vec4(projected_position.xy / projected_position.w\n    + a_textOffsets * fontScale / u_ViewportSize * 2. * u_DevicePixelRatio, 0.0, 1.0);\n  v_gamma_scale = gl_Position.w;\n  setPickingColor(a_PickingColor);\n\n}\n";

function TextTriangulation(feature) {
  var centroid = feature.centroid;
  var glyphQuads = feature.glyphQuads;
  var vertices = [];
  var indices = [];
  var coord = centroid.length === 2 ? [centroid[0], centroid[1], 0] : centroid;
  glyphQuads.forEach(function (quad, index) {
    vertices.push.apply(vertices, (0, _toConsumableArray2.default)(coord).concat([quad.tex.x, quad.tex.y + quad.tex.height, quad.tl.x, quad.tl.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x + quad.tex.width, quad.tex.y + quad.tex.height, quad.tr.x, quad.tr.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x + quad.tex.width, quad.tex.y, quad.br.x, quad.br.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x, quad.tex.y, quad.bl.x, quad.bl.y]));
    indices.push(0 + index * 4, 1 + index * 4, 2 + index * 4, 2 + index * 4, 3 + index * 4, 0 + index * 4);
  });
  return {
    vertices: vertices,
    indices: indices,
    size: 7
  };
}

var TextModel = function (_BaseModel) {
  (0, _inherits2.default)(TextModel, _BaseModel);

  function TextModel() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, TextModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(TextModel)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _this.texture = void 0;
    _this.glyphInfo = void 0;
    _this.currentZoom = -1;
    _this.extent = void 0;
    return _this;
  }

  (0, _createClass2.default)(TextModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$fontWeight = _ref.fontWeight,
          fontWeight = _ref$fontWeight === void 0 ? 800 : _ref$fontWeight,
          _ref$fontFamily = _ref.fontFamily,
          fontFamily = _ref$fontFamily === void 0 ? 'sans-serif' : _ref$fontFamily,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? '#fff' : _ref$stroke,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 0 : _ref$strokeWidth;

      var canvas = this.fontService.canvas;
      return {
        u_opacity: 1.0,
        u_sdf_map: this.texture,
        u_stroke: (0, _l7Utils.rgb2arr)(stroke),
        u_halo_blur: 0.5,
        u_sdf_map_size: [canvas.width, canvas.height],
        u_strokeWidth: strokeWidth
      };
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      this.extent = this.textExtent();
      this.initGlyph();
      this.updateTexture();
      this.filterGlyphs();
      return [this.layer.buildLayerModel({
        moduleName: 'pointText',
        vertexShader: textVert,
        fragmentShader: textFrag,
        triangulation: TextTriangulation,
        depth: {
          enable: false
        },
        blend: this.getBlend()
      })];
    }
  }, {
    key: "needUpdate",
    value: function needUpdate() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$textAllowOverla = _ref2.textAllowOverlap,
          textAllowOverlap = _ref2$textAllowOverla === void 0 ? false : _ref2$textAllowOverla;

      var zoom = this.mapService.getZoom();
      var extent = this.mapService.getBounds();
      var flag = extent[0][0] < this.extent[0][0] || extent[0][1] < this.extent[0][1] || extent[1][0] > this.extent[1][0] || extent[1][1] < this.extent[1][1];

      if (!textAllowOverlap && (Math.abs(this.currentZoom - zoom) > 1 || flag)) {
        this.filterGlyphs();
        this.layer.models = [this.layer.buildLayerModel({
          moduleName: 'pointText',
          vertexShader: textVert,
          fragmentShader: textFrag,
          triangulation: TextTriangulation,
          depth: {
            enable: false
          },
          blend: this.getBlend()
        })];
        return true;
      }

      return false;
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'textOffsets',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_textOffsets',
          buffer: {
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[5], vertex[6]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var size = feature.size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'textUv',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_tex',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }, {
    key: "textExtent",
    value: function textExtent() {
      var bounds = this.mapService.getBounds();
      var step = Math.min(bounds[1][0] - bounds[0][0], bounds[1][1] - bounds[1][0]) / 2;
      return [[bounds[0][0] - step, bounds[0][1] - step], [bounds[1][0] + step, bounds[1][1] + step]];
    }
  }, {
    key: "initTextFont",
    value: function initTextFont() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$fontWeight = _ref3.fontWeight,
          fontWeight = _ref3$fontWeight === void 0 ? '800' : _ref3$fontWeight,
          fontFamily = _ref3.fontFamily;

      var data = this.layer.getEncodedData();
      var characterSet = [];
      data.forEach(function (item) {
        var _item$shape = item.shape,
            shape = _item$shape === void 0 ? '' : _item$shape;
        shape = shape.toString();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = shape[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var char = _step.value;

            if (characterSet.indexOf(char) === -1) {
              characterSet.push(char);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      });
      this.fontService.setFontOptions({
        characterSet: characterSet,
        fontWeight: fontWeight,
        fontFamily: fontFamily
      });
    }
  }, {
    key: "generateGlyphLayout",
    value: function generateGlyphLayout() {
      var mapping = this.fontService.mapping;

      var _ref4 = this.layer.getLayerConfig(),
          _ref4$spacing = _ref4.spacing,
          spacing = _ref4$spacing === void 0 ? 2 : _ref4$spacing,
          _ref4$textAnchor = _ref4.textAnchor,
          textAnchor = _ref4$textAnchor === void 0 ? 'center' : _ref4$textAnchor,
          textOffset = _ref4.textOffset;

      var data = this.layer.getEncodedData();
      this.glyphInfo = data.map(function (feature) {
        var _feature$shape = feature.shape,
            shape = _feature$shape === void 0 ? '' : _feature$shape,
            coordinates = feature.coordinates;
        var shaping = (0, _symbolLayout.shapeText)(shape.toString(), mapping, 24, textAnchor, 'center', spacing, textOffset);
        var glyphQuads = (0, _symbolLayout.getGlyphQuads)(shaping, textOffset, false);
        feature.shaping = shaping;
        feature.glyphQuads = glyphQuads;
        feature.centroid = (0, _geo.calculteCentroid)(coordinates);
        return feature;
      });
    }
  }, {
    key: "filterGlyphs",
    value: function filterGlyphs() {
      var _this2 = this;

      var _ref5 = this.layer.getLayerConfig(),
          _ref5$padding = _ref5.padding,
          padding = _ref5$padding === void 0 ? [4, 4] : _ref5$padding,
          _ref5$textAllowOverla = _ref5.textAllowOverlap,
          textAllowOverlap = _ref5$textAllowOverla === void 0 ? false : _ref5$textAllowOverla;

      if (textAllowOverlap) {
        return;
      }

      this.currentZoom = this.mapService.getZoom();
      this.extent = this.textExtent();

      var _this$rendererService = this.rendererService.getViewportSize(),
          width = _this$rendererService.width,
          height = _this$rendererService.height;

      var collisionIndex = new _collisionIndex.default(width, height);
      var filterData = this.glyphInfo.filter(function (feature) {
        var shaping = feature.shaping,
            _feature$id = feature.id,
            id = _feature$id === void 0 ? 0 : _feature$id;
        var centroid = feature.centroid;
        var size = feature.size;
        var fontScale = size / 24;

        var pixels = _this2.mapService.lngLatToContainer(centroid);

        var _collisionIndex$place = collisionIndex.placeCollisionBox({
          x1: shaping.left * fontScale - padding[0],
          x2: shaping.right * fontScale + padding[0],
          y1: shaping.top * fontScale - padding[1],
          y2: shaping.bottom * fontScale + padding[1],
          anchorPointX: pixels.x,
          anchorPointY: pixels.y
        }),
            box = _collisionIndex$place.box;

        if (box && box.length) {
          collisionIndex.insertCollisionBox(box, id);
          return true;
        } else {
          return false;
        }
      });
      this.layer.setEncodedData(filterData);
    }
  }, {
    key: "initGlyph",
    value: function initGlyph() {
      this.initTextFont();
      this.generateGlyphLayout();
    }
  }, {
    key: "updateTexture",
    value: function updateTexture() {
      var createTexture2D = this.rendererService.createTexture2D;
      var canvas = this.fontService.canvas;
      this.texture = createTexture2D({
        data: canvas,
        width: canvas.width,
        height: canvas.height
      });
    }
  }]);
  return TextModel;
}(_BaseModel2.default);

exports.default = TextModel;
//# sourceMappingURL=text.js.map